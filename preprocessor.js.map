{"version":3,"sources":["webpack://c2wasm/./node_modules/moo/moo.js","webpack://c2wasm/./demos/preprocessor.ts","webpack://c2wasm/./src/c_error.ts","webpack://c2wasm/./src/c_library/standard_library.ts","webpack://c2wasm/./src/parsing/index.ts","webpack://c2wasm/./src/parsing/lexer.ts","webpack://c2wasm/./src/parsing/parser.ts","webpack://c2wasm/./src/parsing/parsetree.ts","webpack://c2wasm/./src/parsing/validation.ts","webpack://c2wasm/./src/preprocessor/conditionals.ts","webpack://c2wasm/./src/preprocessor/definition.ts","webpack://c2wasm/./src/preprocessor/helpers.ts","webpack://c2wasm/./src/preprocessor/index.ts","webpack://c2wasm/./src/preprocessor/preprocessor.ts","webpack://c2wasm/./src/tree/declarations.ts","webpack://c2wasm/./src/tree/expressions.ts","webpack://c2wasm/./src/tree/scope.ts","webpack://c2wasm/./src/tree/statements.ts","webpack://c2wasm/./src/tree/transform/constant_expressions.ts","webpack://c2wasm/./src/tree/transform/expr_transform.ts","webpack://c2wasm/./src/tree/transform/type_transform.ts","webpack://c2wasm/./src/tree/type_checking.ts","webpack://c2wasm/./src/tree/types.ts","webpack://c2wasm/./src/parsing/gen/c_grammar.js","webpack://c2wasm/webpack/bootstrap","webpack://c2wasm/webpack/startup"],"names":["hasOwnProperty","Object","prototype","toString","hasSticky","RegExp","sticky","isRegExp","o","call","isObject","Array","isArray","reEscape","s","replace","reGroups","exec","length","reCapture","reUnion","regexps","map","join","regexpOrLiteral","obj","ignoreCase","Error","global","multiline","source","objectToRules","object","keys","getOwnPropertyNames","result","i","key","thing","rules","concat","match","forEach","rule","push","ruleOptions","j","include","arrayToRules","array","type","JSON","stringify","options","defaultType","lineBreaks","error","fallback","pop","next","value","shouldThrow","sort","a","b","toRules","spec","defaultErrorRule","compileRules","hasStates","errorRule","fast","create","fastAllowed","unicodeFlag","groups","parts","slice","shift","charCodeAt","unicode","pat","regexp","test","fallbackRule","flags","suffix","compile","Lexer","start","checkStateGroup","g","name","state","compileStates","states","all","$all","ruleMap","included","splice","newRules","k","newRule","indexOf","apply","fastKeys","keywordTransform","reverseMap","byLength","types","tokenType","item","keyword","str","x","keywords","Function","this","startState","buffer","stack","reset","data","info","index","line","col","queuedToken","queuedThrow","setState","save","re","popState","pushState","eat","tokenToString","_getGroup","groupCount","undefined","queuedGroup","token","_token","queuedText","group","charAt","lastIndex","text","offset","matchNL","nl","size","formatError","Symbol","iterator","LexerIterator","lexer","done","message","Math","max","eol","firstLine","substring","clone","has","freeze","testInput","trimStart","process","input","preprocessor","Preprocessor","libraryFiles","set","userFiles","e","console","debug","window","document","write","textInput","getElementById","output","addEventListener","textContent","log","CError","node","node2","super","loc","locationString","label","lines","_source","split","first_line","lnumDigits","ceil","log10","last_line","outputLine","lnum","padStart","first_column","last_column","JSON_CACHE","__dirname","IMPL_FOLDER","lib","existsSync","list","folder","baseFolder","files","Map","path","readdirSync","statSync","isDirectory","endsWith","contents","readFileSync","json","parse","values","entries","cacheOutOfDate","trace","writeFileSync","updateCache","warn","STANDARD_LIBRARY","LIBRARY_HEADERS","ParseNode","ParseTreeValidationError","$comment","IDENTIFIER","fromEntries","toUpperCase","CONSTANT_FLOAT","CONSTANT_HEX","CONSTANT_OCTAL","CONSTANT_INT","CONSTANT_CHAR","STRING_LITERAL","ELLIPSIS","RIGHT_ASSIGN","LEFT_ASSIGN","ADD_ASSIGN","SUB_ASSIGN","MUL_ASSIGN","DIV_ASSIGN","MOD_ASSIGN","AND_ASSIGN","XOR_ASSIGN","OR_ASSIGN","RIGHT_OP","LEFT_OP","INC_OP","DEC_OP","PTR_OP","AND_OP","OR_OP","LE_OP","GE_OP","EQ_OP","NE_OP","$whitespace","tok","nextSourceId","generatedParser","parser","WrappedLexer","yylloc","_sourceId","yylineno","yytext","get","clear","d","typeInfo","storageList","declarator","parsetree","IdentifierDeclarator","body","id","tree","validate","hash","Expression","_expression","Identifier","Constant","valueType","StringLiteral","UnaryOperations","UnaryExpression","_unaryExpr","BinaryOperations","BinaryExpression","lhs","rhs","_binaryExpr","SizeofExpression","CastExpression","targetType","FunctionCallExpression","fn","args","MemberAccessExpression","pointer","ConditionalExpression","condition","trueValue","falseValue","AssignmentExpression","assignType","ConstantExpression","expr","CustomTypeSpecifier","SpecifierQualifiers","specifierList","qualifierList","specifier","DeclarationSpecifiers","fnSpecifierList","EnumSpecifier","Enumerator","Declaration","InitDeclarator","initializer","exploreInitializer","StructUnionSpecifier","structure","declarations","StructDeclaration","PointerDeclarator","abstractDeclarator","ArrayDeclarator","FunctionDeclarator","variadic","ParameterDeclaration","Pointer","TypeName","AbstractPointerDeclarator","AbstractArrayDeclarator","AbstractFunctionDeclarator","Statement","_statement","IfStatement","expression","ifBody","elseBody","SwitchStatement","CaseStatement","DefaultStatement","CompoundStatement","ExpressionStatement","NoOp","ForLoop","init","update","WhileLoop","DoWhileLoop","GotoStatement","target","ContinueStatement","BreakStatement","ReturnStatement","FunctionDefinition","validatorMap","nodeList","parents","children","validator","getPrototypeOf","constructor","validators","typeValidation","every","v","getArithmeticType","typeLookup","constExprValidation","n","pt","parent","_eval","BigInt","ptConstant","parseTree","Definition","identifier","replacement","parameters","expandWithParameters","originalLine","consume","PreProRegex","whitespace","remainingLine","mustConsume","consumeArgument","trim","expandDefinitions","out","inQuote","bracketDepth","char","consumed","t","comments","PreprocessorBase","success","errorName","startsWith","filename","standardHeaders","definitions","_define","_undef","_include","_ifdef","_if","defName","consumeAny","def","expand","_includeUser","_includeLib","file","localPath","tokens","parameter","includes","existing","equals","delete","ifdef","unshift","_condition","anyCondition","depth","hadElse","trimEnd","processed","matchAll","definitionName","ppEvaluate","CVarDeclaration","storage","linkage","declType","_addressUsed","_definition","addressUsed","CVarDefinition","dependencies","CArgument","CFuncDeclaration","fnImport","CFuncImport","declaration","CFuncDefinition","translationUnit","CCompoundStatement","CConstant","lvalue","newValue","CArithmetic","BOOL","Number","maxValue","minValue","checks","ExpressionTypeError","CIdentifier","CFuncType","CArrayPointer","arrayIdentifier","CArray","CPointer","CStringLiteral","U8","CFunctionCall","fnType","asFunction","returnType","parameterTypes","CAssignment","checkAssignmentValid","identifiers","CMemberAccess","member","pointerType","asPointer","structUnion","asStructOrUnion","memberType","CIncrDecr","op","pos","checkLvalue","asNonFunctionPointer","asArithmeticOrPointer","checkTypeComplete","CSizeof","CSizeT","incomplete","bytes","typeName","CAddressOf","CDereference","CUnaryPlusMinus","bodyType","asArithmetic","integerPromotion","CBitwiseNot","asInteger","S32","CLogicalNot","CCast","CMulDiv","usualArithmeticConversion","CMod","CAddSub","CShift","dir","CRelational","commonType","CEquality","CBitwiseAndOr","CLogicalAndOr","CConditional","CVoid","otherValue","assignmentType","initialAssignment","getQualifier","CStruct","CUnion","hasConstMember","CInitializer","rhsType","_checkAssignmentTypeValid","varType","qualifier","CComma","_memberTypes","_type","Infinity","typeCheck","members","c","desiredType","changeType","Scope","func","tags","typedefs","tag","_getTag","wantedType","ScopeError","_getId","definition","_getTypedef","statements","scope","CExpressionStatement","CNop","CIf","CForLoop","CWhileLoop","CDoLoop","CGoto","CSwitch","CContinue","loop","CBreak","CReturn","CLabelledStatement","constExpression","extra","staticValue","normalizeType","constInteger","isNaN","bitmask","U32","normalizeValueType","ptExpression","lookupIdentifier","arr","charRegex","unescapeChar","codePointAt","ptUnary","ptBinary","bodyExpr","getType","num","possibleTypes","unsigned","long","toLowerCase","U64","S64","Fp32","Fp64","parseFloat","parseInt","String","fromCharCode","codePoint","specifiers","singleSpecifier","lookupTag","addTag","baseType","getDeclaratorType","getDeclaratorName","CCompoundMember","cEnum","CEnum","nextValue","evalIntegerConstant","enumConstant","addQualifier","addIdentifier","lookupTypedef","getSpecifierType","ptr","parameterNames","param","actualType","arithmetic","alignment","other","constant","_members","reduce","total","m","find","_values","S8","U16","S16","constType","setPrototypeOf","_base","t1","t2","copy","remove","idx","check","c_grammar","JisonParserError","msg","stacktrace","defineProperty","enumerable","writable","exception","ex2","captureStackTrace","l","u","rv","yy","hasPartialLrUpgradeOnConflict","errorRecoveryTokenDiscardCount","symbols_","terminals_","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","TERROR","EOF","originalQuoteName","originalParseError","cleanupAfterParse","constructParseErrorInfo","yyMergeLocationInfo","__reentrant_call_depth","__error_infos","__error_recovery_infos","quoteName","id_str","getSymbolName","symbol","describeSymbol","terminal_descriptions_","collect_expected_token_set","do_not_describe","tokenset","state_descriptions_","p","table","productions_","r","bp","performAction","yyloc","yystate","yysp","yyvstack","yylstack","yyparser","yylexer","$","_$","setLabel","externalDeclaration","len","y","mode","goto","q","z","bt","defaultActions","bda","parseError","ExceptionClass","recoverable","destroy","self","sstack","vstack","lstack","sp","NO_ACTION","__lexer__","sharedState_yy","pre_parse","post_parse","pre_lex","post_lex","shallow_copy","src","dst","shallow_copy_noclobber","copy_yylloc","range","fastLex","assert","yyGetSharedState","resultValue","invoke_post_methods","do_not_nuke_errorinfos","cleanupAfterLex","el","first_index","last_index","first_yylloc","last_yylloc","dont_look_back","i1","i2","l1","l2","ex","expected","pei","errStr","token_id","action","new_state","newState","symbol_stack","state_stack","value_stack","location_stack","stack_pointer","rec","yyrulelen","this_production","lex","yyval","retval","setInput","canIUse","errSymbolDescr","showPosition","ntsymbol","JisonLexerError","Parser","exports","arguments","__webpack_module_cache__","__webpack_require__","moduleId","module","__webpack_modules__"],"mappings":"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GAIR,IAHA,IAAIopB,EAAK,GACLkH,EAAItwB,EAAE4C,IACN6tB,EAAIzwB,EAAE6B,KACDP,EAAI,EAAG4nB,EAAIoH,EAAElwB,OAAQkB,EAAI4nB,EAAG5nB,IACjC8nB,EAAGtnB,KAAK,CACJwuB,EAAEhvB,GACFmvB,EAAEnvB,KAGV,OAAO8nB,EAggBLsH,CAAG,CACf9tB,IAAKumB,EAAE,CACP,GACA,GACA,GACAnpB,EACA,CAAC,GAAI,GACL,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,MAEA6B,KAAMsnB,EAA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A,GACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,GACA,EACA,GACA,GACA,GACA,GACA,GACA+hB,EACA,CAAC,GAAI,GACL/hB,EACA,CAAC,EAAG,GACJ,GACA,EACA,EACA,GACA,GACA,GACAA,EACA,CAAC,EAAG,GACJ,GACA,EACA,GACA,GACA,GACA,GACA,GACA,EACA,EACA,GACA+hB,EACA,CAAC,GAAI,GACL/hB,EACA,CAAC,EAAG,GACJ,GACA,GACA,EACA,EACA,EACAA,EACA,CAAC,EAAG,GACJ,GACA,EACA+hB,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,IAAK,GACN,EACA/hB,EACA,CAAC,EAAG,GACJ+hB,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,GACA,EACAA,EACA,CAAC,EAAG,GACJ/hB,EACA,CAAC,EAAG,GACJ,EACA,GACA,EACA,EACA,EACA,GACAA,EACA,CAAC,EAAG,IACJ,GACA,GACA,GACA,GACA+hB,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJ/hB,EACA,CAAC,EAAG,GACJ,GACA,GACA,GACA+hB,EACA,CAAC,GAAI,GACL,EACA,GACA,GACA,GACA,GACA/hB,EACA,CAAC,GAAI,GACL,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,EACA,EACA,GACA,EACA,GACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,EACA,GACA+hB,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,EACA,EACA,EACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACL,EACA,GACA,GACA,EACA,GACAA,EACA,CAAC,IAAK,GACN,GACA,GACA,GACA,GACA/hB,EACA,CAAC,GAAI,GACL,GACA,GACA,GACA+hB,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,EACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,GACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACL,EACA,GACA,EACAA,EACA,CAAC,IAAK,GACN/hB,EACA,CAAC,GAAI,GACL,GACA,GACA,GACA+hB,EACA,CAAC,GAAI,GACL,EACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,IAEAgO,OAAQ5G,EAAE,CACV,EACAnpB,EACA,CAAC,GAAI,GAAI,GACT,GACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,EACA+hB,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,IACA,EACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,KACL,GACA,GACA,GACAA,EACA,CAAC,EAAG,GACJ,EACA,GACA,GACA,GACA,IACA,EACA,GACA,EACA,GACA,GACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,GACA,IACA,IACA,IACA,EACA,GACA,GACA,GACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL/hB,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,GACA,GACA,IACA,IACA+hB,EACA,CAAC,GAAI,IACL,EACA/hB,EACA,CAAC,EAAG,EAAG,GACP,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACRA,EACA,CAAC,GAAI,GAAI,GACT,IACA+hB,EACA,CAAC,GAAI,GACL/hB,EACA,CAAC,GAAI,GAAI,GACT+hB,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,GACA,GACA,GACA/hB,EACA,CAAC,GAAI,EAAG,GACR+hB,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,GACN/hB,EACA,CAAC,IAAK,EAAG,GACT+hB,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACA,EACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,EACA,GACA,EACA,GACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACA,EACA,EACA/hB,EACA,CAAC,EAAG,EAAG,GACPA,EACA,CAAC,GAAI,GAAI,GACT,GACAA,EACA,CAAC,GAAI,GAAI,GACT,IACA+hB,EACA,CAAC,GAAI,GACL,GACA,GACA,GACA,GACA,GACA/hB,EACA,CAAC,EAAG,GAAI,GACR+hB,EACA,CAAC,GAAI,IACL,GACA,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN/hB,EACA,CAAC,GAAI,EAAG,GACR+hB,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACL,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACP,EACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,KAAM,GACP/hB,EACA,CAAC,EAAG,GACJ+hB,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,EACA,EACA,EACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACP,IACA,IACAA,EACA,CAAC,IAAK,IACN,EACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,EACAA,EACA,CAAC,GAAI,IACL/hB,EACA,CAAC,GAAI,GAAI,GACT,GACA,GACA,GACA,GACA+hB,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,EACA,EACA,EACAA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,KACNA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACP,IACA,GACA,EACA,GACA/hB,EACA,CAAC,GAAI,GAAI,GACT+hB,EACA,CAAC,GAAI,GACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACP,EACA,GACAA,EACA,CAAC,KAAM,GACP,EACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACN,EACA,EACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACL,EACA,EACAA,EACA,CAAC,KAAM,IACP/hB,EACA,CAAC,GAAI,EAAG,GACR+hB,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,OAEN3f,KAAM+mB,EAAE,CACRnpB,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,IACJ,EACA+hB,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL/hB,EACA,CAAC,EAAG,IACJ+hB,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACN/hB,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,IACJ+hB,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACN/hB,EACA,CAAC,EAAG,IACJ+hB,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACN/hB,EACA,CAAC,EAAG,KACJ+hB,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACN/hB,EACA,CAAC,EAAG,KACJ+hB,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,IAAK,MAENhd,MAAOokB,EAAE,CACT,EACAnpB,EACA,CAAC,EAAG,EAAG,GACP,GACA,GACA,GACA,GACA,GACA,EACAA,EACA,CAAC,EAAG,EAAG,GACP+hB,EACA,CAAC,GAAI,GACL,GACA,EACA,GACA,GACA,GACA,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,GACAA,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,EAAG,GACJ,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,GACA,GACA/hB,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA+hB,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,IACA,IACA,IACA/hB,EACA,CAAC,IAAK,EAAG,GACT,GACA,IACA,IACA,GACA,GACA+hB,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,GACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,GACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,IACA,GACA,IACAA,EACA,CAAC,EAAG,GACJ,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACA/hB,EACA,CAAC,IAAK,EAAG,GACT,IACA+hB,EACA,CAAC,IAAK,IACN,IACA,GACA,IACA,GACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,IAAK,IACN,IACA/hB,EACA,CAAC,IAAK,EAAG,GACT+hB,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,GACA,GACA,IACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,GACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACA,GACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,KAEL0P,KAAMtI,EAAE,CACRnpB,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,GACJ+hB,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,GACL,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL/hB,EACA,CAAC,EAAG,IACJ+hB,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL/hB,EACA,CAAC,EAAG,IACJ+hB,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,EAAG,IACJA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN/hB,EACA,CAAC,EAAG,KACJ+hB,EACA,CAAC,IAAK,KACN/hB,EACA,CAAC,EAAG,KACJ+hB,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,KACN/hB,EACA,CAAC,EAAG,IACJ+hB,EACA,CAAC,IAAK,IACN/hB,EACA,CAAC,EAAG,OAEJ0xB,KAAMvI,EAAE,CACR,EACAnpB,EACA,CAAC,GAAI,GAAI,GACT,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA+hB,EACA,CAAC,GAAI,IACL,GACA,GACA,GACA,GACA/hB,EACA,CAAC,GAAI,GACL+hB,EACA,CAAC,GAAI,IACL/hB,EACA,CAAC,GAAI,GACL+hB,EACA,CAAC,GAAI,IACL/hB,EACA,CAAC,GAAI,GACL+hB,EACA,CAAC,GAAI,IACL/hB,EACA,CAAC,GAAI,GACL+hB,EACA,CAAC,GAAI,IACL,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA/hB,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,GACA,IACA,GACA,GACA,GACA,GACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,IAAK,IACN+hB,EACA,CAAC,GAAI,IACL,GACA/hB,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,GACA,GACA,GACA+hB,EACA,CAAC,GAAI,GACL,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACA,IACA/hB,EACA,CAAC,IAAK,EAAG,GACT+hB,EACA,CAAC,IAAK,GACN,GACA,IACA,GACA/hB,EACA,CAAC,IAAK,GACN,IACA,IACA+hB,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL/hB,EACA,CAAC,IAAK,GACN,GACA,IACA,GACA,IACA+hB,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL/hB,EACA,CAAC,IAAK,GACN+hB,EACA,CAAC,GAAI,IACL/hB,EACA,CAAC,IAAK,GACN+hB,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,GACAA,EACA,CAAC,IAAK,IACN/hB,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GAAI,GACVA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,GACA,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACA+hB,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL/hB,EACA,CAAC,GAAI,GACL,IACA,GACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL+hB,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN/hB,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACL+hB,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,IACN,GACA,GACA/hB,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL+hB,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,IACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,IACA,GACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA/hB,EACA,CAAC,GAAI,GACL,IACA,GACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL+hB,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN/hB,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACL+hB,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA/hB,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA+hB,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,QAGR+P,eA5+IQ,SAAa9xB,GAIT,IAHA,IAAIopB,EAAK,GACLxY,EAAI5Q,EAAEsoB,IACNzjB,EAAI7E,EAAE0xB,KACDpwB,EAAI,EAAG4nB,EAAItY,EAAExQ,OAAQkB,EAAI4nB,EAAG5nB,IAAK,CAEtC8nB,EADQxY,EAAEtP,IACFuD,EAAEvD,GAEd,OAAO8nB,EAo+IH2I,CAAI,CAClBzJ,IAAKa,EAAE,CACPnpB,EACA,CAAC,EAAG,EAAG,GACPA,EACA,CAAC,GAAI,GAAI,GACTA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACAA,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,KAET0xB,KAAMvI,EAAE,CACR,EACA,IACA,IACA,IACAnpB,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,IACA,IACA,IACA,EACA,IACA,GACA,GACA,IACA,EACAA,EACA,CAAC,GAAI,EAAG,GACR,IACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,EAAG,EAAG,GACP,GACA,EACA,GACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,GACA,GACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,GAAI,GACT,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,QAGFgyB,WAAY,SAAoB5rB,EAAKkL,EAAM2gB,GACvC,IAAI3gB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","file":"preprocessor.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var unicodeFlag = null\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match.slice()\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // Check unicode flag is used everywhere or nowhere\n      for (var j = 0; j < match.length; j++) {\n        var obj = match[j]\n        if (!isRegExp(obj)) {\n          continue\n        }\n\n        if (unicodeFlag === null) {\n          unicodeFlag = obj.unicode\n        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n          throw new Error('If one rule is /u then all must be')\n        }\n      }\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?:  ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n\n    if (unicodeFlag === true) flags += \"u\"\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n    var reverseMap = Object.create(null)\n    var byLength = Object.create(null)\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        reverseMap[keyword] = tokenType\n      })\n    }\n\n    // fast string lookup\n    // https://jsperf.com/string-lookups\n    function str(x) { return JSON.stringify(x) }\n    var source = ''\n    source += 'switch (value.length) {\\n'\n    for (var length in byLength) {\n      var keywords = byLength[length]\n      source += 'case ' + length + ':\\n'\n      source += 'switch (value) {\\n'\n      keywords.forEach(function(keyword) {\n        var tokenType = reverseMap[keyword]\n        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n'\n      })\n      source += '}\\n'\n    }\n    source += '}\\n'\n    return Function('value', source) // type\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      throw new Error(this.formatError(token, \"invalid syntax\"))\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    if (token == null) {\n      // An undefined token indicates EOF\n      var text = this.buffer.slice(this.index)\n      var token = {\n        text: text,\n        offset: this.index,\n        lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n        line: this.line,\n        col: this.col,\n      }\n    }\n    var start = Math.max(0, token.offset - token.col + 1)\n    var eol = token.lineBreaks ? token.text.indexOf('\\n') : token.text.length\n    var firstLine = this.buffer.substring(start, token.offset + eol)\n    message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\"\n    message += \"  \" + firstLine + \"\\n\"\n    message += \"  \" + Array(token.col).join(\" \") + \"^\"\n    return message\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n","import {Preprocessor} from \"../src/preprocessor\";\n\nconst testInput = `\nint factorial(int v) {\n  return v < 2 ? 1 : v * factorial(v - 1);\n}\n`.trimStart();\n\nfunction process(input: string): string {\n    try {\n        const preprocessor = new Preprocessor(\"main.c\");\n        for (let i = 0; i < 5; i++) {\n            preprocessor.libraryFiles.set(`library${i}.h`, `void library${i}() {}`);\n            preprocessor.userFiles.set(`user${i}.h`, `void user${i}() {}`);\n        }\n\n        return preprocessor.process(input);\n    } catch (e) {\n        console.debug(e);\n        return e.stack;\n    }\n}\n\nif (typeof window !== 'undefined' && window.document) {\n    window.document.write(`\n        <h1>c2wasm preprocessor</h1>\n        <div>\n            <textarea id=\"textInput\" rows=\"20\" style=\"width: 100%; resize: vertical\">${testInput}</textarea>\n            <pre id=\"output\">${process(testInput)}</pre>\n        </div>\n    `);\n\n    const textInput = window.document.getElementById(\"textInput\") as HTMLTextAreaElement;\n    const output = window.document.getElementById(\"output\") as HTMLPreElement;\n\n    textInput.addEventListener(\"input\", () => {\n        output.textContent = process(textInput.value);\n    });\n} else {\n    console.log(process(testInput));\n}\n","import type {Location, ParseNode} from \"./parsing\";\n\nexport class CError extends Error {\n    name = \"CError\";\n\n    constructor(message: string, readonly node?: ParseNode, readonly node2?: ParseNode) {\n        super(message);\n\n        if (node?.loc) {\n            this.message += \"\\n\\n\" + locationString(node.loc);\n            if (node2?.loc) this.message += \"\\n\\n\" + locationString(node2.loc, \"Secondary location\");\n        }\n    }\n}\n\nexport function locationString(loc: Location, label: string = \"Location\"): string {\n    const lines = loc._source.split(\"\\n\");\n    if (loc.first_line >= lines.length) return `${label}: [UNKNOWN]`;\n\n    let output = `${label}:\\n`;\n\n    const lnumDigits = Math.ceil(Math.log10(loc.last_line + 4));\n    function outputLine(lnum: number) {\n        output += `L${(lnum + 1).toString().padStart(lnumDigits, '0')}: ${lines[lnum]}\\n`;\n    }\n\n    if (loc.first_line > 1) outputLine(loc.first_line - 2);\n    if (loc.first_line > 0) outputLine(loc.first_line - 1);\n    outputLine(loc.first_line);\n\n    // output ^^^ arrows\n    output += new Array(3 + lnumDigits + loc.first_column).join(\" \");\n    if (loc.first_line === loc.last_line) {\n        output += new Array(1 + loc.last_column - loc.first_column).join(\"^\");\n    } else {\n        output += \"^\";\n    }\n    output += \"\\n\";\n\n    if (loc.first_line + 1 < lines.length) outputLine(loc.first_line + 1);\n    if (loc.first_line + 2 < lines.length) outputLine(loc.first_line + 2);\n    return output;\n}\n","import fs from \"fs\";\n\n/*\nLoad standard library from filesystem if available, or fall back to cached JSON (e.g. in web browser)\n */\n\nconst JSON_CACHE = __dirname + \"/_standard_library.json\";\nconst IMPL_FOLDER = __dirname + \"/impl/\";\n\nfunction list(folder: string, baseFolder: string, files: Map<string, string> = new Map<string, string>()){\n    for (const path of fs.readdirSync(baseFolder + folder)){\n        const name = folder.length > 0 ? folder + '/' + path : path;\n\n        if (fs.statSync(baseFolder + name).isDirectory()){\n            list(name, baseFolder, files);\n        } else {\n            if (!path.endsWith(\".h\") && !path.endsWith(\".c\")) continue;\n            const contents = fs.readFileSync(baseFolder + name, \"utf8\")\n                .replace(/\\r\\n/g, \"\\n\") // convert CRLF\n                .replace(/(?:\\/\\*[^]*?\\*\\/)|(?:\\/\\/.*?$)/gm, \" \") // remove comments\n                .replace(/^(?:[ \\t]*\\n+|[ \\t]+)/gm, \"\"); // remove leading whitespace and empty lines\n            files.set(name, contents);\n        }\n    }\n    return files;\n}\n\nfunction cacheOutOfDate(lib: Map<string, string>): boolean {\n    if (fs.existsSync(JSON_CACHE)) {\n        const contents = fs.readFileSync(JSON_CACHE, \"utf-8\");\n        const json = JSON.parse(contents);\n        if (Object.values(json).length !== lib.size) return true;\n        for (const [path, contents] of lib.entries()) {\n            if (json[path] !== contents) return true;\n        }\n        return false;\n    }\n    return true;\n}\n\nfunction updateCache(lib: Map<string, string>) {\n    console.trace(\"[standard library]: cache out of date\\n\");\n\n    const obj: {[s: string]: string} = {};\n    for (const [path, contents] of lib.entries()) {\n        obj[path] = contents;\n    }\n\n    fs.writeFileSync(JSON_CACHE, JSON.stringify(obj));\n}\n\nlet lib: Map<string, string>;\nif (Object.prototype.hasOwnProperty.call(fs, \"readdirSync\") && fs.existsSync(IMPL_FOLDER)) {\n    lib = list(\"\", IMPL_FOLDER);\n\n    try {\n        if (cacheOutOfDate(lib)) updateCache(lib);\n    } catch (e) {\n        console.warn(e);\n    }\n} else {\n    lib = new Map<string, string>();\n\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const obj = require(\"./_standard_library.json\") as {[s: string]: string};\n    Object.entries(obj).forEach(([path, contents]) => lib.set(path, contents));\n}\n\nexport const STANDARD_LIBRARY = lib as ReadonlyMap<string, string>;\nexport const LIBRARY_HEADERS = (() => {\n    const map = new Map<string, string>();\n    for (const [path, data] of lib.entries()) {\n        if (path.endsWith(\".h\")) map.set(path, data);\n    }\n    return map as ReadonlyMap<string, string>;\n})();\n","export * as pt from \"./parsetree\";\nexport {ParseNode, Location} from \"./parsetree\"; // the most common parsetree imports\nexport {ParseTreeValidationError} from \"./validation\";\nexport {parse} from \"./parser\";\n","import moo from \"moo\";\n\nconst keywords = [\n    \"if\", \"break\", \"case\", \"char\", \"const\", \"continue\", \"default\", \"do\", \"double\", \"else\", \"enum\", \"extern\", \"float\",\n    \"for\", \"inline\", \"int\", \"long\", \"return\", \"short\", \"signed\", \"sizeof\", \"static\", \"struct\", \"switch\", \"typedef\",\n    \"union\", \"unsigned\", \"void\", \"while\", \"_Bool\",\n\n    // currently unsupported (but still lex so parser throws error)\n    \"auto\", \"goto\", \"register\", \"volatile\",\n\n    // special for c2wasm, not on spec\n    \"import\"\n];\n\nconst simpleSymbols = [';','{','}',',',':','=','(',')','[',']','.','&','!','~','-','+','*','/','%','<','>','^','|','?'];\n\nexport const lexer = moo.compile({\n    $comment: {match: /(?:\\/\\*[^]*?\\*\\/)|(?:\\/\\/.*?$)/, multiline: true},\n    IDENTIFIER: {\n        match: /[a-zA-Z_][a-zA-Z0-9_]*/,\n        type: moo.keywords(Object.fromEntries(keywords.map(x => [x.toUpperCase(), x])))\n    },\n    CONSTANT_FLOAT: /(?:[0-9]+[Ee][+-]?[0-9]+|(?:[0-9]*\\.[0-9]+|[0-9]+\\.[0-9]*)(?:[Ee][+-]?[0-9]+)?)[fFlL]?|(?:[1-9][0-9]*|0)[fF]/,\n    CONSTANT_HEX: /0[xX][a-fA-F0-9]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    CONSTANT_OCTAL: /0[0-7]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    CONSTANT_INT: /(?:[1-9][0-9]*|0)(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    CONSTANT_CHAR: {match: /'(?:[^\\\\\\n']|\\\\(?:.|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))'/, value: x => x.slice(1, -1)},\n    STRING_LITERAL: {match: /\"(?:[^\\\\\\n\"]|\\\\(?:[^x0-7\\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))*\"/, value: x => x.slice(1, -1)},\n    ELLIPSIS: \"...\",\n    RIGHT_ASSIGN: \">>=\",\n    LEFT_ASSIGN: \"<<=\",\n    ADD_ASSIGN: \"+=\",\n    SUB_ASSIGN: \"-=\",\n    MUL_ASSIGN: \"*=\",\n    DIV_ASSIGN: \"/=\",\n    MOD_ASSIGN: \"%=\",\n    AND_ASSIGN: \"&=\",\n    XOR_ASSIGN: \"^=\",\n    OR_ASSIGN: \"|=\",\n    RIGHT_OP: \">>\",\n    LEFT_OP: \"<<\",\n    INC_OP: \"++\",\n    DEC_OP: \"--\",\n    PTR_OP: \"->\",\n    AND_OP: \"&&\",\n    OR_OP: \"||\",\n    LE_OP: \"<=\",\n    GE_OP: \">=\",\n    EQ_OP: \"==\",\n    NE_OP: \"!=\",\n    ...Object.fromEntries(simpleSymbols.map(x => [x,x])),\n    $whitespace: [\n        {match: /[ \\t\\v\\f]+/},\n        {match: /\\n/, lineBreaks: true},\n    ],\n});\n\n// automatically skip tokens starting with \"$\", i.e. whitespace, line breaks and comments\nlexer.next = (next => () => {\n    let tok = next.call(lexer);\n    while (tok?.type?.charAt(0) === '$') tok = next.call(lexer);\n    return tok;\n})(lexer.next);\n","import {locationString} from \"../c_error\";\nimport {lexer} from \"./lexer\";\nimport gen from \"./gen/c_grammar\";\nimport * as parsetree from \"./parsetree\";\nimport {validate} from \"./validation\";\n\nfunction newLocation(): parsetree.Location {\n    return {first_line: 0, first_column: 0, last_line: 0, last_column: 0, _source: \"\", _sourceId: 0};\n}\nlet nextSourceId: number = 1;\n\n// adapt moo parser to work with Jison\nclass WrappedLexer {\n    yytext?: string;\n    yylloc: parsetree.Location = newLocation();\n    yylineno: number = 0;\n    types = new Map<string, boolean>();\n\n    /** return the token type and update yytext, yylloc, yylineno */\n    lex(): string {\n        const token = lexer.next();\n        this.yytext = token?.value;\n        if (!token || !token.type) {\n            // no more tokens, end of file reached\n            return \"EOF\";\n        }\n\n        this.yylloc = {\n            first_line: token.line - 1,\n            first_column: token.col,\n            last_line: token.line + token.lineBreaks - 1,\n            last_column: token.lineBreaks ? 0 : token.col + token.text.length,\n            _sourceId: this.yylloc._sourceId,\n            _source: this.yylloc._source\n        };\n        this.yylineno = this.yylloc.first_line;\n\n        if (token.type === \"IDENTIFIER\" && this.types.get(token.text)) {\n            return \"TYPE_NAME\";\n        }\n        return token.type;\n    }\n\n    setInput(input: string): void {\n        // completely reset all state\n        this.yylloc = newLocation();\n        this.yylineno = 0;\n        this.yytext = undefined;\n        this.types.clear();\n\n        lexer.reset(input);\n        this.yylloc._source = input; // store source on the parser tokens, allowing error information to be easily printed\n        this.yylloc._sourceId = nextSourceId++; // identifier which can be used to check if tokens are from the same file\n    }\n\n    externalDeclaration(d: parsetree.Declaration) {\n        if (d.typeInfo.storageList[0] !== \"typedef\") return;\n\n        for (let declarator of d.list) {\n            while (!(declarator instanceof parsetree.IdentifierDeclarator)) declarator = declarator.body;\n            this.types.set(declarator.id, true);\n        }\n    }\n}\n\n// provide the generated parser with our custom lexer\nconst generatedParser = gen as any;\ngeneratedParser.parser.lexer = new WrappedLexer();\n\n/**\n * Parse the input string into a parse tree and perform some basic validation\n */\nexport function parse(input: string): parsetree.TranslationUnit {\n    try {\n        const tree = generatedParser.parse(input);\n        return validate(tree);\n    } catch (e) {\n        if (e?.hash?.loc) { // Jison parse errors\n            e.message += \"\\n\\n\" + locationString(e.hash?.loc);\n        }\n        throw e;\n    }\n}\n","export type Location = {\n    first_line: number, last_line: number, first_column: number, last_column: number,\n    _source: string, _sourceId: number // hidden attributes for error printing\n};\n\n// Classes used to build up the C parse tree - mostly just simple objects storing the relevant fields.\n\nexport abstract class ParseNode {\n    abstract readonly type: string;\n\n    constructor(readonly loc: Location) {\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        // return any children of the node\n    }\n}\n\n// Expressions\n\nexport abstract class Expression extends ParseNode {\n    // typescript does structural equality when type checking, so for this class to be different from\n    // the base ParseNode add a simple private field.\n    private readonly _expression: boolean = true;\n}\n\nexport class Identifier extends Expression {\n    readonly type = \"identifier\";\n\n    constructor(loc: Location, readonly name: string) {\n        super(loc);\n    }\n}\n\nexport class Constant extends Expression {\n    readonly type = \"constant\";\n\n    constructor(loc: Location, readonly value: string, readonly valueType: \"float\" | \"char\" | \"int\" | \"oct\" | \"hex\") {\n        super(loc);\n    }\n}\n\nexport class StringLiteral extends Expression {\n    readonly type = \"stringLiteral\";\n\n    constructor(loc: Location, readonly value: string) {\n        super(loc);\n    }\n}\n\nexport const UnaryOperations = [\n    \"postfixIncrement\", \"postfixDecrement\", \"prefixIncrement\", \"prefixDecrement\",\n    \"addressOf\", \"dereference\", \"unaryPlus\", \"unaryMinus\", \"bitwiseNot\", \"logicalNot\"] as const;\nexport type UnaryOp = typeof UnaryOperations[number];\nexport class UnaryExpression extends Expression {\n    private readonly _unaryExpr = true;\n\n    constructor(loc: Location, readonly type: UnaryOp, readonly body: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport const BinaryOperations = [\"arraySubscript\", \"comma\",\n    \"mul\", \"div\", \"mod\", \"add\", \"sub\", \"bitwiseShiftLeft\", \"bitwiseShiftRight\",\n    \"relationalLT\", \"relationalGT\", \"relationalLEq\", \"relationalGEq\", \"relationalEq\", \"relationalNEq\",\n    \"bitwiseAnd\", \"bitwiseXor\", \"bitwiseOr\", \"logicalAnd\", \"logicalOr\"] as const;\nexport type BinaryOp = typeof BinaryOperations[number];\nexport class BinaryExpression extends Expression {\n    private readonly _binaryExpr = true;\n\n    constructor(loc: Location, readonly type: BinaryOp, readonly lhs: Expression, readonly rhs: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n        yield this.rhs;\n    }\n}\n\nexport class SizeofExpression extends Expression {\n    readonly type = \"sizeof\";\n\n    constructor(loc: Location, readonly body: Expression | TypeName) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport class CastExpression extends Expression {\n    readonly type = \"cast\";\n\n    constructor(loc: Location, readonly targetType: TypeName, readonly body: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.targetType;\n        yield this.body;\n    }\n}\n\nexport class FunctionCallExpression extends Expression {\n    readonly type = \"functionCall\";\n\n    constructor(loc: Location, readonly fn: Expression, readonly args: ReadonlyArray<Expression> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.fn;\n        yield* this.args;\n    }\n}\n\nexport class MemberAccessExpression extends Expression {\n    readonly type = \"access\";\n\n    constructor(loc: Location, readonly pointer: boolean, readonly lhs: Expression, readonly rhs: string) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n    }\n}\n\nexport class ConditionalExpression extends Expression {\n    readonly type = \"conditional\";\n\n    constructor(loc: Location, readonly condition: Expression, readonly trueValue: Expression, readonly falseValue: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.condition;\n        yield this.trueValue;\n        yield this.falseValue;\n    }\n}\n\nexport type AssignmentType = undefined | \"mul\" | \"div\" | \"mod\" | \"add\" | \"sub\" | \"leftShift\"| \"rightShift\" | \"bitwiseAnd\" | \"bitwiseXor\" | \"bitwiseOr\";\nexport class AssignmentExpression extends Expression {\n    readonly type = \"assign\";\n\n    constructor(loc: Location, readonly assignType: AssignmentType, readonly lhs: Expression, readonly rhs: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n        yield this.rhs;\n    }\n}\n\nexport class ConstantExpression extends Expression {\n    readonly type = \"constantExpr\";\n\n    constructor(loc: Location, readonly expr: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expr;\n    }\n}\n\n// Declarations\nexport class CustomTypeSpecifier extends ParseNode {\n    readonly type = \"customType\";\n\n    public constructor(loc: Location, readonly name: string) {\n        super(loc);\n    }\n}\n\nexport type StorageClass = \"typedef\" | \"extern\" | \"static\"; // | \"auto\" | \"register\";\nexport type TypeSpecifier =\n    \"void\" | \"char\" | \"short\" | \"int\" | \"long\" | \"float\" | \"double\" | \"signed\" | \"unsigned\" | \"bool\" // | \"complex\" | \"imaginary\"]\n    | StructUnionSpecifier\n    | EnumSpecifier\n    | CustomTypeSpecifier;\nexport type TypeQualifier = \"const\"; // | \"restrict\" | \"volatile\";\nexport type FnSpecifier = \"import\" | \"inline\";\n\nexport class SpecifierQualifiers extends ParseNode {\n    readonly type = \"specifiersAndQualifiers\";\n\n    constructor(loc: Location,\n                readonly specifierList: ReadonlyArray<TypeSpecifier>,\n                readonly qualifierList: ReadonlyArray<TypeQualifier>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        for (const specifier of this.specifierList) {\n            if (specifier instanceof ParseNode) yield specifier;\n        }\n    }\n}\n\nexport class DeclarationSpecifiers extends ParseNode {\n    readonly type = \"declarationSpecifiers\";\n\n    constructor(loc: Location,\n                readonly specifierList: ReadonlyArray<TypeSpecifier>,\n                readonly qualifierList: ReadonlyArray<TypeQualifier>,\n                readonly storageList: ReadonlyArray<StorageClass>,\n                readonly fnSpecifierList: ReadonlyArray<FnSpecifier>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        for (const specifier of this.specifierList) {\n            if (specifier instanceof ParseNode) yield specifier;\n        }\n    }\n}\n\nexport class EnumSpecifier extends ParseNode {\n    type = \"enum\";\n\n    constructor(loc: Location, readonly id?: string, readonly body?: ReadonlyArray<Enumerator>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield* this.body;\n    }\n}\n\nexport class Enumerator extends ParseNode {\n    type = \"enumerator\";\n\n    constructor(loc: Location, readonly id: string, readonly value?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.value) yield this.value;\n    }\n}\n\nexport class Declaration extends ParseNode{\n    readonly type = \"declaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly list: ReadonlyArray<Declarator | InitDeclarator> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield* this.list;\n    }\n}\n\nexport class InitDeclarator extends ParseNode {\n    readonly type= \"initDeclarator\";\n\n    constructor(loc: Location, readonly body: Declarator, readonly initializer: Initializer) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        yield* this.exploreInitializer();\n    }\n\n    private *exploreInitializer(initializer: Initializer = this.initializer): Iterable<ParseNode> {\n        if (initializer instanceof AssignmentExpression) {\n            yield initializer;\n        } else if (Array.isArray(initializer)) {\n            for (const x of initializer) yield* this.exploreInitializer(x);\n        }\n    }\n}\n\nexport class StructUnionSpecifier extends ParseNode {\n    readonly type = \"structUnionSpecifier\";\n\n    constructor(loc: Location, readonly structure: \"struct\" | \"union\", readonly id?: string, readonly declarations?: ReadonlyArray<StructDeclaration>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.declarations) yield* this.declarations;\n    }\n}\n\nexport class StructDeclaration extends ParseNode {\n    readonly type= \"structDeclaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly list: ReadonlyArray<Declarator> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield* this.list;\n    }\n}\n\nexport type Declarator = PointerDeclarator | IdentifierDeclarator | ArrayDeclarator | FunctionDeclarator;\n\nexport class PointerDeclarator extends ParseNode {\n    readonly type= \"pointerDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly pointer: Pointer, readonly body: Declarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.pointer;\n        yield this.body;\n    }\n}\n\nexport class IdentifierDeclarator extends ParseNode {\n    readonly type= \"identifierDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly id: string) {\n        super(loc);\n    }\n}\n\nexport class ArrayDeclarator extends ParseNode {\n    readonly type= \"arrayDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly body: Declarator, readonly length?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        if (this.length) yield this.length;\n    }\n}\n\nexport class FunctionDeclarator extends ParseNode {\n    readonly type= \"functionDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly body: Declarator, readonly args?: ReadonlyArray<ParameterDeclaration>, readonly variadic: boolean = false) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        for (const value of this.args ?? []) {\n            if (value instanceof ParseNode) yield value;\n        }\n    }\n}\n\nexport class ParameterDeclaration extends ParseNode {\n    readonly type= \"parameterDeclaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly declarator?: Declarator | AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        if (this.declarator) yield this.declarator;\n    }\n}\n\nexport class Pointer extends ParseNode {\n    readonly type= \"pointer\";\n\n    constructor(loc: Location, readonly qualifierList?: ReadonlyArray<TypeQualifier>, readonly body?: Pointer) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n    }\n}\n\nexport class TypeName extends ParseNode {\n    readonly type= \"typeName\";\n\n    constructor(loc: Location, readonly typeInfo: SpecifierQualifiers, readonly declarator?: AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        if (this.declarator) yield this.declarator;\n    }\n}\n\nexport type AbstractDeclarator = AbstractPointerDeclarator | AbstractArrayDeclarator | AbstractFunctionDeclarator;\n\nexport class AbstractPointerDeclarator extends ParseNode {\n    readonly type= \"abstractPointerDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly pointer: Pointer, readonly body?: AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.pointer;\n        if (this.body) yield this.body;\n    }\n}\n\nexport class AbstractArrayDeclarator extends ParseNode {\n    readonly type= \"abstractArrayDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly body?: AbstractDeclarator, readonly length?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n        if (this.length) yield this.length;\n    }\n}\n\nexport class AbstractFunctionDeclarator extends ParseNode {\n    readonly type= \"abstractFunctionDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly body?: AbstractDeclarator, readonly args?: ReadonlyArray<ParameterDeclaration>, readonly variadic: boolean = false) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n        if (this.args) yield* this.args;\n    }\n}\n\nexport type Initializer = Expression | ReadonlyArray<Initializer>;\n\n// Statements\n\nexport abstract class Statement extends ParseNode {\n    private readonly _statement: boolean = true;\n    label?: string;\n\n    setLabel(label: string): this {\n        this.label = label;\n        return this;\n    }\n}\n\nexport class IfStatement extends Statement {\n    readonly type = \"ifStatement\";\n\n    constructor(loc: Location, readonly expression: Expression, readonly ifBody: Statement, readonly elseBody?: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n        yield this.ifBody;\n        if (this.elseBody) yield this.elseBody;\n    }\n}\n\nexport class SwitchStatement extends Statement {\n    readonly type = \"switchStatement\";\n\n    constructor(loc: Location, readonly expression: Expression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n        yield this.body;\n    }\n}\n\nexport class CaseStatement extends Statement {\n    readonly type = \"caseStatement\";\n\n    constructor(loc: Location, readonly value: ConstantExpression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.value;\n        yield this.body;\n    }\n}\n\nexport class DefaultStatement extends Statement {\n    readonly type = \"defaultStatement\";\n\n    constructor(loc: Location, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport class CompoundStatement extends Statement {\n    readonly type = \"compoundStatement\";\n\n    constructor(loc: Location, readonly body: ReadonlyArray<Statement | Declaration>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield* this.body;\n    }\n}\n\nexport class ExpressionStatement extends Statement {\n    readonly type = \"expressionStatement\";\n\n    constructor(loc: Location, readonly expression: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n    }\n}\n\nexport class NoOp extends Statement {\n    readonly type= \"nopStatement\";\n\n    constructor(loc: Location) {\n        super(loc);\n    }\n}\n\nexport class ForLoop extends Statement {\n    readonly type = \"forStatement\";\n\n    constructor(loc: Location,\n                readonly init: ExpressionStatement | NoOp | Declaration,\n                readonly test: ExpressionStatement | NoOp,\n                readonly update: Expression | undefined,\n                readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.init;\n        yield this.test;\n        if (this.update) yield this.update;\n        yield this.body;\n    }\n}\n\nexport class WhileLoop extends Statement {\n    readonly type = \"whileStatement\";\n\n    constructor(loc: Location, readonly test: Expression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.test;\n        yield this.body;\n    }\n}\n\nexport class DoWhileLoop extends Statement {\n    readonly type = \"doWhileStatement\";\n\n    constructor(loc: Location, readonly body: Statement, readonly test: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        yield this.test;\n    }\n}\n\nexport class GotoStatement extends Statement {\n    readonly type = \"gotoStatement\";\n\n    constructor(loc: Location, readonly target: string) {\n        super(loc);\n    }\n}\n\nexport class ContinueStatement extends Statement {\n    readonly type = \"continueStatement\";\n}\n\nexport class BreakStatement extends Statement {\n    readonly type = \"breakStatement\";\n}\n\nexport class ReturnStatement extends Statement {\n    readonly type = \"returnStatement\";\n\n    constructor(loc: Location, readonly value?: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.value) yield this.value;\n    }\n}\n\nexport class FunctionDefinition extends ParseNode {\n    readonly type = \"functionDefinition\";\n\n    constructor(loc: Location,\n                readonly typeInfo: DeclarationSpecifiers,\n                readonly declarator: Declarator,\n                readonly body: CompoundStatement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield this.declarator;\n        yield this.body;\n    }\n}\n\nexport type TranslationUnit = ReadonlyArray<FunctionDefinition | Declaration>;\n","import {CError} from \"../c_error\";\nimport {getArithmeticType} from \"../tree/types\";\nimport * as pt from \"./parsetree\";\nimport {ParseNode, TypeSpecifier} from \"./parsetree\";\n\nconst validatorMap = new Map<typeof ParseNode, ((node: ParseNode, parents: ParseNode[]) => void)[]>();\n\nexport function validate<T extends Iterable<ParseNode>>(nodeList: T, parents: ParseNode[] = []): T {\n    for (const node of nodeList) {\n        parents.push(node);\n        validate(node.children(), parents);\n        parents.pop();\n\n        for (const validator of validatorMap.get(Object.getPrototypeOf(node).constructor) ?? []) {\n            validator(node, parents);\n        }\n    }\n    return nodeList;\n}\n\nexport class ParseTreeValidationError extends CError {\n    readonly name = \"TreeValidationError\";\n\n    constructor(node: ParseNode | undefined, message: string, node2?: ParseNode) {\n        super(node && node.loc ? `Line ${node.loc.first_line + 1}: ${message}` : message, node, node2);\n    }\n}\n\nfunction validator<T extends ParseNode>(type: { new(...args: any[]): T}, fn: (node: T, parents: ParseNode[]) => void) {\n    const validators = validatorMap.get(type);\n    if (validators) {\n        validators.push(fn as any);\n    } else {\n        validatorMap.set(type, [fn as any]);\n    }\n}\n\n// DeclarationSpecifiers/SpecifierQualifiers validation\nfunction typeLookup(specifierList: ReadonlyArray<pt.TypeSpecifier>, node?: ParseNode) {\n    if (specifierList.every(v => typeof v === 'string')) {\n        if (!getArithmeticType(specifierList as ReadonlyArray<TypeSpecifier & string>)) {\n            throw new ParseTreeValidationError(node, \"Invalid specifiers - \" + specifierList.join(\", \"));\n        }\n    }\n}\n\nconst typeValidation = (d: pt.SpecifierQualifiers | pt.DeclarationSpecifiers) => {\n    if (d.qualifierList.length > 1) throw new ParseTreeValidationError(d, \"Invalid qualifiers.\");\n    typeLookup(d.specifierList, d);\n};\n\nvalidator(pt.SpecifierQualifiers, typeValidation);\nvalidator(pt.DeclarationSpecifiers, typeValidation);\nvalidator(pt.DeclarationSpecifiers, (d, parents) => {\n    if (d.storageList.length > 1) throw new ParseTreeValidationError(d, \"Invalid storage class list.\");\n    if (d.fnSpecifierList.length > 1) throw new ParseTreeValidationError(d, \"Invalid fn specifier list.\");\n\n    if (d.storageList[0] === \"typedef\" && parents.length !== 1) {\n        throw new ParseTreeValidationError(d, \"Nested typedefs are not allowed\");\n    }\n});\n\n// Constant expr validation\nfunction constExprValidation(n: ParseNode, parents: ParseNode[]) {\n    for (let i = parents.length - 1; i >= 0; i--) {\n        if (!(parents[i] instanceof pt.Expression) || parents[i].type === \"sizeof\") return;\n        if (parents[i].type === \"constantExpr\") throw new ParseTreeValidationError(n, \"Invalid constant expr.\");\n    }\n}\n\nvalidator(pt.UnaryExpression, (node, parent) => {\n    switch (node.type) {\n    case \"postfixIncrement\":\n    case \"postfixDecrement\":\n    case \"prefixIncrement\":\n    case \"prefixDecrement\":\n    case \"addressOf\": // If integers are required (believe this is always the case?)\n    case \"dereference\":\n        constExprValidation(node, parent);\n    }\n});\nvalidator(pt.BinaryExpression, (node, parent) => {\n    switch (node.type) {\n    case \"comma\":\n    case \"arraySubscript\": // If int\n        constExprValidation(node, parent);\n    }\n});\nvalidator(pt.FunctionCallExpression, constExprValidation);\n\n// If int\nvalidator(pt.MemberAccessExpression, constExprValidation);\n","import {parse} from \"../parsing\";\nimport {Expression, Constant, BinaryExpression, UnaryExpression, Identifier} from \"../parsing/parsetree\";\nimport {ptConstant} from \"../tree/transform/expr_transform\";\nimport {Preprocessor} from \"./preprocessor\";\n\nexport function ppEvaluate(x: string, preprocessor: Preprocessor): bigint {\n    const parseTree = parse(`int x = ${x};`);\n    if (parseTree.length !== 1 || parseTree[0].type !== \"declaration\" || parseTree[0].list.length !== 1 || parseTree[0].list[0].type !== \"initDeclarator\" || Array.isArray(parseTree[0].list[0].initializer)) {\n        throw preprocessor.error(\"Invalid #if conditional: `\" + x + \"`\");\n    }\n    const expression = parseTree[0].list[0].initializer as Expression;\n    return _eval(expression, preprocessor);\n}\n\nfunction _eval(n: Expression, preprocessor: Preprocessor): bigint {\n    if (n instanceof Constant && n.valueType !== \"float\") {\n        return BigInt(ptConstant(n).value);\n    } else if (n instanceof BinaryExpression) {\n        switch (n.type) {\n        case \"add\":\n            return _eval(n.lhs, preprocessor) + _eval(n.rhs, preprocessor);\n        case \"sub\":\n            return _eval(n.lhs, preprocessor) - _eval(n.rhs, preprocessor);\n        case \"mul\":\n            return _eval(n.lhs, preprocessor) * _eval(n.rhs, preprocessor);\n        case \"div\":\n            return _eval(n.lhs, preprocessor) / _eval(n.rhs, preprocessor);\n        case \"bitwiseAnd\":\n            return _eval(n.lhs, preprocessor) & _eval(n.rhs, preprocessor);\n        case \"bitwiseOr\":\n            return _eval(n.lhs, preprocessor) | _eval(n.rhs, preprocessor);\n        case \"bitwiseXor\":\n            return _eval(n.lhs, preprocessor) ^ _eval(n.rhs, preprocessor);\n        case \"bitwiseShiftLeft\":\n            return _eval(n.lhs, preprocessor) << _eval(n.rhs, preprocessor);\n        case \"bitwiseShiftRight\":\n            return _eval(n.lhs, preprocessor) >> _eval(n.rhs, preprocessor);\n        case \"relationalEq\":\n            return _eval(n.lhs, preprocessor) === _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalNEq\":\n            return _eval(n.lhs, preprocessor) !== _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalLT\":\n            return _eval(n.lhs, preprocessor) < _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalLEq\":\n            return _eval(n.lhs, preprocessor) <= _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalGT\":\n            return _eval(n.lhs, preprocessor) > _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"relationalGEq\":\n            return _eval(n.lhs, preprocessor) >= _eval(n.rhs, preprocessor) ? 1n : 0n;\n        case \"logicalAnd\":\n            return (_eval(n.lhs, preprocessor) !== 0n && _eval(n.rhs, preprocessor) !== 0n) ? 1n : 0n;\n        case \"logicalOr\":\n            return (_eval(n.lhs, preprocessor) !== 0n || _eval(n.rhs, preprocessor) !== 0n) ? 1n : 0n;\n        }\n    } else if (n instanceof UnaryExpression) {\n        switch (n.type) {\n        case \"unaryPlus\":\n            return _eval(n.body, preprocessor);\n        case \"unaryMinus\":\n            return -(_eval(n.body, preprocessor));\n        case \"logicalNot\":\n            return _eval(n.body, preprocessor) === 0n ? 1n : 0n;\n        }\n    } else if (n instanceof Identifier) {\n        return 0n;\n    }\n\n    throw preprocessor.error(\"Invalid preprocessor expression\");\n}\n","import {Token, PreProRegex} from \"./helpers\";\nimport type {Preprocessor} from \"./preprocessor\";\n\nexport class Definition {\n\n    constructor(readonly preprocessor: Preprocessor,\n                readonly identifier: string,\n                readonly replacement: Token[],\n                readonly parameters: string[]) {\n    }\n\n    expand(line: string): { output: string, line: string } {\n        if (this.parameters.length > 0) return this.expandWithParameters(line);\n\n        const output = this.replacement.map(x => x.value).join(\"\");\n        return {output, line};\n    }\n\n    private expandWithParameters(line: string) {\n        // check if macro call\n        const originalLine = line;\n        line = this.preprocessor.consume(line, PreProRegex.whitespace).remainingLine;\n        if (line.length === 0 || line[0] !== \"(\") {\n            // not referencing the definition\n            return {output: this.identifier, line: originalLine};\n        }\n        line = this.preprocessor.mustConsume(line, \"(\").remainingLine;\n\n        // consume args\n        const args: string[] = [];\n        for (let i = 0; i < this.parameters.length; i++) {\n            const match = this.consumeArgument(line);\n            args.push(match.value.trim());\n            if (i !== this.parameters.length - 1) {\n                line = this.preprocessor.mustConsume(match.remainingLine, \",\").remainingLine;\n            } else {\n                line = this.preprocessor.mustConsume(match.remainingLine, \")\").remainingLine;\n            }\n        }\n\n        // assemble output\n        let output = \"\";\n        for (const token of this.replacement) {\n            if (token.type === \"identifier\") {\n                const index = this.parameters.indexOf(token.value);\n                if (index >= 0) {\n                    output += this.preprocessor.expandDefinitions(args[index]);\n                    continue; // TODO repeat as needed\n                }\n            }\n            output += token.value;\n        }\n        return {output, line};\n    }\n\n    private consumeArgument(line: string): {value: string, remainingLine: string} {\n        const out = {value: \"\", remainingLine: line};\n        let inQuote = false, bracketDepth = 0;\n\n        while (out.remainingLine.length > 0 && (inQuote || bracketDepth !== 0 || (out.remainingLine[0] !== \",\" && out.remainingLine[0] !== \")\"))) {\n            const char = out.remainingLine[0];\n            let consumed = 1;\n\n            if (inQuote && char === `\\\\` && out.remainingLine[0] === `\"`) {\n                // escaped quote\n                consumed = 2;\n            } else if (char === `\"`) {\n                inQuote = !inQuote;\n            } else if (char === `(` && !inQuote) {\n                bracketDepth++;\n            } else if (char === `)` && !inQuote) {\n                bracketDepth--;\n            }\n\n            out.value += out.remainingLine.substring(0, consumed);\n            out.remainingLine = out.remainingLine.substring(consumed);\n        }\n        return out;\n    }\n\n    equals(t: this): boolean {\n        return t.identifier === this.identifier &&\n            t.replacement.length === this.replacement.length &&\n            t.replacement.every((v, i) => v.value === this.replacement[i].value) &&\n            t.parameters.length === this.parameters.length &&\n            t.parameters.every((v, i) => v === this.parameters[i]);\n    }\n}\n","// preprocessor tokens\nexport type Token = {\n    type?: \"identifier\", // with optional type\n    value: string\n};\n\n// various regexes used\nexport const PreProRegex = {\n    identifier: /^[a-zA-Z_][a-zA-Z0-9_]*/,\n    token: /^(?:\"(?:\\\\\"|[^\\n\"])*\"|[^ \\t\\v\\f\\na-zA-Z_]+)/,\n    whitespace: /^[ \\t\\v\\f]+/,\n    // used in first pass so is global and multiline\n    comments: /(?:\\/\\*[^]*?\\*\\/)|(?:\\/\\/.*?$)/gm,\n    // used to process conditions\n    condition: /defined(?:[ \\t]*\\([ \\t]*([a-zA-Z_][a-zA-Z0-9_]*)[ \\t]*\\)|[ \\t]+([a-zA-Z_][a-zA-Z0-9_]*))|(d?[^d]*)/gm\n};\n\n// functions to 'consume' text from an input line\ntype ConsumeFailed = { success: false, remainingLine: string };\ntype ConsumeSucceeded = { success: true, remainingLine: string } & Token;\n\n\nexport abstract class PreprocessorBase {\n\n    abstract error(message: string): Error;\n\n    /** Consume identifier, token or whitespace */\n    consumeAny(line: string): ConsumeSucceeded {\n        let match: ConsumeFailed | ConsumeSucceeded;\n        if ((match = this.consume(line, PreProRegex.identifier)).success) {\n            match.type = \"identifier\";\n            return match;\n        } else if ((match = this.consume(line, PreProRegex.token)).success) {\n            return match;\n        } else if ((match = this.consume(line, PreProRegex.whitespace)).success) {\n            return match;\n        }\n        throw this.error(\"Malformed input? Line does not match defined regular expressions.\\n`\" + line + \"`\");\n    }\n\n    /** Consume or throw error */\n    mustConsume(line: string, t: RegExp | string, errorName: string = t.toString()): ConsumeSucceeded {\n        const match = this.consume(line, t);\n        if (match.success) return match;\n\n        throw this.error(`Expected to find ${errorName} but found \\`${line}\\` instead`);\n    }\n\n    consume(line: string, t: RegExp | string): ConsumeFailed | ConsumeSucceeded {\n        if (typeof t === \"string\") {\n            if (line.startsWith(t)) {\n                return {success: true, value: t, remainingLine: line.substring(t.length)};\n            } else {\n                return {success: false, remainingLine: line};\n            }\n        }\n\n        const match = line.match(t);\n        if (match === null) {\n            return {success: false, remainingLine: line};\n        }\n        return {success: true, value: match[0], remainingLine: line.substring(match[0].length)};\n    }\n\n}\n","export {Preprocessor} from \"./preprocessor\";\nexport {Definition} from \"./definition\";\n","import {LIBRARY_HEADERS} from \"../c_library/standard_library\";\nimport {ppEvaluate} from \"./conditionals\";\nimport {Definition} from \"./definition\";\nimport {PreProRegex, PreprocessorBase} from \"./helpers\";\n\nexport class Preprocessor extends PreprocessorBase {\n    definitions = new Map<string, Definition>();\n\n    libraryFiles: Map<string, string>; // #include <...>\n    userFiles = new Map<string, string>(); // #include \"...\"\n\n    constructor(readonly filename: string, standardHeaders: boolean = true) {\n        super();\n        if (standardHeaders) {\n            this.libraryFiles = new Map<string, string>(LIBRARY_HEADERS);\n        } else {\n            this.libraryFiles = new Map<string, string>();\n        }\n\n        this.definitions.set(\"__FILE__\", new Definition(this, \"__FILE__\", [{value: `\"${filename}\"`}], []));\n    }\n\n    process(text: string, filename: string = this.filename): string {\n        // replace crlf with lf\n        text = text.replace(/\\r\\n/g, \"\\n\");\n        // remove comments\n        text = text.replace(PreProRegex.comments, \" \");\n        // remove line continuations\n        const lines = text.replace(/\\\\\\n/g, \"\").split(\"\\n\");\n\n        let output = \"\";\n        while (lines.length > 0) {\n            const line = lines.shift() as string;\n\n            if (line.startsWith(\"#\")) {\n                let match: ReturnType<typeof Preprocessor.prototype[\"consume\"]>;\n                if ((match = this.consume(line, \"#define\")).success) {\n                    this._define(match.remainingLine);\n                } else if ((match = this.consume(line, \"#undef\")).success) {\n                    this._undef(match.remainingLine);\n                } else if ((match = this.consume(line, \"#include\")).success) {\n                    output += this._include(match.remainingLine) + \"\\n\";\n                } else if ((match = this.consume(line, \"#ifdef\")).success) {\n                    this._ifdef(match.remainingLine, true, lines);\n                } else if ((match = this.consume(line, \"#ifndef\")).success) {\n                    this._ifdef(match.remainingLine, false, lines);\n                } else if ((match = this.consume(line, \"#if\")).success) {\n                    output += this._if(match.remainingLine, lines);\n                } else if ((match = this.consume(line, \"#pragma\")).success) {\n                    const l = this.mustConsume(match.remainingLine, PreProRegex.whitespace, \"whitespace\").remainingLine;\n                    if (l.trim() === \"once\") {\n                        // only include source file once\n                        const defName = `__pragma_once_${filename}__`;\n                        if (this.definitions.has(defName)) return output;\n                        this.definitions.set(defName, new Definition(this, defName, [], []));\n                    }\n                    // unknown pragmas must be ignored\n                } else if (line.trim().length > 1) {\n                    throw this.error(\"Unknown preprocessor directive\");\n                }\n\n            } else {\n                output += this.expandDefinitions(line) + \"\\n\";\n            }\n        }\n        return output;\n    }\n\n    expandDefinitions(line: string): string {\n        let output = \"\";\n        while (line.length > 0) {\n            const token = this.consumeAny(line);\n            if (token?.type === \"identifier\") {\n                const def = this.definitions.get(token.value);\n                if (def !== undefined) {\n                    const e = def.expand(token.remainingLine);\n                    output += e.output;\n                    line = e.line;\n                    continue;\n                }\n            }\n            output += token?.value;\n            line = token.remainingLine;\n        }\n        return output;\n    }\n\n    error(message: string): Error {\n        return new class extends Error {\n            name = \"PreprocessorError\";\n        }(`In file '${this.filename}': ${message}`);\n    }\n\n    private _include(line: string): string {\n        line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine.trim();\n        if (line.startsWith('\"') && line.endsWith('\"')) {\n            return this._includeUser(line.substring(1, line.length - 1));\n        } else if (line.startsWith(\"<\") && line.endsWith(\">\")) {\n            return this._includeLib(line.substring(1, line.length - 1));\n        }\n\n        // if failed try expand macros\n        line = this.expandDefinitions(line);\n        if (line.startsWith('\"') && line.endsWith('\"')) {\n            return this._includeUser(line.substring(1, line.length - 1));\n        } else if (line.startsWith(\"<\") && line.endsWith(\">\")) {\n            return this._includeLib(line.substring(1, line.length - 1));\n        }\n\n        throw this.error(\"Invalid #include\");\n    }\n\n    private _includeLib(path: string) {\n        const file = this.libraryFiles.get(path);\n        if (file === undefined) throw this.error(\"Unknown path `\" + path + \"`\");\n        return this.process(file, `<${path}>`);\n    }\n\n    private _includeUser(path: string) {\n        const localPath = this.filename.replace(/[^/\\\\]*$/, path);\n        let file = this.userFiles.get(localPath);\n        if (file === undefined) {\n            file = this.userFiles.get(path);\n            if (file === undefined) return this._includeLib(path);\n        }\n        return this.process(file, path);\n    }\n    private _define(line: string) {\n        line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n        const identifier = this.mustConsume(line, PreProRegex.identifier, \"identifier\");\n        const tokens = [];\n        const parameters: string[] = [];\n\n        if (identifier.remainingLine.trim().length > 0) {\n            if (identifier.remainingLine[0] === \"(\") {\n                // definition with parameters\n                line = this.mustConsume(identifier.remainingLine, \"(\").remainingLine;\n                while (line.length > 0) {\n                    line = this.consume(line, PreProRegex.whitespace).remainingLine;\n                    const parameter = this.mustConsume(line, PreProRegex.identifier, \"identifier\");\n                    parameters.push(parameter.value);\n                    line = this.consume(parameter.remainingLine, PreProRegex.whitespace).remainingLine;\n\n                    if (line.length === 0) {\n                        throw this.error(\"Unexpected end of line\");\n                    } else if (line[0] === \",\") {\n                        line = this.mustConsume(line, \",\").remainingLine;\n                    } else if (line[0] === \")\") {\n                        break;\n                    } else {\n                        throw this.error(\"Unexpected\");\n                    }\n                }\n                line = this.mustConsume(line, \")\").remainingLine;\n                if (line.length > 0) {\n                    line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n                }\n\n            } else {\n                // normal definition\n                line = this.mustConsume(identifier.remainingLine, PreProRegex.whitespace, \"whitespace\").remainingLine;\n            }\n\n            // body\n            while (line.length > 0) {\n                const token = this.consumeAny(line);\n                if (token.type !== \"identifier\" || !parameters.includes(token.value)) {\n                    token.value = this.expandDefinitions(token.value);\n                }\n\n                tokens.push(token);\n                line = token.remainingLine;\n            }\n        }\n\n        const def = new Definition(this, identifier.value, tokens, parameters);\n        const existing = this.definitions.get(identifier.value);\n        if (existing !== undefined && !def.equals(existing)) {\n            throw this.error(\"Duplicate defines must be the same\");\n        }\n        this.definitions.set(identifier.value, def);\n    }\n\n    private _undef(line: string) {\n        line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n        const identifier = this.mustConsume(line, PreProRegex.identifier, \"identifier\");\n        if (identifier.remainingLine.trim().length !== 0) throw this.error(\"Unexpected extra characters in undef\");\n        this.definitions.delete(identifier.value);\n    }\n\n    private _ifdef(line: string, ifdef: boolean, lines: string[]) {\n        line = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n        const identifier = this.mustConsume(line, PreProRegex.identifier, \"identifier\");\n        lines.unshift(`#if ${ifdef ? \"\" : \"!\"} defined ${identifier.value}`);\n    }\n\n    private _if(line: string, lines: string[]): string {\n        const expression = this.mustConsume(line, PreProRegex.whitespace, \"whitespace\").remainingLine;\n        let condition = this._condition(expression), anyCondition = condition, depth = 1, hadElse = false;\n\n        const body: string[] = [];\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i].trimEnd();\n\n            if (line.startsWith(\"#if\")) {\n                depth++;\n\n            } else if (line === \"#endif\") {\n                depth--;\n                if (depth === 0) {\n                    // well formed ifdef\n                    lines.splice(0, i + 1);\n                    return this.process(body.join(\"\\n\"));\n                }\n\n            } else if (line === \"#else\" && depth === 1) {\n                if (hadElse) throw this.error(\"more than one #else statement\");\n                hadElse = true;\n\n                condition = !anyCondition;\n                anyCondition = true;\n                continue;\n            } else if (line.startsWith(\"#elif\") && depth === 1) {\n                if (anyCondition) {\n                    condition = false;\n                } else {\n                    const expression = this.mustConsume(lines[i].substring(5), PreProRegex.whitespace, \"whitespace\").remainingLine;\n                    condition = this._condition(expression);\n                    anyCondition ||= condition;\n                }\n                continue;\n            }\n\n            if (condition) body.push(lines[i]);\n        }\n\n        throw this.error(\"no matching #endif found\");\n    }\n\n    private _condition(s: string): boolean {\n        // deal with \"defined ...\"\n        let processed = \"\";\n        for (const match of s.matchAll(PreProRegex.condition)) {\n            if (match.length !== 4) throw this.error(\"invalid regex result when processing #if condition\");\n            const definitionName = match[1] ?? match[2];\n            if (definitionName) {\n                processed += this.definitions.has(definitionName) ? \" 1L \" : \" 0L \";\n            } else {\n                processed += match[3];\n            }\n        }\n        // expand remaining macros\n        processed = this.expandDefinitions(processed);\n        // try evaluate\n        try {\n            return ppEvaluate(processed, this) !== 0n;\n        } catch (e) {\n            console.debug(e);\n            throw this.error(\"Invalid condition `\" + s + \"`\");\n        }\n    }\n}\n","import type {FunctionDefinition, ParseNode} from \"../parsing/parsetree\";\nimport type {CInitializer, CExpression} from \"./expressions\";\nimport type {Scope} from \"./scope\";\nimport {CCompoundStatement} from \"./statements\";\nimport type {CFuncType, CNotFuncType, CQualifiedType} from \"./types\";\n\n// classes to represent all the different types of declarations in the IR\nexport type CDeclaration = CVariable | CFunction;\nexport type CVariable = CVarDeclaration | CVarDefinition | CArgument;\nexport type CFunction = CFuncDefinition | CFuncDeclaration;\n\nexport class CVarDeclaration {\n    readonly declType = \"variable\";\n    _addressUsed: boolean = false;\n    _definition?: CVarDefinition;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly storage: \"static\" | \"local\",\n                readonly linkage: \"none\" | \"internal\" | \"external\") {\n    }\n\n    set addressUsed(b: boolean) {\n        if (this._definition) this._definition.addressUsed ||= b;\n        else this._addressUsed ||= b;\n    }\n\n    get addressUsed(): boolean {\n        return this._definition ? this._definition.addressUsed : this._addressUsed;\n    }\n\n    set definition(v: CVarDefinition | undefined) {\n        if (v === undefined) throw new Error(\"Cannot set definition to undefined\");\n        v.addressUsed ||= this._addressUsed;\n        this._definition = v;\n    }\n\n    get definition(): CVarDefinition | undefined {\n        return this._definition;\n    }\n}\n\nexport class CVarDefinition {\n    readonly declType = \"variable\";\n    staticValue?: CExpression | CInitializer;\n    addressUsed: boolean = false;\n    readonly dependencies = new Map<CDeclaration, boolean>(); // direct dependencies of initializer only\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly storage: \"static\" | \"local\",\n                public linkage: \"none\" | \"internal\" | \"external\") {\n    }\n}\n\nexport class CArgument {\n    readonly declType = \"variable\";\n    readonly storage = \"argument\";\n    readonly linkage = \"none\";\n    addressUsed: boolean = false;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly index: number) {\n    }\n}\n\nexport class CFuncDeclaration {\n    readonly declType = \"function\";\n    definition?: CFuncDefinition | CFuncImport;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CFuncType>,\n                readonly linkage: \"none\" | \"internal\" | \"external\",\n                public fnImport: boolean = false) {\n    }\n}\n\nexport class CFuncImport {\n    readonly declType = \"import\";\n    readonly node: ParseNode;\n\n    constructor(readonly declaration: CFuncDeclaration) {\n        this.node = declaration.node;\n    }\n\n    getFunction(): CFuncDeclaration {\n        return this.declaration;\n    }\n}\n\nexport class CFuncDefinition {\n    readonly declType = \"function\";\n    readonly body: CCompoundStatement;\n    readonly dependencies = new Map<CDeclaration, boolean>(); // direct dependencies only\n\n    constructor(readonly node: FunctionDefinition,\n                readonly name: string,\n                readonly type: CQualifiedType<CFuncType>,\n                public linkage: \"none\" | \"internal\" | \"external\",\n                readonly translationUnit: Scope) {\n        this.body = new CCompoundStatement(node.body, this);\n    }\n\n    get scope(): Scope {\n        return this.translationUnit;\n    }\n\n    equals(t: object): boolean {\n        return t === this;\n    }\n\n    getFunction(): CFuncDefinition {\n        return this;\n    }\n}\n","import type {ParseNode, pt} from \"../parsing\";\nimport type {CDeclaration, CVariable, CArgument} from \"./declarations\";\nimport * as checks from \"./type_checking\";\nimport {\n    CArithmetic, CType, CArray, CPointer, CUnion, CStruct,\n    CSizeT, usualArithmeticConversion, integerPromotion, CFuncType, CVoid, checkTypeComplete, getQualifier\n} from \"./types\";\n\n// Classes to represent all the possible expression types in the IR\n\nexport type CExpression =\n    CConstant | CIdentifier | CArrayPointer | CStringLiteral |\n    CFunctionCall | CMemberAccess | CIncrDecr | // postfix\n    CAddressOf | CDereference | CUnaryPlusMinus | CBitwiseNot | CLogicalNot | CSizeof | // unary\n    CCast |\n    CMulDiv | CMod | CAddSub | CShift |\n    CRelational | CEquality |\n    CBitwiseAndOr | CLogicalAndOr |\n    CConditional | CAssignment | CComma;\n\n// evaluated expression, value and type pair\nexport type CValue = {readonly value: number | bigint, readonly type: CArithmetic | CPointer};\n\nexport class CConstant {\n    readonly lvalue = false;\n\n    constructor(readonly node: ParseNode, readonly type: CArithmetic, readonly value: bigint | number) {\n    }\n\n    changeType(type: CArithmetic): CConstant {\n        if (this.type.equals(type)) return this;\n\n        let newValue: bigint | number;\n        if (type.equals(CArithmetic.BOOL)) {\n            // eslint-disable-next-line eqeqeq\n            newValue = this.value == 0 ? 0 : 1;\n        } else if (type.type === \"float\") {\n            newValue = Number(this.value);\n        } else {\n            if (this.value > type.maxValue || this.value < type.minValue) {\n                throw new checks.ExpressionTypeError(this.node, `value which fits in ${type.name}`, this.value.toString());\n            }\n            newValue = BigInt(this.value);\n        }\n        return new CConstant(this.node, type, newValue);\n    }\n\n    // for analyzing expression dependencies\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CIdentifier {\n    readonly lvalue: boolean;\n\n    constructor(readonly node: ParseNode, readonly value: CDeclaration) {\n        this.lvalue = !(value.type instanceof CFuncType);\n    }\n\n    get type(): CType {\n        return this.value.type;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield this;\n    }\n}\n\n/**\n * Array identifiers are used as pointers to arrays everywhere excluding:\n * - the unary & operator\n * - the sizeof operator\n */\nexport class CArrayPointer {\n    readonly lvalue = false;\n    readonly type: CPointer;\n\n    constructor(readonly node: ParseNode, readonly arrayIdentifier: CIdentifier | CStringLiteral) {\n        if (!(arrayIdentifier.type instanceof CArray)) {\n            throw new checks.ExpressionTypeError(this.node, \"array\");\n        }\n        this.type = new CPointer(this.node, arrayIdentifier.type.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        if (this.arrayIdentifier instanceof CIdentifier) yield this.arrayIdentifier;\n    }\n}\n\nexport class CStringLiteral {\n    readonly lvalue = false;\n    readonly type: CArray;\n\n    constructor(readonly node: ParseNode, readonly value: bigint[]) {\n        // currently only supports UTF8\n        if (value.length === 0 || value[value.length - 1] !== 0n) {\n            throw new checks.ExpressionTypeError(node, \"null terminated char[]\", \"char[]\");\n        }\n        this.type = new CArray(node, CArithmetic.U8, value.length);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CFunctionCall {\n    readonly lvalue = false;\n    readonly fnType: CFuncType;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly args: CExpression[]) {\n        this.fnType = checks.asFunction(body.node, body.type);\n        this.type = this.fnType.returnType;\n\n        // check arguments correct for the function type\n        if (this.fnType.variadic && this.fnType.parameterTypes.length > args.length) {\n            throw new checks.ExpressionTypeError(node, `at least ${this.fnType.parameterTypes.length} argument(s) to variadic function`);\n        } else if (!this.fnType.variadic && this.fnType.parameterTypes.length !== args.length) {\n            throw new checks.ExpressionTypeError(node, `${this.fnType.parameterTypes.length} argument(s)`, `${args.length}`);\n        }\n        for (let i = 0; i < this.fnType.parameterTypes.length; i++) {\n            CAssignment.checkAssignmentValid(args[i].node, this.fnType.parameterTypes[i], args[i]);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n        for (const a of this.args) yield* a.identifiers();\n    }\n}\n\nexport class CMemberAccess {\n    readonly lvalue: boolean;\n    readonly structUnion: CStruct | CUnion;\n    readonly type: CType;\n\n    /** transform `e.member` to `(&e)->member` before calling */\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly member: string) {\n        const pointerType = checks.asPointer(body.node, body.type);\n        this.structUnion = checks.asStructOrUnion(body.node, pointerType.type);\n\n        const type = this.structUnion.memberType(member);\n        this.type = type instanceof CArray ? new CPointer(type.node, type.type) : type;\n        this.lvalue = !(this.type instanceof CArray);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CIncrDecr {\n    readonly lvalue = false;\n    readonly type: CArithmetic | CPointer;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression,\n                readonly op: \"++\" | \"--\", readonly pos: \"pre\" | \"post\") {\n        checks.checkLvalue(body, true);\n\n        this.type = checks.asNonFunctionPointer(body.node, checks.asArithmeticOrPointer(body.node, body.type));\n        if (this.type instanceof CPointer) checkTypeComplete(this.type.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CSizeof {\n    readonly lvalue = false;\n    readonly type = CSizeT;\n\n    constructor(readonly node: ParseNode, readonly body: CType) {\n        if (body.incomplete || body.bytes === 0 || body instanceof CFuncType) {\n            throw new checks.ExpressionTypeError(node, \"Complete non-function type\", body.typeName);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CAddressOf { // &\n    readonly lvalue = false;\n    readonly type: CPointer;\n    readonly body: CExpression;\n\n    constructor(readonly node: ParseNode, body: CExpression) {\n        if (body instanceof CArrayPointer) body = body.arrayIdentifier;\n        if (!(body instanceof CIdentifier && body.type instanceof CFuncType)) checks.checkLvalue(body, true);\n        this.type = new CPointer(node, body.type);\n\n        if (body instanceof CIdentifier) {\n            // when translating to wasm all variables which have their address taken have to be stored on the shadow stack\n            (body.value as CVariable | CArgument).addressUsed = true;\n        }\n        this.body = body;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CDereference { // * or 'indirection'\n    readonly lvalue = true;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        this.type = checks.asPointer(node, body.type).type;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CUnaryPlusMinus {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n    readonly bodyType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly op: \"+\" | \"-\") {\n        this.bodyType = checks.asArithmetic(body.node, body.type);\n        this.type = integerPromotion(this.bodyType);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CBitwiseNot {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n    readonly bodyType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        this.bodyType = checks.asInteger(body.node, body.type);\n        this.type = this.bodyType.bytes < CArithmetic.S32.bytes ? CArithmetic.S32 : this.bodyType;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CLogicalNot {\n    readonly lvalue = false;\n    readonly type = CArithmetic.S32;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        checks.asArithmeticOrPointer(body.node, body.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CCast {\n    readonly lvalue = false;\n\n    constructor(readonly node: ParseNode, readonly type: CType, readonly body: CExpression) {\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CMulDiv {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"*\" | \"/\") {\n        this.type = usualArithmeticConversion(\n            checks.asArithmetic(lhs.node, lhs.type),\n            checks.asArithmetic(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CMod {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression) {\n        this.type = usualArithmeticConversion(\n            checks.asInteger(lhs.node, lhs.type),\n            checks.asInteger(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\n// Array subscript a[b] becomes *(a + b)\nexport class CAddSub {\n    readonly lvalue = false;\n    readonly type: CArithmetic | CPointer;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"+\" | \"-\") {\n        if (lhs.type instanceof CPointer && rhs.type instanceof CPointer) { // both pointers\n            if (!lhs.type.equals(rhs.type)) throw new checks.ExpressionTypeError(node, \"both pointers to have the same type\");\n            checkTypeComplete(lhs.type.type);\n            this.type = checks.asNonFunctionPointer(lhs.node, lhs.type);\n            checks.asNonFunctionPointer(rhs.node, rhs.type);\n\n        } else if (lhs.type instanceof CPointer) { // one pointer, one integral\n            checks.asInteger(rhs.node, rhs.type);\n            checkTypeComplete(lhs.type.type);\n            this.type = checks.asNonFunctionPointer(lhs.node, lhs.type);\n\n        } else if (rhs.type instanceof CPointer) { // one pointer, one integral\n            checks.asInteger(lhs.node, lhs.type);\n            checkTypeComplete(rhs.type.type);\n            this.type = checks.asNonFunctionPointer(rhs.node, rhs.type);\n\n        } else {\n            this.type = usualArithmeticConversion(checks.asArithmetic(lhs.node, lhs.type), checks.asArithmetic(rhs.node, rhs.type));\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CShift {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly dir: \"left\" | \"right\") {\n        this.type = integerPromotion(checks.asInteger(lhs.node, lhs.type));\n        checks.asInteger(rhs.node, rhs.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CRelational {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n    readonly commonType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"LT\" | \"GT\" | \"LEq\" | \"GEq\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n\n        this.commonType = usualArithmeticConversion(\n            lhs.type instanceof CArithmetic ? lhs.type : CSizeT,\n            rhs.type instanceof CArithmetic ? rhs.type : CSizeT);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CEquality {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n    readonly commonType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"==\" | \"!=\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n\n        this.commonType = usualArithmeticConversion(\n            lhs.type instanceof CArithmetic ? lhs.type : CSizeT,\n            rhs.type instanceof CArithmetic ? rhs.type : CSizeT);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CBitwiseAndOr {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"and\" | \"or\" | \"xor\") {\n        this.type = usualArithmeticConversion(\n            checks.asInteger(lhs.node, lhs.type),\n            checks.asInteger(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CLogicalAndOr {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"and\" | \"or\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CConditional { // [test] ? [trueValue] : [falseValue]\n    readonly lvalue = false;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly test: CExpression, readonly trueValue: CExpression, readonly falseValue: CExpression) {\n        checks.asArithmeticOrPointer(test.node, test.type);\n\n        if (trueValue.type instanceof CArithmetic && falseValue.type instanceof CArithmetic) {\n            this.type = usualArithmeticConversion(trueValue.type, falseValue.type);\n            return;\n        } else if (trueValue.type.equals(falseValue.type)) {\n            this.type = trueValue.type;\n            return;\n        } else if (trueValue.type instanceof CPointer && falseValue.type instanceof CPointer) {\n            // both pointers - check if either is void* pointer\n            if (trueValue.type.type instanceof CVoid) {\n                this.type = falseValue.type;\n                return;\n            } else if (falseValue.type.type instanceof CVoid) {\n                this.type = trueValue.type;\n                return;\n            }\n        } else if (trueValue.type instanceof CPointer || falseValue.type instanceof CPointer) {\n            // one pointer - check if other null constant\n            const otherValue = trueValue.type instanceof CPointer ? falseValue : trueValue;\n            // eslint-disable-next-line eqeqeq\n            if (otherValue instanceof CConstant && otherValue.value == 0) {\n                this.type = trueValue.type instanceof CPointer ? trueValue.type : falseValue.type;\n                return;\n            }\n        }\n        throw new checks.ExpressionTypeError(node, \"both conditional branches to have the same type\", \"different types\");\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.test.identifiers();\n        yield* this.trueValue.identifiers();\n        yield* this.falseValue.identifiers();\n    }\n}\n\nexport class CAssignment {\n    readonly lvalue = false;\n    readonly type: CType;\n\n    // rhs may require casting\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression | CInitializer,\n                readonly assignmentType: pt.AssignmentType, readonly initialAssignment: boolean = false) {\n        // check lvalue\n        checks.checkLvalue(lhs, true);\n        if ((lhs.type instanceof CArray && !initialAssignment) || lhs.type instanceof CFuncType || lhs.type.incomplete) {\n            throw new checks.ExpressionTypeError(lhs.node, \"assignable type\");\n        } else if (getQualifier(lhs.type) === \"const\" && !initialAssignment) {\n            throw new checks.ExpressionTypeError(lhs.node, \"non-const location\");\n        } else if ((lhs.type instanceof CStruct || lhs.type instanceof CUnion) && lhs.type.hasConstMember() && !initialAssignment) {\n            throw new checks.ExpressionTypeError(lhs.node, \"structure without a const member\");\n        }\n        this.type = lhs.type;\n\n        // fix string constants being wrapped into pointers\n        if (lhs.type instanceof CArray && rhs instanceof CArrayPointer) this.rhs = rhs = rhs.arrayIdentifier;\n\n        // check assignment types are valid\n        if (assignmentType) {\n            if (rhs instanceof CInitializer) {\n                throw new checks.ExpressionTypeError(node,\"simple assignments with structure initializers\");\n            }\n            let rhsType = rhs.type;\n\n            // typecheck `lhs op= rhs` as `lhs = lhs op rhs`\n            // LHS only evaluated once so can't just be transformed: see `a[i++] += 1;`\n            switch (assignmentType) {\n            case \"mul\": rhsType = new CMulDiv(node, lhs, rhs, \"*\").type; break;\n            case \"div\": rhsType = new CMulDiv(node, lhs, rhs, \"/\").type; break;\n            case \"mod\": rhsType = new CMod(node, lhs, rhs).type; break;\n            case \"add\": rhsType = new CAddSub(node, lhs, rhs, \"+\").type; break;\n            case \"sub\": rhsType = new CAddSub(node, lhs, rhs, \"-\").type; break;\n            case \"leftShift\": rhsType = new CShift(node, lhs, rhs, \"left\").type; break;\n            case \"rightShift\": rhsType = new CShift(node, lhs, rhs, \"right\").type; break;\n            case \"bitwiseAnd\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"and\").type; break;\n            case \"bitwiseOr\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"or\").type; break;\n            case \"bitwiseXor\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"xor\").type; break;\n            default: throw new checks.ExpressionTypeError(node, \"valid assignment type\");\n            }\n            CAssignment._checkAssignmentTypeValid(node, lhs.type, rhsType);\n        } else {\n            CAssignment.checkAssignmentValid(node, lhs.type, rhs);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n\n    static checkAssignmentValid(node: ParseNode, varType: CType, value: CExpression | CInitializer): void {\n        // also allow constant 0 to be assigned to a pointer\n        if (varType instanceof CPointer && value instanceof CConstant) {\n            if (value.value === 0n) return;\n        }\n        this._checkAssignmentTypeValid(node, varType, value.type);\n    }\n\n    private static _checkAssignmentTypeValid(node: ParseNode, varType: CType, valueType: CType): void {\n        if (varType.equals(valueType)) return;\n        if (varType instanceof CArithmetic && valueType instanceof CArithmetic) {\n            return; // arithmetic types always assignable\n        }\n        if (varType instanceof CPointer && valueType instanceof CPointer) {\n            // void pointers can be assigned to any pointer and any pointer can be assigned to a void pointer\n            if (varType.type instanceof CVoid || valueType.type instanceof CVoid) return;\n            // allow non-constant pointers to be assigned to constant pointers\n            if (varType.type.equals(valueType.type) && valueType.qualifier !== \"const\") return;\n        }\n        if (varType instanceof CPointer && valueType instanceof CFuncType) {\n            // implicit function pointer conversion\n            if (varType.type.equals(valueType)) return;\n        }\n\n        throw new checks.ExpressionTypeError(node, varType.typeName, valueType.typeName);\n    }\n}\n\nexport class CComma {\n    readonly lvalue = false;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression) {\n        this.type = rhs.type;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\n/** Special type of expression permitted only in declarations */\nexport class CInitializer {\n    private _type: CType;\n    private _memberTypes: CType[] = [];\n\n    constructor(readonly node: ParseNode, readonly body: (CExpression | CInitializer)[], type?: CType) {\n        // default to a void* array which isn't the true type but lets the array size be used when declaring arrays\n        this._type = type ?? new CArray(undefined, new CPointer(undefined, new CVoid()), body.length);\n    }\n\n    get memberTypes(): ReadonlyArray<CType> {\n        return this._memberTypes;\n    }\n\n    get type(): CType {\n        return this._type;\n    }\n\n    /** Once the initializer is recursively constructed and the declaration's type is known, set the type of the\n     * initializer to the type of the declaration, checking that this initializer is valid for the provided type */\n    set type(value: CType) {\n        const error = () => {\n            throw new checks.ExpressionTypeError(this.node, \"initializer to match type\");\n        };\n        this._memberTypes = [];\n\n        if (value instanceof CArray) {\n            if (this.body.length > (value.length ?? Infinity)) error(); // too many elements in this initializer\n            for (let i = 0; i < this.body.length; i++) {\n                this.body[i] = CInitializer.typeCheck(value.type, this.body[i]);\n                this._memberTypes.push(value.type);\n            }\n\n        } else if (value instanceof CStruct) {\n            if (this.body.length > value.members.length) error(); // too many members\n            for (let i = 0; i < this.body.length; i++) {\n                this.body[i] = CInitializer.typeCheck(value.members[i].type, this.body[i]);\n                this._memberTypes.push(value.members[i].type);\n            }\n\n        } else if (value instanceof CUnion) {\n            if (this.body.length > 1) error();\n            // unions have to be initialized to the first member in the union\n            if (this.body.length === 1) {\n                this.body[0] = CInitializer.typeCheck(value.members[0].type, this.body[0]);\n                this._memberTypes.push(value.members[0].type);\n            }\n\n        } else {\n            error();\n        }\n        this._type = value;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        for (const c of this.body) yield* c.identifiers();\n    }\n\n    private static typeCheck(desiredType: CType, expr: CExpression | CInitializer): CExpression | CInitializer {\n        if (expr instanceof CInitializer) {\n            expr.type = desiredType;\n        } else {\n            CAssignment.checkAssignmentValid(expr.node, desiredType, expr);\n\n            if (expr instanceof CConstant && desiredType instanceof CArithmetic && expr.type !== desiredType) {\n                expr = expr.changeType(desiredType);\n            }\n        }\n        return expr;\n    }\n}\n","import {CError} from \"../c_error\";\nimport type {ParseNode} from \"../parsing\";\nimport type {CDeclaration} from \"./declarations\";\nimport {CFuncDeclaration, CFuncDefinition, CVarDeclaration, CVarDefinition} from \"./declarations\";\nimport type {CLabelledStatement} from \"./statements\";\nimport type {CCompound, CType} from \"./types\";\n\n/**\n * Represents a scope storing identifiers (variables & functions) and tags (struct, union & enum names) in the IR.\n * Each one has a parent scope excluding the base scope for the translation unit.\n *\n * e.g. base scope (function declarations) <- function scope (contains parameters) <- compound statement scope (fn locals).\n *\n * If a tag or identifier isn't found in the current scope, parents are checked.\n */\nexport class Scope {\n    private tags = new Map<string, CCompound>(); // names of structs, unions & enums\n    private identifiers = new Map<string, CDeclaration>(); // names of variables and functions\n    private typedefs = new Map<string, CType>();\n    labelledStatement?: CLabelledStatement;\n\n    constructor(readonly node?: ParseNode,\n                readonly parent?: Scope,\n                readonly func: CFuncDefinition | undefined = parent?.func) {\n    }\n\n    private _getTag(tag: string): CCompound | undefined {\n        // perform recursive lookup in parents if not found\n        return this.tags.get(tag) ?? this.parent?._getTag(tag);\n    }\n\n    lookupTag<T extends CCompound>(tag: string, wantedType?: { new(...args: any[]): T }, node?: ParseNode): T | undefined {\n        const result = this._getTag(tag);\n        if (wantedType && result && wantedType.prototype !== Object.getPrototypeOf(result)) {\n            throw new ScopeError(\"`\" + tag + \"` was already declared as a \" + result.typeName, result.node, node);\n        }\n        return result as T | undefined;\n    }\n\n    addTag(value: CCompound): void {\n        if (!value.name) throw new Error(\"Cannot add nameless compound type to scope\"); // shouldn't happen\n        if (this._getTag(value.name)) throw new ScopeError(\"Compound type `\" + value.name + \"` is already defined!\", value.node);\n        this.tags.set(value.name, value);\n    }\n\n    private _getId(name: string): CDeclaration | undefined {\n        return this.identifiers.get(name) ?? this.parent?._getId(name);\n    }\n\n    lookupIdentifier(name: string, node?: ParseNode): CDeclaration {\n        const result = this._getId(name);\n        if (!result) {\n            throw new ScopeError(\"Failed to find `\" + name + \"`\", node);\n        }\n        return result;\n    }\n\n    addIdentifier(value: CDeclaration): void {\n        const existing = this.identifiers.get(value.name); // allowing redefining identifiers defined in parent scopes\n        if (existing) {\n            if (existing.type.equals(value.type) && existing instanceof CFuncDeclaration && value instanceof CFuncDefinition) {\n                // allow replacement of function declaration with definition\n                if (existing.linkage !== \"external\" && value.linkage === \"external\") {\n                    // linkage inherited from first declaration\n                    value.linkage = existing.linkage;\n                }\n                existing.definition = value;\n            } else if (existing.type.equals(value.type) && value instanceof CFuncDeclaration) {\n                // allow functions to be redeclared (but don't override instance in scope)\n                if (existing instanceof CFuncDeclaration) existing.fnImport ||= value.fnImport;\n                return;\n            } else if (existing.type.equals(value.type) && existing instanceof CVarDeclaration && value instanceof CVarDefinition) {\n                // allow replacement of variable declaration with definition\n                if (existing.linkage !== \"external\" && existing.linkage !== value.linkage) {\n                    // check linkage is the same\n                    throw new ScopeError(\"Variable `\" + value.name + \"` is already defined with \" + existing.linkage + \" linkage\", existing.node, value.node);\n                }\n                existing.definition = value;\n            } else if (existing.type.equals(value.type) && value instanceof CVarDeclaration) {\n                // allow variables to be redeclared (but don't override instance in scope)\n                if (existing.linkage !== \"external\" && existing.linkage !== value.linkage) {\n                    // check linkage is the same\n                    throw new ScopeError(\"Variable `\" + value.name + \"` is already defined with \" + existing.linkage + \" linkage\", existing.node, value.node);\n                }\n                return;\n            } else {\n                throw new ScopeError(\"Identifier `\" + value.name + \"` is already defined in this scope!\", existing.node, value.node);\n            }\n        }\n        this.identifiers.set(value.name, value);\n    }\n\n    get declarations(): ReadonlyArray<CDeclaration> {\n        return [...this.identifiers.values()];\n    }\n\n    private _getTypedef(id: string): CType | undefined {\n        // perform recursive lookup in parents if not found\n        return this.typedefs.get(id) ?? this.parent?._getTypedef(id);\n    }\n\n    lookupTypedef(id: string, node?: ParseNode): CType {\n        const result = this._getTypedef(id);\n        if (result === undefined) {\n            throw new ScopeError(\"typedef `\" + id + \"` not found in scope\", node);\n        }\n        return result;\n    }\n\n    addTypedef(id: string, type: CType, node?: ParseNode): void {\n        const existing = this._getTypedef(id);\n        if (existing) {\n            if (existing.equals(type)) return;\n            throw new ScopeError(\"typedef already defined with a different type\", node);\n        }\n        this.typedefs.set(id, type);\n    }\n}\n\nclass ScopeError extends CError {\n    name = \"ScopeError\";\n}\n","import type * as pt from \"../parsing/parsetree\";\nimport {CFuncDefinition} from \"./declarations\";\nimport {CExpression, CAssignment, CValue} from \"./expressions\";\nimport {Scope} from \"./scope\";\nimport {ExpressionTypeError, asArithmeticOrPointer} from \"./type_checking\";\n\n// classes to represent the various C statements in the IR\nexport type CStatement =\n    CCompoundStatement | CExpressionStatement | CNop |\n    CIf | CForLoop | CWhileLoop | CDoLoop | CSwitch |\n    CGoto | CContinue | CBreak | CReturn;\n\nexport class CCompoundStatement {\n    readonly scope: Scope;\n    readonly statements: CStatement[] = [];\n\n    constructor(readonly node: pt.ParseNode, readonly parent: CStatement | CFuncDefinition) {\n        this.scope = new Scope(node, parent.scope, parent instanceof CFuncDefinition ? parent : undefined);\n    }\n}\n\nexport class CExpressionStatement {\n    constructor(readonly node: pt.ParseNode, readonly expression: CExpression, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CNop {\n    constructor(readonly node: pt.NoOp, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CIf {\n    ifBody?: CStatement;\n    elseBody?: CStatement;\n\n    constructor(readonly node: pt.IfStatement, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CForLoop {\n    init?: CExpressionStatement | CExpressionStatement[] | CNop;\n    test?: CExpressionStatement | CNop;\n    update?: CExpression;\n    body?: CStatement;\n\n    readonly scope: Scope; // own scope for init variable\n\n    constructor(readonly node: pt.ForLoop, readonly parent: CStatement) {\n        this.scope = new Scope(node, parent.scope);\n    }\n}\n\nexport class CWhileLoop {\n    body?: CStatement;\n\n    constructor(readonly node: pt.WhileLoop, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CDoLoop {\n    body?: CStatement;\n\n    constructor(readonly node: pt.DoWhileLoop, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CGoto {\n    constructor(readonly node: pt.GotoStatement, readonly target: CLabelledStatement, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CSwitch {\n    children: {cases: CValue[], body: CCompoundStatement, default: boolean}[] = [];\n\n    constructor(readonly node: pt.SwitchStatement, readonly expression: CExpression, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CContinue {\n    constructor(readonly node: pt.ContinueStatement,\n                readonly loop: CForLoop | CWhileLoop | CDoLoop,\n                readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CBreak {\n    constructor(readonly node: pt.BreakStatement,\n                readonly target: CForLoop | CWhileLoop | CDoLoop | CSwitch,\n                readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CReturn {\n    constructor(readonly node: pt.ReturnStatement,\n                readonly func: CFuncDefinition,\n                public value: CExpression | undefined,\n                readonly parent: CStatement) {\n\n        if (value === undefined) {\n            if (func.type.returnType.bytes > 0) {\n                // function return type is not void but a value was not provided\n                throw new ExpressionTypeError(node, \"`return [expression]`\", \"`return;`\");\n            }\n        } else {\n            if (!func.type.returnType.equals(value.type)) {\n                // check provided return value matches the function's return type\n                CAssignment.checkAssignmentValid(node, func.type.returnType, value);\n            }\n        }\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\n// not a CStatement, used to store labelled statements in Scopes\nexport class CLabelledStatement {\n    body?: CStatement;\n\n    constructor(readonly node: pt.Statement, readonly label: string) {\n    }\n}\n","import {CVarDefinition} from \"../declarations\";\nimport {CExpression, CConstant, CIdentifier, CSizeof, CBitwiseNot, CLogicalNot, CCast, CMulDiv, CMod, CAddSub, CShift, CRelational, CEquality, CBitwiseAndOr, CLogicalAndOr, CConditional, CUnaryPlusMinus, CValue, CInitializer} from \"../expressions\";\nimport {ExpressionTypeError} from \"../type_checking\";\nimport {CArithmetic, CSizeT, CPointer} from \"../types\";\n\ntype ExtraFn = (e: CExpression) => CValue;\n\nexport function constExpression(e: CExpression, extra?: ExtraFn): CValue {\n    if (e instanceof CConstant) {\n        return {value: e.value, type: e.type};\n    } else if (e instanceof CIdentifier && e.value instanceof CVarDefinition && e.value.type.qualifier === \"const\" && e.value.staticValue instanceof CConstant) {\n        return constExpression(e.value.staticValue, extra);\n\n    } else if (e instanceof CSizeof) {\n        return normalizeType({value: e.body.bytes, type: CSizeT});\n\n    } else if (e instanceof CUnaryPlusMinus) {\n        const v = constExpression(e.body, extra);\n        return e.op === \"+\" ? v : {value: -v.value, type: e.type};\n\n    } else if (e instanceof CBitwiseNot) {\n        const v = constInteger(e.body, extra);\n        return normalizeType({value: ~v.value, type: v.type});\n\n    } else if (e instanceof CLogicalNot) {\n        const v = constExpression(e.body, extra);\n        // eslint-disable-next-line eqeqeq\n        return {value: v.value == 0 ? 1n : 0n, type: CArithmetic.S32};\n\n    } else if (e instanceof CCast && (e.type instanceof CArithmetic || e.type instanceof CPointer)) {\n        const v = constExpression(e.body, extra);\n        return normalizeType({value: v.value, type: e.type});\n\n    } else if (e instanceof CMulDiv) {\n        const lhs = constExpression(e.lhs, extra), rhs = constExpression(e.rhs, extra);\n        if (e.op === \"*\") {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) * Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) * BigInt(rhs.value), type: e.type});\n        } else {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) / Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) / BigInt(rhs.value), type: e.type});\n        }\n\n    } else if (e instanceof CMod) {\n        const lhs = constInteger(e.lhs, extra), rhs = constInteger(e.rhs, extra);\n        return normalizeType({value: lhs.value % rhs.value, type: e.type});\n\n    } else if (e instanceof CAddSub && e.type instanceof CArithmetic) {\n        const lhs = constExpression(e.lhs, extra), rhs = constExpression(e.rhs, extra);\n        if (e.op === \"+\") {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) + Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) + BigInt(rhs.value), type: e.type});\n        } else {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) - Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) - BigInt(rhs.value), type: e.type});\n        }\n\n    } else if (e instanceof CShift) {\n        const lhs = constInteger(e.lhs, extra), rhs = constInteger(e.rhs, extra);\n        if (e.dir === \"left\") {\n            return normalizeType({value: lhs.value << rhs.value, type: e.type});\n        }\n        return normalizeType({value: lhs.value >> rhs.value, type: e.type});\n\n    } else if (e instanceof CRelational) {\n        const lhs = constExpression(e.lhs, extra), rhs = constExpression(e.rhs, extra);\n        if (e.op === \"LT\") {\n            return {value: lhs.value < rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else if (e.op === \"GT\") {\n            return {value: lhs.value > rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else if (e.op === \"LEq\") {\n            return {value: lhs.value <= rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else {\n            return {value: lhs.value >= rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CEquality) {\n        const lhs = constExpression(e.lhs, extra), rhs = constExpression(e.rhs, extra);\n        if (e.op === \"==\") {\n            // eslint-disable-next-line eqeqeq\n            return {value: lhs.value == rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else {\n            // eslint-disable-next-line eqeqeq\n            return {value: lhs.value != rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CBitwiseAndOr) {\n        const lhs = constInteger(e.lhs, extra), rhs = constInteger(e.rhs, extra);\n        if (e.op === \"and\") {\n            return normalizeType({value: lhs.value & rhs.value, type: e.type});\n        } else if (e.op === \"or\") {\n            return normalizeType({value: lhs.value | rhs.value, type: e.type});\n        } else {\n            return normalizeType({value: lhs.value ^ rhs.value, type: e.type});\n        }\n\n    } else if (e instanceof CLogicalAndOr) {\n        const lhs = constExpression(e.lhs, extra);\n        if (e.op === \"and\") {\n            // eslint-disable-next-line eqeqeq\n            if (lhs.value != 0 && constExpression(e.rhs, extra).value != 0) {\n                return {value: 1n, type: CArithmetic.S32};\n            }\n            return {value: 0n, type: CArithmetic.S32};\n        } else {\n            // eslint-disable-next-line eqeqeq\n            if (lhs.value != 0 || constExpression(e.rhs, extra).value != 0) {\n                return {value: 1n, type: CArithmetic.S32};\n            }\n            return {value: 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CConditional && (e.type instanceof CArithmetic || e.type instanceof CPointer)) {\n        const test = constExpression(e.test, extra);\n        let value: CValue;\n        // eslint-disable-next-line eqeqeq\n        if (test.value != 0) {\n            value = constExpression(e.trueValue, extra);\n        } else {\n            value = constExpression(e.falseValue, extra);\n        }\n        return normalizeType({value: value.value, type: e.type});\n\n    }\n\n    // for adding addressof support etc for static initializers\n    if (extra !== undefined) return extra(e);\n\n    throw new ExpressionTypeError(e.node, \"constant expression\");\n}\n\nexport function constInteger(e: CExpression, extra?: ExtraFn): CValue & {readonly value: bigint} {\n    const v = constExpression(e, extra);\n    if (v.type instanceof CArithmetic && v.type.type !== \"float\") return {value: BigInt(v.value), type: v.type};\n    throw new ExpressionTypeError(e.node, \"expected constant integer expression\");\n}\n\nfunction normalizeType(v: CValue): CValue {\n    if (v.type instanceof CArithmetic) {\n        if (CArithmetic.BOOL.equals(v.type)) {\n            // eslint-disable-next-line eqeqeq\n            return {value: v.value == 0 ? 0n : 1n, type: CArithmetic.BOOL};\n        } else if (v.type.type === \"float\") {\n            return {value: typeof v.value === \"number\" ? v.value : Number(v.value), type: v.type};\n        } else {\n            let value: bigint;\n            if (typeof v.value === \"number\") {\n                // need to emulate runtime behaviour - i.e. the use of the trunc_sat instructions\n                if (isNaN(v.value)) {\n                    value = 0n;\n                } else if (v.value > v.type.maxValue) {\n                    value = BigInt(v.type.maxValue);\n                } else if (v.value < v.type.minValue) {\n                    value = BigInt(v.type.minValue);\n                } else {\n                    value = BigInt(v.value);\n                }\n            } else {\n                value = v.value;\n            }\n\n            const bitmask = 2n ** BigInt(8 * v.type.bytes) - 1n;\n            if (v.type.type === \"unsigned\") {\n                value &= bitmask;\n            } else { // signed\n                const minValue = BigInt(v.type.minValue);\n                value = ((value - minValue) & bitmask) + minValue;\n            }\n\n            return {value, type: v.type};\n        }\n    } else { // instanceof CPointer\n        // normalize as if U32\n        const value = normalizeType({value: v.value, type: CArithmetic.U32}).value;\n        return {value: value, type: v.type};\n    }\n}\n\nexport const normalizeValueType = normalizeType;\n","import {ParseNode, ParseTreeValidationError, pt} from \"../../parsing\";\nimport {CFuncDefinition, CFuncDeclaration} from \"../declarations\";\nimport {\n    CExpression, CConstant, CIdentifier, CFunctionCall, CMemberAccess, CDereference, CConditional,\n    CAssignment, CStringLiteral, CIncrDecr, CAddressOf, CUnaryPlusMinus, CBitwiseNot, CLogicalNot, CSizeof, CAddSub,\n    CCast, CComma, CMulDiv, CMod, CShift, CRelational, CEquality, CBitwiseAndOr, CLogicalAndOr, CArrayPointer, CValue\n} from \"../expressions\";\nimport {Scope} from \"../scope\";\nimport {CArithmetic, CArray} from \"../types\";\nimport {constInteger} from \"./constant_expressions\";\nimport {getType} from \"./type_transform\";\n\n/** Transform expressions from the parse tree */\nexport function ptExpression(e: pt.Expression, scope: Scope): CExpression {\n    if (e instanceof pt.ConstantExpression) {\n        // pt.ConstantExpression is a wrapped class in the parse tree denoting where constant expressions are expected.\n        return ptExpression(e.expr, scope);\n\n    } else if (e instanceof pt.Constant) {\n        return ptConstant(e);\n\n    } else if (e instanceof pt.Identifier) {\n        const id = new CIdentifier(e, scope.lookupIdentifier(e.name, e));\n        if (scope.func) scope.func.dependencies.set(id.value, true);\n\n        if (id.type instanceof CArray) {\n            return new CArrayPointer(e, id);\n        }\n        return id;\n\n    } else if (e instanceof pt.StringLiteral) {\n        const arr: bigint[] = []; // split the literal into characters taking into account escape sequences\n        const charRegex = /[^\\\\\\n\"]|\\\\(?:[^x0-7\\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3})/y;\n        while (charRegex.lastIndex < e.value.length) {\n            const match = charRegex.exec(e.value);\n            if (match && charRegex.lastIndex !== 0) {\n                arr.push(BigInt(unescapeChar(match[0], e).codePointAt(0) ?? 0)); // unescape the char if needed\n            } else {\n                // regex didn't match the body for some reason, this shouldn't happen\n                throw new ParseTreeValidationError(e, \"Invalid string literal\");\n            }\n        }\n        arr.push(0n); // null terminator\n        return new CArrayPointer(e, new CStringLiteral(e, arr));\n\n    } else if (e instanceof pt.UnaryExpression) {\n        return ptUnary(e, scope);\n\n    } else if (e instanceof pt.BinaryExpression) {\n        return ptBinary(e, scope);\n\n    } else if (e instanceof pt.SizeofExpression) {\n        if (e.body instanceof pt.Expression) { // sizeof [expression]\n            let bodyExpr = ptExpression(e.body, scope);\n            if (bodyExpr instanceof CArrayPointer) bodyExpr = bodyExpr.arrayIdentifier;\n            return new CSizeof(e, bodyExpr.type);\n        } else { // sizeof [type]\n            return new CSizeof(e, getType(e.body, scope));\n        }\n\n    } else if (e instanceof pt.CastExpression) {\n        return new CCast(e, getType(e.targetType, scope), ptExpression(e.body, scope));\n\n    } else if (e instanceof pt.FunctionCallExpression) {\n        return new CFunctionCall(e, ptExpression(e.fn, scope), (e.args ?? []).map(e => ptExpression(e, scope)));\n\n    } else if (e instanceof pt.MemberAccessExpression) {\n        let body = ptExpression(e.lhs, scope);\n        if (!e.pointer) { // transform into pointer access\n            body = new CAddressOf(e, body);\n        }\n        return new CMemberAccess(e, body, e.rhs);\n\n    } else if (e instanceof pt.ConditionalExpression) {\n        return new CConditional(e, ptExpression(e.condition, scope), ptExpression(e.trueValue, scope), ptExpression(e.falseValue, scope));\n\n    } else if (e instanceof pt.AssignmentExpression) {\n        return new CAssignment(e, ptExpression(e.lhs, scope), ptExpression(e.rhs, scope), e.assignType);\n\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid expression\");\n}\n\n/** Evaluate an expression at compile time to an integer constant */\nexport function evalIntegerConstant(c: pt.ConstantExpression, scope: Scope): CValue & {value: bigint} {\n    const expr = ptExpression(c.expr, scope);\n    return constInteger(expr);\n}\n\nfunction ptUnary(e: pt.UnaryExpression, scope: Scope): CExpression {\n    // transform unary expressions\n    const body = ptExpression(e.body, scope);\n    if (e.type === \"prefixIncrement\") return new CIncrDecr(e, body, \"++\", \"pre\");\n    if (e.type === \"prefixDecrement\") return new CIncrDecr(e, body, \"--\", \"pre\");\n    if (e.type === \"postfixIncrement\") return new CIncrDecr(e, body, \"++\", \"post\");\n    if (e.type === \"postfixDecrement\") return new CIncrDecr(e, body, \"--\", \"post\");\n    if (e.type === \"addressOf\") return new CAddressOf(e, body);\n    if (e.type === \"dereference\") return new CDereference(e, body);\n    if (e.type === \"unaryPlus\") return new CUnaryPlusMinus(e, body, \"+\");\n    if (e.type === \"unaryMinus\") return new CUnaryPlusMinus(e, body, \"-\");\n    if (e.type === \"bitwiseNot\") return new CBitwiseNot(e, body);\n    if (e.type === \"logicalNot\") return new CLogicalNot(e, body);\n\n    throw new ParseTreeValidationError(e, \"Invalid unary expression\");\n}\n\nfunction ptBinary(e: pt.BinaryExpression, scope: Scope): CExpression {\n    // transform binary expressions\n    const lhs = ptExpression(e.lhs, scope), rhs = ptExpression(e.rhs, scope);\n\n    if (e.type === \"mul\") return new CMulDiv(e, lhs, rhs, \"*\");\n    if (e.type === \"div\") return new CMulDiv(e, lhs, rhs, \"/\");\n    if (e.type === \"mod\") return new CMod(e, lhs, rhs);\n    if (e.type === \"add\") return new CAddSub(e, lhs, rhs, \"+\");\n    if (e.type === \"sub\") return new CAddSub(e, lhs, rhs, \"-\");\n    if (e.type === \"bitwiseShiftLeft\") return new CShift(e, lhs, rhs, \"left\");\n    if (e.type === \"bitwiseShiftRight\") return new CShift(e, lhs, rhs, \"right\");\n\n    if (e.type === \"relationalLT\") return new CRelational(e, lhs, rhs, \"LT\");\n    if (e.type === \"relationalGT\") return new CRelational(e, lhs, rhs, \"GT\");\n    if (e.type === \"relationalLEq\") return new CRelational(e, lhs, rhs, \"LEq\");\n    if (e.type === \"relationalGEq\") return new CRelational(e, lhs, rhs, \"GEq\");\n    if (e.type === \"relationalEq\") return new CEquality(e, lhs, rhs, \"==\");\n    if (e.type === \"relationalNEq\") return new CEquality(e, lhs, rhs, \"!=\");\n\n    if (e.type === \"bitwiseAnd\") return new CBitwiseAndOr(e, lhs, rhs, \"and\");\n    if (e.type === \"bitwiseXor\") return new CBitwiseAndOr(e, lhs, rhs, \"xor\");\n    if (e.type === \"bitwiseOr\") return new CBitwiseAndOr(e, lhs, rhs, \"or\");\n    if (e.type === \"logicalAnd\") return new CLogicalAndOr(e, lhs, rhs, \"and\");\n    if (e.type === \"logicalOr\") return new CLogicalAndOr(e, lhs, rhs, \"or\");\n\n    if (e.type === \"comma\") return new CComma(e, lhs, rhs);\n    if (e.type === \"arraySubscript\") {\n        // transform `a[b]` into `*(a+b)`\n        return new CDereference(e, new CAddSub(e, ptExpression(e.lhs, scope), ptExpression(e.rhs, scope), \"+\"));\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid binary expression\");\n}\n\n/** Transform a constant\n *\n * This is quite complicated because we have to work out what type to give the constant, following the rules set out in\n * the standard\n */\nexport function ptConstant(e: pt.Constant): CConstant {\n    let value = e.value;\n    let type: CArithmetic;\n\n    if (e.valueType === \"int\" || e.valueType === \"oct\" || e.valueType === \"hex\") {\n        let unsigned = false, long = false;\n        value = value.toLowerCase();\n        if (value.endsWith(\"u\")) {\n            value = value.slice(0, -1);\n            unsigned = true;\n        }\n        if (value.endsWith(\"l\")) {\n            value = value.slice(0, -1);\n            long = true;\n            // may be a second l for long long\n            if (value.endsWith(\"l\")) value = value.slice(0, -1);\n        }\n        if (!unsigned && value.endsWith(\"u\")) {\n            // check u again as u and l can appear in either order\n            value = value.slice(0, -1);\n            unsigned = true;\n        }\n\n        let num: bigint; // all integer constants are stored as BigInt\n        if (e.valueType !== \"oct\") {\n            // BigInt constructor natively handles decimal values and hexadecimal values prefixed with 0x\n            num = BigInt(value);\n        } else {\n            // Have to manually construct octal constants\n            num = 0n;\n            for (let i = 0; i < value.length - 1; i++) { // ignore the leading 0\n                num += BigInt(value[value.length - 1 - i]) * (8n ** BigInt(i));\n            }\n        }\n\n        // Choose the list of possible types from the suffixes and the constant type used (decimal, hex, octal)\n        let possibleTypes;\n        if (e.valueType === \"int\" && !unsigned && !long) {\n            possibleTypes = [CArithmetic.S32, CArithmetic.S64, CArithmetic.U64];\n        } else if (e.valueType !== \"int\" && !unsigned && !long) {\n            possibleTypes = [CArithmetic.S32, CArithmetic.U32, CArithmetic.S64, CArithmetic.U64];\n        } else if (unsigned && long) {\n            possibleTypes = [CArithmetic.U64];\n        } else if (long) {\n            possibleTypes = [CArithmetic.S64, CArithmetic.U64];\n        } else { // if (unsigned)\n            possibleTypes = [CArithmetic.U32, CArithmetic.U64];\n        }\n\n        // find smallest acceptable type which fits the value\n        for (const type of possibleTypes) {\n            if (num >= type.minValue && num <= type.maxValue) {\n                return new CConstant(e, type, num);\n            }\n        }\n        throw new ParseTreeValidationError(e, \"Integer constant too large for its type\");\n\n    } else if (e.valueType === \"float\") {\n        // floats default to double unless suffixed with \"f\"\n        if (value.endsWith(\"f\")) {\n            value = value.slice(0, -1);\n            type = CArithmetic.Fp32;\n        } else {\n            type = CArithmetic.Fp64;\n        }\n        return new CConstant(e, type, parseFloat(value));\n\n    } else if (e.valueType === \"char\") {\n        value = unescapeChar(value, e);\n        return new CConstant(e, CArithmetic.U8, BigInt(value.codePointAt(0)));\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid constant type?\");\n}\n\n/** Unescape strings as defined in the C standard */\nfunction unescapeChar(s: string, node?: ParseNode): string {\n    if (s.startsWith(\"\\\\\")) {\n        if (s === \"\\\\n\") return \"\\n\";\n        if (s === \"\\\\t\") return \"\\t\";\n        if (s === \"\\\\v\") return \"\\v\";\n        if (s === \"\\\\b\") return \"\\b\";\n        if (s === \"\\\\r\") return \"\\r\";\n        if (s === \"\\\\f\") return \"\\f\";\n        if (s === \"\\\\a\") return \"\\x07\";\n        if (s === \"\\\\\\\\\") return \"\\\\\";\n        if (s === \"\\\\?\") return \"?\";\n        if (s === \"\\\\'\") return \"'\";\n        if (s === '\\\\\"') return '\"';\n\n        let value: number;\n        if (s.startsWith(\"\\\\x\")) {\n            // hex constant\n            value = parseInt(s.slice(2), 16);\n        } else {\n            // octal constant\n            value = parseInt(s.slice(1), 8);\n        }\n\n        if (!isNaN(value) && value >= 0 && value <= 255) {\n            return String.fromCharCode(value);\n        }\n        throw new ParseTreeValidationError(node, \"Invalid character escape\");\n    }\n\n    const codePoint = s.codePointAt(0);\n    if (s.length !== 1 || codePoint === undefined || codePoint > 255) {\n        throw new ParseTreeValidationError(node, \"Invalid character\");\n    }\n    return s;\n}\n","import {CVarDefinition} from \"../declarations\";\nimport {CConstant} from \"../expressions\";\nimport {Scope} from \"../scope\";\nimport {CType, getArithmeticType, CPointer, addQualifier, CFuncType, CNotFuncType, CArray, CEnum, CStruct, CUnion, CCompoundMember, CVoid, CArithmetic} from \"../types\";\nimport {ParseTreeValidationError, pt} from \"../../parsing/\";\nimport {evalIntegerConstant} from \"./expr_transform\";\n\ntype GeneralTypeDecl = {\n    typeInfo: pt.SpecifierQualifiers | pt.DeclarationSpecifiers,\n    declarator?: pt.Declarator | pt.AbstractDeclarator\n};\n\n/** helper function for specifier & declarator type */\nexport function getType(o: GeneralTypeDecl, scope: Scope): CType {\n    let type = getSpecifierType(o.typeInfo, scope);\n    if (o.typeInfo.qualifierList.length) type = addQualifier(type, o.typeInfo.qualifierList[0]);\n    if (o.declarator) type = getDeclaratorType(type, o.declarator, scope);\n    return type;\n}\n\n/** transform the CType from a type specifier into the declarator type */\nexport function getDeclaratorType(type: CType, declarator: pt.Declarator | pt.AbstractDeclarator, scope: Scope): CType {\n    let d: pt.Declarator | pt.AbstractDeclarator | undefined = declarator;\n\n    while (d && !(d instanceof pt.IdentifierDeclarator)) {\n        if (d instanceof pt.PointerDeclarator || d instanceof pt.AbstractPointerDeclarator) {\n            let ptr: pt.Pointer | undefined = d.pointer;\n            while (ptr) {\n                type = new CPointer(ptr, type, ptr.qualifierList?.includes(\"const\"));\n                ptr = ptr.body;\n            }\n            d = d.body;\n\n        } else if (d instanceof pt.ArrayDeclarator || d instanceof pt.AbstractArrayDeclarator) {\n            type = new CArray(d, type);\n            if (d.length) {\n                type.length = Number(evalIntegerConstant(d.length, scope).value);\n                if (type.length <= 0) throw new ParseTreeValidationError(d.length, \"Invalid array length\");\n            }\n\n            d = d.body;\n        } else { // d instanceof pt.(Abstract)FunctionDeclarator\n            const parameterTypes = [];\n            let parameterNames = undefined;\n\n            for (const param of d.args ?? []) {\n                const type = getType(param, scope);\n                if (type instanceof CFuncType) {\n                    throw new ParseTreeValidationError(param, \"Functions cannot be parameters\");\n                }\n                parameterTypes.push(type);\n\n                if (param.declarator && !param.declarator.abstractDeclarator) {\n                    parameterNames ??= [];\n                    parameterNames.push(getDeclaratorName(param.declarator));\n                }\n\n                if (parameterNames && parameterNames.length !== parameterTypes.length) {\n                    throw new ParseTreeValidationError(param, \"Unexpected mix of abstract & non-abstract declarators\");\n                }\n            }\n\n            if (parameterTypes.length === 1 && parameterTypes[0] instanceof CVoid) parameterTypes.shift();\n\n            if (parameterTypes.length === 0) {\n                // ensure parameterNames are always non-null in function definitions\n                parameterNames = [];\n            }\n\n            type = new CFuncType(d, type as CNotFuncType, parameterTypes, parameterNames, d.variadic);\n            d = d.body;\n        }\n    }\n    return type;\n}\n\nexport function getDeclaratorName(declarator: pt.Declarator | pt.InitDeclarator): string {\n    while (!(declarator instanceof pt.IdentifierDeclarator)) {\n        declarator = declarator.body;\n    }\n    return declarator.id;\n}\n\n/** Get the base type from the list of specifiers */\nfunction getSpecifierType(d: pt.SpecifierQualifiers | pt.DeclarationSpecifiers, scope: Scope): CType {\n    const specifiers = d.specifierList;\n    const singleSpecifier = specifiers.length === 1 ? specifiers[0] : undefined;\n\n    if (singleSpecifier instanceof pt.StructUnionSpecifier) {\n        const type = singleSpecifier.structure === \"struct\" ? CStruct : CUnion;\n        let structure = new type(singleSpecifier, singleSpecifier.id);\n        if (singleSpecifier.id) {\n            // lookup tag and if it already exists use the existing instance\n            const existing: CStruct | CUnion = scope.lookupTag(singleSpecifier.id, type as any, singleSpecifier) as any;\n            if (existing) {\n                structure = existing;\n            } else {\n                scope.addTag(structure);\n            }\n        }\n        if (!singleSpecifier.declarations) return structure;\n\n        const values: CCompoundMember[] = []; // populate struct/union members if provided\n        for (const declaration of singleSpecifier.declarations) {\n            const baseType = getType(declaration, scope);\n\n            for (const declarator of declaration.list) {\n                const type = getDeclaratorType(baseType, declarator, scope);\n                const name = getDeclaratorName(declarator);\n                if (type.incomplete || type.bytes === 0 || type instanceof CFuncType) {\n                    throw new ParseTreeValidationError(declarator, \"Type must be complete\");\n                }\n\n                values.push(new CCompoundMember(declaration, name, type));\n            }\n        }\n        structure.members = values;\n        structure.node = singleSpecifier; // set the parse node to point to the node which actually defined the members\n        return structure;\n\n    } else if (singleSpecifier instanceof pt.EnumSpecifier) {\n        let cEnum = new CEnum(singleSpecifier, singleSpecifier.id);\n        if (singleSpecifier.id) {\n            // lookup tag and if it already exists use its instance\n            const existing = scope.lookupTag(singleSpecifier.id, CEnum, singleSpecifier);\n            if (existing) {\n                cEnum = existing;\n            } else {\n                scope.addTag(cEnum);\n            }\n        }\n        if (!singleSpecifier.body) return CArithmetic.S32;\n\n        // enum members either provide their own value or use the last value + 1, starting at 0\n        let nextValue = 0n;\n        const values = [];\n        for (const e of singleSpecifier.body) { // populate enum\n            if (e.value) nextValue = evalIntegerConstant(e.value, scope).value;\n\n            // enum constants are `int`s!!!\n            const enumConstant = new CVarDefinition(e, e.id, addQualifier(CArithmetic.S32, \"const\"), \"static\", \"internal\");\n            enumConstant.staticValue = new CConstant(e, CArithmetic.S32, nextValue);\n\n            scope.addIdentifier(enumConstant); // add the enum member as a constant to the scope\n            values.push({name: e.id, value: nextValue++});\n        }\n        cEnum.values = values;\n        cEnum.node = singleSpecifier;\n        return CArithmetic.S32;\n\n    } else if (specifiers.every(x => typeof x === 'string')) {\n        // arithmetic or void\n        const type = getArithmeticType(specifiers as ReadonlyArray<pt.TypeSpecifier & string>);\n        if (type) return type;\n\n    } else if (specifiers.length === 1 && specifiers[0] instanceof pt.CustomTypeSpecifier) {\n        // typedef\n        return scope.lookupTypedef(specifiers[0].name);\n    }\n\n    throw new ParseTreeValidationError(d, \"Invalid specifier\");\n}\n","import {CError} from \"../c_error\";\nimport type {ParseNode} from \"../parsing\";\nimport type {CExpression} from \"./expressions\";\nimport {CArithmetic, CPointer, CStruct, CUnion, CType, CFuncType, checkTypeComplete} from \"./types\";\n\nexport class ExpressionTypeError extends CError {\n    name = \"ExpressionTypeError\";\n\n    constructor(node: ParseNode, readonly wantedType: string, readonly actualType?: string) {\n        super(actualType ? `Expected ${wantedType} but got ${actualType} instead!` : `Expected ${wantedType}`, node);\n    }\n}\n\n// Basic type checking for expressions, throws an exception if the expression's type is not the expected type\n\nexport function asArithmetic(node: ParseNode, t: CType): CArithmetic {\n    if (t instanceof CArithmetic) return t;\n    throw new ExpressionTypeError(node, \"arithmetic\", t.typeName);\n}\n\nexport function asInteger(node: ParseNode, t: CType): CArithmetic {\n    const arithmetic = asArithmetic(node, t);\n    switch (arithmetic.type) {\n    case \"signed\":\n    case \"unsigned\":\n        return arithmetic;\n    default:\n        throw new ExpressionTypeError(node, \"integer\", t.typeName);\n    }\n}\n\nexport function asPointer(node: ParseNode, t: CType): CPointer {\n    if (t instanceof CPointer) return t;\n    throw new ExpressionTypeError(node, \"pointer\", t.typeName);\n}\n\nexport function asArithmeticOrPointer(node: ParseNode, t: CType): CArithmetic | CPointer {\n    if (t instanceof CArithmetic) return t;\n    if (t instanceof CPointer) return t;\n    throw new ExpressionTypeError(node, \"arithmetic or pointer\", t.typeName);\n}\n\nexport function asNonFunctionPointer<T extends CType>(node: ParseNode, t: T): T {\n    if (t instanceof CPointer && t.type instanceof CFuncType) {\n        throw new ExpressionTypeError(node, \"non-function pointer\", \"function pointer\");\n    }\n    return t;\n}\n\nexport function asFunction(node: ParseNode, t: CType): CFuncType {\n    if (t instanceof CFuncType) return t;\n    if (t instanceof CPointer && t.type instanceof CFuncType) return t.type;\n    throw new ExpressionTypeError(node, \"function\", t.typeName);\n}\n\nexport function asStructOrUnion(node: ParseNode, t: CType): CStruct | CUnion {\n    checkTypeComplete(t);\n    if (t instanceof CStruct) return t;\n    if (t instanceof CUnion) return t;\n    throw new ExpressionTypeError(node, \"struct or union\", t.typeName);\n}\n\nexport function checkLvalue(expression: CExpression, lvalue: boolean): CExpression {\n    if (expression.lvalue === lvalue) return expression;\n    throw new ExpressionTypeError(expression.node, `lvalue=${lvalue}`, `lvalue=${expression.lvalue}`);\n}\n","import {CError} from \"../c_error\";\nimport type {TypeSpecifier, TypeQualifier, ParseNode} from \"../parsing/parsetree\";\n\n// types for expressions and declarations in the IR\nexport type CType = CNotFuncType | CFuncType;\nexport type CNotFuncType = CArithmetic | CPointer | CArray | CStruct | CUnion | CVoid;\nexport type CQualifiedType<T extends CType> = T & {qualifier?: TypeQualifier};\n\nexport class CFuncType {\n    readonly typeName = \"function\";\n    readonly bytes = 0;\n    readonly alignment = 1;\n    readonly incomplete = false;\n\n    constructor(readonly node: ParseNode | undefined,\n                readonly returnType: CQualifiedType<CNotFuncType>,\n                readonly parameterTypes: CQualifiedType<CNotFuncType>[],\n                public parameterNames?: string[],\n                readonly variadic: boolean = false) {\n        // return type and parameter types must be complete\n        if (!(returnType instanceof CVoid)) checkTypeComplete(returnType);\n        parameterTypes.forEach(x => checkTypeComplete(x));\n    }\n\n    equals(t: Object): boolean {\n        return t instanceof CFuncType\n            && t.returnType.equals(this.returnType)\n            && t.parameterTypes.length === this.parameterTypes.length\n            && t.parameterTypes.every((other, i) => this.parameterTypes[i].equals(other))\n            && t.variadic === this.variadic;\n    }\n}\n\nexport class CPointer {\n    readonly typeName = \"pointer\";\n    readonly bytes = 4;\n    readonly alignment = 4;\n    readonly incomplete = false;\n    readonly qualifier?: TypeQualifier;\n\n    constructor(readonly node: ParseNode | undefined, readonly type: CType, constant: boolean = false) {\n        // allow pointers to incomplete types\n        if (constant) this.qualifier = \"const\";\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CPointer && t.qualifier === this.qualifier && this.type.equals(t.type);\n    }\n}\n\nexport class CArray {\n    readonly typeName = \"array\";\n    readonly alignment: number;\n\n    constructor(readonly node: ParseNode | undefined, readonly type: CType, public length?: number) {\n        checkTypeComplete(type);\n        this.alignment = type.alignment;\n    }\n\n    get bytes(): number {\n        if (this.length === undefined) throw new Error(\"Tried to get size of incomplete type\");\n        return this.type.bytes * this.length;\n    }\n\n    get incomplete(): boolean {\n        return this.length === undefined;\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CArray && t.length === this.length && this.type.equals(t.type);\n    }\n}\n\nexport type CCompound = CStruct | CUnion | CEnum;\n\nexport class CCompoundMember {\n    constructor(readonly node: ParseNode, readonly name: string, readonly type: CQualifiedType<CNotFuncType>) {}\n}\n\nexport class CStruct {\n    readonly typeName = \"struct\";\n    private _members: ReadonlyArray<CCompoundMember> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get members(): ReadonlyArray<CCompoundMember> {\n        if (this._members === undefined) throw new Error(\"Can't get members of an incomplete struct\");\n        return this._members;\n    }\n\n    set members(children: ReadonlyArray<CCompoundMember>) {\n        if (this._members !== undefined) throw new Error(\"Can't redefine a struct's members\");\n        if (children.length === 0) throw new Error(\"Struct must have one or more member\");\n        this._members = children;\n    }\n\n    get bytes(): number {\n        if (this.incomplete) throw new Error(\"Tried to get size of incomplete type\");\n        return this.members.reduce((total, x) => {\n            // align member type\n            total = Math.ceil(total / x.type.alignment) * x.type.alignment;\n            return total + x.type.bytes;\n        }, 0);\n    }\n\n    get alignment(): number {\n        return Math.max(...this.members.map(x => x.type.alignment));\n    }\n\n    get incomplete(): boolean {\n        return this._members === undefined;\n    }\n\n    equals(t: object): boolean {\n        /** \"Structures, unions and enumerations with different tags are distinct,\n         * and a tagless union, structure, or enumeration specifies a unique type\" */\n        if (this.name === undefined) return this === t;\n        return t instanceof CStruct && t.name === this.name;\n    }\n\n    memberType(m: string): CType {\n        const member = this.members.find(x => x.name === m);\n        if (member) return member.type;\n        throw new Error(`Struct does not contain member \"${m}\"`);\n    }\n\n    hasConstMember(): boolean { // if the struct contains one or more const members\n        return this.members.find(m =>\n            getQualifier(m.type) || ((m.type instanceof CUnion || m.type instanceof CStruct) && m.type.hasConstMember())\n        ) !== undefined;\n    }\n}\n\nexport class CUnion {\n    readonly typeName = \"union\";\n    private _members: ReadonlyArray<CCompoundMember> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get members(): ReadonlyArray<CCompoundMember> {\n        if (this._members === undefined) throw new Error(\"Can't get members of an incomplete union\");\n        return this._members;\n    }\n\n    set members(children: ReadonlyArray<CCompoundMember>) {\n        if (this._members !== undefined) throw new Error(\"Can't redefine a union's members\");\n        if (children.length === 0) throw new Error(\"Struct must have one or more member\");\n        this._members = children;\n    }\n\n    get bytes(): number {\n        if (this.incomplete) throw new Error(\"Tried to get size of incomplete type\");\n        return this.members.reduce((total, x) => Math.max(total, x.type.bytes), 0);\n    }\n\n    get alignment(): number {\n        return Math.max(...this.members.map(x => x.type.alignment));\n    }\n\n    get incomplete(): boolean {\n        return this._members === undefined;\n    }\n\n    equals(t: object): boolean {\n        if (this.name === undefined) return this === t;\n        return t instanceof CUnion && t.name === this.name;\n    }\n\n    memberType(m: string): CType {\n        const member = this.members.find(x => x.name === m);\n        if (member) return member.type;\n        throw new Error(`Union does not contain member \"${m}\"`);\n    }\n\n    hasConstMember(): boolean { // if the union has one or more const members\n        return this.members.find(m =>\n            getQualifier(m.type) || ((m.type instanceof CUnion || m.type instanceof CStruct) && m.type.hasConstMember())\n        ) !== undefined;\n    }\n}\n\nexport type CEnumValue = {name: string, value: bigint};\nexport class CEnum {\n    readonly typeName = \"enum\";\n    private _values: ReadonlyArray<CEnumValue> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get values(): ReadonlyArray<CEnumValue> {\n        if (this._values === undefined) throw new Error(\"Can't get values of an incomplete enum\");\n        return this._values;\n    }\n\n    set values(children: ReadonlyArray<CEnumValue>) {\n        if (this._values !== undefined) throw new Error(\"Can't redefine an enum's values\");\n        if (children.length === 0) throw new Error(\"Enum must have one or more value\");\n        this._values = children;\n    }\n\n    get incomplete(): boolean {\n        return this._values === undefined;\n    }\n\n    equals(t: object): boolean {\n        if (this.name === undefined) return this === t;\n        return t instanceof CEnum && t.name === this.name;\n    }\n}\n\nexport class CVoid {\n    readonly typeName = \"void\";\n    readonly bytes = 0;\n    readonly alignment = 1;\n    readonly incomplete = true;\n    readonly node = undefined;\n\n    equals(t: object): boolean {\n        return t instanceof CVoid;\n    }\n}\n\nexport class CArithmetic {\n    readonly typeName = \"arithmetic\";\n    readonly incomplete = false;\n    readonly node = undefined;\n    readonly alignment: number;\n\n    private constructor(readonly name: string, readonly bytes: number, readonly type: \"float\" | \"signed\" | \"unsigned\") {\n        this.alignment = bytes;\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CArithmetic && t.name === this.name && t.type === this.type && t.bytes === this.bytes;\n    }\n\n    get minValue(): bigint | number {\n        if (CArithmetic.BOOL.equals(this)) return 0;\n\n        switch (this.type) {\n        case \"float\":\n            return -Infinity;\n        case \"unsigned\":\n            return 0;\n        case \"signed\":\n            return -(2n ** (BigInt(this.bytes * 8) - 1n));\n        }\n    }\n\n    get maxValue(): bigint | number {\n        if (CArithmetic.BOOL.equals(this)) return 1;\n\n        switch (this.type) {\n        case \"float\":\n            return Infinity;\n        case \"unsigned\":\n            return 2n ** BigInt(this.bytes * 8) - 1n;\n        case \"signed\":\n            return 2n ** (BigInt(this.bytes * 8) - 1n) - 1n;\n        }\n    }\n\n    static readonly Fp32 = new CArithmetic(\"float\", 4, \"float\");\n    static readonly Fp64 = new CArithmetic(\"double\", 8, \"float\");\n\n    static readonly U8 = new CArithmetic(\"char\", 1, \"unsigned\");\n    static readonly S8 = new CArithmetic(\"signed char\", 1, \"signed\");\n    static readonly U16 = new CArithmetic(\"unsigned short\", 2, \"unsigned\");\n    static readonly S16 = new CArithmetic(\"short\", 2, \"signed\");\n    static readonly U32 = new CArithmetic(\"unsigned int\", 4, \"unsigned\");\n    static readonly S32 = new CArithmetic(\"int\", 4, \"signed\");\n    static readonly U64 = new CArithmetic(\"unsigned long\", 8, \"unsigned\");\n    static readonly S64 = new CArithmetic(\"long\", 8, \"signed\");\n\n    static readonly BOOL = new CArithmetic(\"bool\", 4, \"signed\");\n}\n\nexport const CSizeT = CArithmetic.U32;\n\n\nconst constType = Symbol(\"const\"); // hidden property key\n\n/**\n * Add a qualifier to a type.\n *\n * This creates a new object with the qualifier attached, using the existing type as its prototype, allowing it to be\n * treated as the existing type. This new object is also cached on the existing type using a field referenced by a\n * symbol, so it can't be accessed when enumerating the fields and doesn't affect existing code.\n */\nexport function addQualifier<T extends CType>(t: T, qualifier?: TypeQualifier): CQualifiedType<T> {\n    if (qualifier === undefined) return t;\n    if (Object.prototype.hasOwnProperty.call(t, \"qualifier\")) {\n        throw new Error(\"Type already has a qualifier\");\n    }\n\n    const baseType = t as Record<typeof constType, any>;\n    if (baseType[constType]) {\n        // const type already exists\n        return baseType[constType];\n    }\n\n    const type = Object.setPrototypeOf({qualifier, _base: t}, t);\n    baseType[constType] = type;\n    return type;\n}\n\nexport function getQualifier(t: CQualifiedType<CType>): TypeQualifier | undefined {\n    return t?.qualifier;\n}\n\n/** integer promotion from the C standard */\nexport function integerPromotion(t: CArithmetic): CArithmetic {\n    if (t.type === \"float\") return t;\n    if (t.bytes < CArithmetic.S32.bytes || t === CArithmetic.BOOL) return CArithmetic.S32;\n    return t;\n}\n\n/** \"The usual arithmetic conversions\" from the C standard */\nexport function usualArithmeticConversion(t1: CArithmetic, t2: CArithmetic): CArithmetic {\n    if (t1 === CArithmetic.Fp64 || t2 === CArithmetic.Fp64) return CArithmetic.Fp64;\n    if (t1 === CArithmetic.Fp32 || t2 === CArithmetic.Fp32) return CArithmetic.Fp32;\n\n    // integer promotion\n    t1 = integerPromotion(t1);\n    t2 = integerPromotion(t2);\n\n    if (t1 === CArithmetic.U64 || t2 === CArithmetic.U64) return CArithmetic.U64;\n    if (t1 === CArithmetic.S64 || t2 === CArithmetic.S64) return CArithmetic.S64;\n    if (t1 === CArithmetic.U32 || t2 === CArithmetic.U32) return CArithmetic.U32;\n    return CArithmetic.S32;\n}\n\n/** Convert a list of specifier strings (e.g. \"signed\", \"int\") into a CType instance. */\nexport function getArithmeticType(specifierList: ReadonlyArray<TypeSpecifier & string>): CArithmetic | CVoid | undefined {\n    const copy = specifierList.slice();\n\n    function remove(s: TypeSpecifier & string) { // remove an item from a list if present, and return whether it was\n        const idx = copy.indexOf(s);\n        if (idx > -1) {\n            copy.splice(idx, 1);\n            return true;\n        }\n        return false;\n    }\n\n    function check<T>(x: T): T | undefined { // check that there are no specifiers left to be processed\n        if (copy.length > 0) return undefined; // extra specifiers so this type is invalid (e.g. \"unsigned signed int\")\n        return x;\n    }\n\n    if (remove(\"void\")) { // if \"void\" in list\n        return check(new CVoid()); // then the type must be void, check no extra specifiers were provided\n    } else if (remove(\"double\")) {\n        remove(\"long\"); // remove \"long\" if present, as treating \"long double\" as normal doubles\n        return check(CArithmetic.Fp64);\n    } else if (remove(\"float\")) {\n        return check(CArithmetic.Fp32);\n    } else if (remove(\"char\")) {\n        if (remove(\"signed\")) return check(CArithmetic.S8);\n        remove(\"unsigned\");\n        return check(CArithmetic.U8);\n    } else if (remove(\"short\")) {\n        remove(\"int\"); // remove optional \"int\" (\"short int\" === \"int\")\n        if (remove(\"unsigned\")) return check(CArithmetic.U16);\n        remove(\"signed\");\n        return check(CArithmetic.S16);\n    } else if (remove(\"long\")) {\n        remove(\"long\"); // remove an 2nd \"long\" if present, as treating \"long long\" as \"long\"\n        remove(\"int\");\n        if (remove(\"unsigned\")) return check(CArithmetic.U64);\n        remove(\"signed\");\n        return check(CArithmetic.S64);\n    } else if (remove(\"int\")) {\n        if (remove(\"unsigned\")) return check(CArithmetic.U32);\n        remove(\"signed\");\n        return check(CArithmetic.S32);\n    } else if (remove(\"unsigned\")) { // support just `unsigned` and `signed`\n        return check(CArithmetic.U32);\n    } else if (remove(\"signed\")) {\n        return check(CArithmetic.S32);\n    } else if (remove(\"bool\")) {\n        return check(CArithmetic.BOOL);\n    }\n    return undefined;\n}\n\n/** Assert that type is complete */\nexport function checkTypeComplete<T extends CType>(type: T, node: ParseNode | undefined = type.node): T {\n    if (type.incomplete) {\n        throw new class extends CError {\n            name = \"IncompleteTypeError\";\n        }(\"Invalid use of an incomplete type\", node);\n    }\n    return type;\n}\n","\n/* parser generated by jison 0.6.1-215 */\n\n/*\n * Returns a Parser object of the following structure:\n *\n *  Parser: {\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n *               the real \"shared state\" `yy` passed around to\n *               the rule actions, etc. is a derivative/copy of this one,\n *               not a direct reference!\n *  }\n *\n *  Parser.prototype: {\n *    yy: {},\n *    EOF: 1,\n *    TERROR: 2,\n *\n *    trace: function(errorMessage, ...),\n *\n *    JisonParserError: function(msg, hash),\n *\n *    quoteName: function(name),\n *               Helper function which can be overridden by user code later on: put suitable\n *               quotes around literal IDs in a description string.\n *\n *    originalQuoteName: function(name),\n *               The basic quoteName handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function\n *               at the end of the `parse()`.\n *\n *    describeSymbol: function(symbol),\n *               Return a more-or-less human-readable description of the given symbol, when\n *               available, or the symbol itself, serving as its own 'description' for lack\n *               of something better to serve up.\n *\n *               Return NULL when the symbol is unknown to the parser.\n *\n *    symbols_: {associative list: name ==> number},\n *    terminals_: {associative list: number ==> name},\n *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},\n *    terminal_descriptions_: (if there are any) {associative list: number ==> description},\n *    productions_: [...],\n *\n *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)\n *                             to store/reference the rule value `$$` and location info `@$`.\n *\n *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets\n *                 to see the same object via the `this` reference, i.e. if you wish to carry custom\n *                 data from one reduce action through to the next within a single parse run, then you\n *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.\n *\n *                 `this.yy` is a direct reference to the `yy` shared state object.\n *\n *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`\n *                 object at `parse()` start and are therefore available to the action code via the\n *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from\n *                 the %parse-param` list.\n *\n *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used\n *                             to match this rule. This is *not* the look-ahead token, but the last token\n *                             that's actually part of this rule.\n *\n *                 Formulated another way, `yytext` is the value of the token immediately preceeding\n *                 the current look-ahead token.\n *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.\n *\n *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.\n *\n *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.\n *\n *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.\n *\n *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead\n *                               of an empty object when no suitable location info can be provided.\n *\n *               - `yystate` : the current parser state number, used internally for dispatching and\n *                               executing the action code chunk matching the rule currently being reduced.\n *\n *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *                 Also note that you can access this and other stack index values using the new double-hash\n *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things\n *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.\n *                 This is made available to write very advanced grammar action rules, e.g. when you want\n *                 to investigate the parse state stack in your action code, which would, for example,\n *                 be relevant when you wish to implement error diagnostics and reporting schemes similar\n *                 to the work described here:\n *\n *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.\n *                   In Journes Francophones des Languages Applicatifs.\n *\n *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.\n *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631640.\n *\n *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.\n *                             constructs.\n *\n *               - `yylstack`: reference to the parser token location stack. Also accessed via\n *                             the `@1` etc. constructs.\n *\n *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are\n *                             UNDEFINED rather than an empty (location) object, when the lexer/parser\n *                             action code did not provide a suitable location info object when such a\n *                             slot was filled!\n *\n *               - `yystack` : reference to the parser token id stack. Also accessed via the\n *                             `#1` etc. constructs.\n *\n *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to\n *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might\n *                 want access this array for your own purposes, such as error analysis as mentioned above!\n *\n *                 Note that this stack stores the current stack of *tokens*, that is the sequence of\n *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*\n *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and\n *                 *reduced*.\n *\n *               - `yysstack`: reference to the parser state stack. This one carries the internal parser\n *                             *states* such as the one in `yystate`, which are used to represent\n *                             the parser state machine in the *parse table*. *Very* *internal* stuff,\n *                             what can I say? If you access this one, you're clearly doing wicked things\n *\n *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your\n *                             grammar definition file.\n *\n *    table: [...],\n *               State transition table\n *               ----------------------\n *\n *               index levels are:\n *               - `state`  --> hash table\n *               - `symbol` --> action (number or array)\n *\n *                 If the `action` is an array, these are the elements' meaning:\n *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept\n *                 - index [1]: GOTO `state`\n *\n *                 If the `action` is a number, it is the GOTO `state`\n *\n *    defaultActions: {...},\n *\n *    parseError: function(str, hash, ExceptionClass),\n *    yyError: function(str, ...),\n *    yyRecovering: function(),\n *    yyErrOk: function(),\n *    yyClearIn: function(),\n *\n *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n *               See it's use in this parser kernel in many places; example usage:\n *\n *                   var infoObj = parser.constructParseErrorInfo('fail!', null,\n *                                     parser.collect_expected_token_set(state), true);\n *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);\n *\n *    originalParseError: function(str, hash, ExceptionClass),\n *               The basic `parseError` handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function\n *               at the end of the `parse()`.\n *\n *    options: { ... parser %options ... },\n *\n *    parse: function(input[, args...]),\n *               Parse the given `input` and return the parsed value (or `true` when none was provided by\n *               the root action, in which case the parser is acting as a *matcher*).\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the jison run-time;\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\n *               from silently accepting this confusing and potentially hazardous situation!\n *\n *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in\n *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state\n *               object and any collision with those will be reported by the lexer via a thrown exception.\n *\n *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown\n *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY\n *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and\n *               the internal parser gets properly garbage collected under these particular circumstances.\n *\n *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API can be invoked to calculate a spanning `yylloc` location info object.\n *\n *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case\n *               this function will attempt to obtain a suitable location marker by inspecting the location stack\n *               backwards.\n *\n *               For more info see the documentation comment further below, immediately above this function's\n *               implementation.\n *\n *    lexer: {\n *        yy: {...},           A reference to the so-called \"shared state\" `yy` once\n *                             received via a call to the `.setInput(input, yy)` lexer API.\n *        EOF: 1,\n *        ERROR: 2,\n *        JisonLexerError: function(msg, hash),\n *        parseError: function(str, hash, ExceptionClass),\n *        setInput: function(input, [yy]),\n *        input: function(),\n *        unput: function(str),\n *        more: function(),\n *        reject: function(),\n *        less: function(n),\n *        pastInput: function(n),\n *        upcomingInput: function(n),\n *        showPosition: function(),\n *        test_match: function(regex_match_array, rule_index, ...),\n *        next: function(...),\n *        lex: function(...),\n *        begin: function(condition),\n *        pushState: function(condition),\n *        popState: function(),\n *        topState: function(),\n *        _currentRules: function(),\n *        stateStackSize: function(),\n *        cleanupAfterLex: function()\n *\n *        options: { ... lexer %options ... },\n *\n *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),\n *        rules: [...],\n *        conditions: {associative list: name ==> set},\n *    }\n *  }\n *\n *\n *  token location info (@$, _$, etc.): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a 'hash' object with these members for lexer and\n * parser errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *  }\n *\n * parser (grammar) errors will also provide these additional members:\n *\n *  {\n *    expected:    (array describing the set of expected tokens;\n *                  may be UNDEFINED when we cannot easily produce such a set)\n *    state:       (integer (or array when the table includes grammar collisions);\n *                  represents the current internal state of the parser kernel.\n *                  can, for example, be used to pass to the `collect_expected_token_set()`\n *                  API to obtain the expected token set)\n *    action:      (integer; represents the current internal action which will be executed)\n *    new_state:   (integer; represents the next/planned internal state, once the current\n *                  action has executed)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    yy:          (object: the current parser internal \"shared state\" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *    parser:      (reference to the current parser instance)\n *  }\n *\n * while `this` will reference the current parser instance.\n *\n * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    lexer:       (reference to the current lexer instance which reported the error)\n *  }\n *\n * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired\n * from either the parser or lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    exception:   (reference to the exception thrown)\n *  }\n *\n * Please do note that in the latter situation, the `expected` field will be omitted as\n * this type of failure is assumed not to be due to *parse errors* but rather due to user\n * action code in either parser or lexer failing unexpectedly.\n *\n * ---\n *\n * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.\n * These options are available:\n *\n * ### options which are global for all parser instances\n *\n *  Parser.pre_parse: function(yy)\n *                 optional: you can specify a pre_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`.\n *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: you can specify a post_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`. When it does not return any value,\n *                 the parser will return the original `retval`.\n *\n * ### options which can be set up per parser instance\n *\n *  yy: {\n *      pre_parse:  function(yy)\n *                 optional: is invoked before the parse cycle starts (and before the first\n *                 invocation of `lex()`) but immediately after the invocation of\n *                 `parser.pre_parse()`).\n *      post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: is invoked when the parse terminates due to success ('accept')\n *                 or failure (even when exceptions are thrown).\n *                 `retval` contains the return value to be produced by `Parser.parse()`;\n *                 this function can override the return value by returning another.\n *                 When it does not return any value, the parser will return the original\n *                 `retval`.\n *                 This function is invoked immediately before `parser.post_parse()`.\n *\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *      quoteName: function(name),\n *                 optional: overrides the default `quoteName` function.\n *  }\n *\n *  parser.lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */\n\n        \n    \n            var c_grammar = (function () {\n\n\n// See also:\n// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n// with userland code which might access the derived class in a 'classic' way.\nfunction JisonParserError(msg, hash) {\n    Object.defineProperty(this, 'name', {\n        enumerable: false,\n        writable: false,\n        value: 'JisonParserError'\n    });\n\n    if (msg == null) msg = '???';\n\n    Object.defineProperty(this, 'message', {\n        enumerable: false,\n        writable: true,\n        value: msg\n    });\n\n    this.hash = hash;\n\n    var stacktrace;\n    if (hash && hash.exception instanceof Error) {\n        var ex2 = hash.exception;\n        this.message = ex2.message || msg;\n        stacktrace = ex2.stack;\n    }\n    if (!stacktrace) {\n        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            stacktrace = (new Error(msg)).stack;\n        }\n    }\n    if (stacktrace) {\n        Object.defineProperty(this, 'stack', {\n            enumerable: false,\n            writable: false,\n            value: stacktrace\n        });\n    }\n}\n\nif (typeof Object.setPrototypeOf === 'function') {\n    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);\n} else {\n    JisonParserError.prototype = Object.create(Error.prototype);\n}\nJisonParserError.prototype.constructor = JisonParserError;\nJisonParserError.prototype.name = 'JisonParserError';\n\n\n\n\n        // helper: reconstruct the productions[] table\n        function bp(s) {\n            var rv = [];\n            var p = s.pop;\n            var r = s.rule;\n            for (var i = 0, l = p.length; i < l; i++) {\n                rv.push([\n                    p[i],\n                    r[i]\n                ]);\n            }\n            return rv;\n        }\n    \n\n\n        // helper: reconstruct the defaultActions[] table\n        function bda(s) {\n            var rv = {};\n            var d = s.idx;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var j = d[i];\n                rv[j] = g[i];\n            }\n            return rv;\n        }\n    \n\n\n        // helper: reconstruct the 'goto' table\n        function bt(s) {\n            var rv = [];\n            var d = s.len;\n            var y = s.symbol;\n            var t = s.type;\n            var a = s.state;\n            var m = s.mode;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var n = d[i];\n                var q = {};\n                for (var j = 0; j < n; j++) {\n                    var z = y.shift();\n                    switch (t.shift()) {\n                    case 2:\n                        q[z] = [\n                            m.shift(),\n                            g.shift()\n                        ];\n                        break;\n\n                    case 0:\n                        q[z] = a.shift();\n                        break;\n\n                    default:\n                        // type === 1: accept\n                        q[z] = [\n                            3\n                        ];\n                    }\n                }\n                rv.push(q);\n            }\n            return rv;\n        }\n    \n\n\n        // helper: runlength encoding with increment step: code, length: step (default step = 0)\n        // `this` references an array\n        function s(c, l, a) {\n            a = a || 0;\n            for (var i = 0; i < l; i++) {\n                this.push(c);\n                c += a;\n            }\n        }\n\n        // helper: duplicate sequence from *relative* offset and length.\n        // `this` references an array\n        function c(i, l) {\n            i = this.length - i;\n            for (l += i; i < l; i++) {\n                this.push(this[i]);\n            }\n        }\n\n        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.\n        function u(a) {\n            var rv = [];\n            for (var i = 0, l = a.length; i < l; i++) {\n                var e = a[i];\n                // Is this entry a helper function?\n                if (typeof e === 'function') {\n                    i++;\n                    e.apply(rv, a[i]);\n                } else {\n                    rv.push(e);\n                }\n            }\n            return rv;\n        }\n    \n\nvar parser = {\n    // Code Generator Information Report\n    // ---------------------------------\n    //\n    // Options:\n    //\n    //   default action mode: ............. [\"none\",\"merge\"]\n    //   test-compile action mode: ........ \"parser:*,lexer:*\"\n    //   try..catch: ...................... true\n    //   default resolve on conflict: ..... true\n    //   on-demand look-ahead: ............ false\n    //   error recovery token skip maximum: 3\n    //   yyerror in parse actions is: ..... NOT recoverable,\n    //   yyerror in lexer actions and other non-fatal lexer are:\n    //   .................................. NOT recoverable,\n    //   debug grammar/output: ............ false\n    //   has partial LR conflict upgrade:   true\n    //   rudimentary token-stack support:   false\n    //   parser table compression mode: ... 2\n    //   export debug tables: ............. false\n    //   export *all* tables: ............. false\n    //   module type: ..................... commonjs\n    //   parser engine type: .............. lalr\n    //   output main() in the module: ..... true\n    //   has user-specified main(): ....... false\n    //   has user-specified require()/import modules for main():\n    //   .................................. false\n    //   number of expected conflicts: .... 0\n    //\n    //\n    // Parser Analysis flags:\n    //\n    //   no significant actions (parser is a language matcher only):\n    //   .................................. false\n    //   uses yyleng: ..................... false\n    //   uses yylineno: ................... false\n    //   uses yytext: ..................... true\n    //   uses yylloc: ..................... false\n    //   uses ParseError API: ............. false\n    //   uses YYERROR: .................... false\n    //   uses YYRECOVERING: ............... false\n    //   uses YYERROK: .................... false\n    //   uses YYCLEARIN: .................. false\n    //   tracks rule values: .............. true\n    //   assigns rule values: ............. true\n    //   uses location tracking: .......... true\n    //   assigns location: ................ true\n    //   uses yystack: .................... false\n    //   uses yysstack: ................... false\n    //   uses yysp: ....................... true\n    //   uses yyrulelength: ............... false\n    //   uses yyMergeLocationInfo API: .... true\n    //   has error recovery: .............. false\n    //   has error reporting: ............. false\n    //\n    // --------- END OF REPORT -----------\n\ntrace: function no_op_trace() { },\nJisonParserError: JisonParserError,\nyy: {},\noptions: {\n  type: \"lalr\",\n  hasPartialLrUpgradeOnConflict: true,\n  errorRecoveryTokenDiscardCount: 3\n},\nsymbols_: {\n  \"!\": 14,\n  \"$accept\": 0,\n  \"$end\": 1,\n  \"%\": 16,\n  \"&\": 9,\n  \"(\": 3,\n  \")\": 4,\n  \"*\": 10,\n  \"+\": 11,\n  \",\": 8,\n  \"-\": 12,\n  \".\": 7,\n  \"/\": 15,\n  \":\": 22,\n  \";\": 24,\n  \"<\": 17,\n  \"=\": 23,\n  \">\": 18,\n  \"?\": 21,\n  \"ADD_ASSIGN\": 49,\n  \"AND_ASSIGN\": 53,\n  \"AND_OP\": 44,\n  \"BREAK\": 87,\n  \"CASE\": 77,\n  \"CHAR\": 60,\n  \"CONST\": 73,\n  \"CONSTANT_CHAR\": 32,\n  \"CONSTANT_FLOAT\": 28,\n  \"CONSTANT_HEX\": 29,\n  \"CONSTANT_INT\": 31,\n  \"CONSTANT_OCTAL\": 30,\n  \"CONTINUE\": 86,\n  \"DEC_OP\": 36,\n  \"DEFAULT\": 78,\n  \"DIV_ASSIGN\": 47,\n  \"DO\": 83,\n  \"DOUBLE\": 65,\n  \"ELLIPSIS\": 76,\n  \"ELSE\": 80,\n  \"ENUM\": 72,\n  \"EOF\": 1,\n  \"EQ_OP\": 42,\n  \"EXTERN\": 57,\n  \"FLOAT\": 64,\n  \"FOR\": 84,\n  \"GE_OP\": 41,\n  \"GOTO\": 85,\n  \"IDENTIFIER\": 27,\n  \"IF\": 79,\n  \"IMPORT\": 75,\n  \"INC_OP\": 35,\n  \"INLINE\": 74,\n  \"INT\": 62,\n  \"LEFT_ASSIGN\": 51,\n  \"LEFT_OP\": 38,\n  \"LE_OP\": 40,\n  \"LONG\": 63,\n  \"MOD_ASSIGN\": 48,\n  \"MUL_ASSIGN\": 46,\n  \"NE_OP\": 43,\n  \"OR_ASSIGN\": 55,\n  \"OR_OP\": 45,\n  \"PTR_OP\": 34,\n  \"RETURN\": 88,\n  \"RIGHT_ASSIGN\": 52,\n  \"RIGHT_OP\": 39,\n  \"SHORT\": 61,\n  \"SIGNED\": 66,\n  \"SIZEOF\": 37,\n  \"STATIC\": 58,\n  \"STRING_LITERAL\": 33,\n  \"STRUCT\": 70,\n  \"SUB_ASSIGN\": 50,\n  \"SWITCH\": 81,\n  \"TYPEDEF\": 56,\n  \"TYPE_NAME\": 69,\n  \"UNION\": 71,\n  \"UNSIGNED\": 67,\n  \"VOID\": 59,\n  \"WHILE\": 82,\n  \"XOR_ASSIGN\": 54,\n  \"[\": 5,\n  \"]\": 6,\n  \"^\": 19,\n  \"_BOOL\": 68,\n  \"abstract_declarator\": 141,\n  \"additive_expression\": 101,\n  \"and_expression\": 105,\n  \"argument_expression_list\": 96,\n  \"assignment_expression\": 111,\n  \"assignment_operator\": 112,\n  \"ast_tree\": 89,\n  \"block_item\": 149,\n  \"block_item_list\": 148,\n  \"cast_expression\": 99,\n  \"compound_statement\": 147,\n  \"concat_string_literals\": 93,\n  \"conditional_expression\": 110,\n  \"constant\": 91,\n  \"constant_expression\": 114,\n  \"declaration\": 115,\n  \"declaration_specifiers\": 116,\n  \"declarator\": 133,\n  \"direct_abstract_declarator\": 142,\n  \"direct_declarator\": 134,\n  \"enum_specifier\": 128,\n  \"enumerator\": 130,\n  \"enumerator_list\": 129,\n  \"equality_expression\": 104,\n  \"error\": 2,\n  \"exclusive_or_expression\": 106,\n  \"expression\": 113,\n  \"expression_statement\": 150,\n  \"external_declaration\": 155,\n  \"function_definition\": 156,\n  \"function_specifier\": 132,\n  \"identifier\": 90,\n  \"inclusive_or_expression\": 107,\n  \"init_declarator\": 118,\n  \"init_declarator_list\": 117,\n  \"initializer\": 143,\n  \"initializer_list\": 144,\n  \"iteration_statement\": 152,\n  \"jump_statement\": 153,\n  \"labeled_statement\": 146,\n  \"logical_and_expression\": 108,\n  \"logical_or_expression\": 109,\n  \"multiplicative_expression\": 100,\n  \"parameter_declaration\": 139,\n  \"parameter_list\": 138,\n  \"parameter_type_list\": 137,\n  \"pointer\": 135,\n  \"postfix_expression\": 95,\n  \"primary_expression\": 94,\n  \"relational_expression\": 103,\n  \"selection_statement\": 151,\n  \"shift_expression\": 102,\n  \"specifier_qualifier_list\": 125,\n  \"statement\": 145,\n  \"storage_class_specifier\": 119,\n  \"string_literal\": 92,\n  \"struct_declaration\": 124,\n  \"struct_declaration_list\": 123,\n  \"struct_declarator\": 127,\n  \"struct_declarator_list\": 126,\n  \"struct_or_union\": 122,\n  \"struct_or_union_specifier\": 121,\n  \"translation_unit\": 154,\n  \"type_name\": 140,\n  \"type_qualifier\": 131,\n  \"type_qualifier_list\": 136,\n  \"type_specifier\": 120,\n  \"unary_expression\": 97,\n  \"unary_operator\": 98,\n  \"{\": 25,\n  \"|\": 20,\n  \"}\": 26,\n  \"~\": 13\n},\nterminals_: {\n  1: \"EOF\",\n  2: \"error\",\n  3: \"(\",\n  4: \")\",\n  5: \"[\",\n  6: \"]\",\n  7: \".\",\n  8: \",\",\n  9: \"&\",\n  10: \"*\",\n  11: \"+\",\n  12: \"-\",\n  13: \"~\",\n  14: \"!\",\n  15: \"/\",\n  16: \"%\",\n  17: \"<\",\n  18: \">\",\n  19: \"^\",\n  20: \"|\",\n  21: \"?\",\n  22: \":\",\n  23: \"=\",\n  24: \";\",\n  25: \"{\",\n  26: \"}\",\n  27: \"IDENTIFIER\",\n  28: \"CONSTANT_FLOAT\",\n  29: \"CONSTANT_HEX\",\n  30: \"CONSTANT_OCTAL\",\n  31: \"CONSTANT_INT\",\n  32: \"CONSTANT_CHAR\",\n  33: \"STRING_LITERAL\",\n  34: \"PTR_OP\",\n  35: \"INC_OP\",\n  36: \"DEC_OP\",\n  37: \"SIZEOF\",\n  38: \"LEFT_OP\",\n  39: \"RIGHT_OP\",\n  40: \"LE_OP\",\n  41: \"GE_OP\",\n  42: \"EQ_OP\",\n  43: \"NE_OP\",\n  44: \"AND_OP\",\n  45: \"OR_OP\",\n  46: \"MUL_ASSIGN\",\n  47: \"DIV_ASSIGN\",\n  48: \"MOD_ASSIGN\",\n  49: \"ADD_ASSIGN\",\n  50: \"SUB_ASSIGN\",\n  51: \"LEFT_ASSIGN\",\n  52: \"RIGHT_ASSIGN\",\n  53: \"AND_ASSIGN\",\n  54: \"XOR_ASSIGN\",\n  55: \"OR_ASSIGN\",\n  56: \"TYPEDEF\",\n  57: \"EXTERN\",\n  58: \"STATIC\",\n  59: \"VOID\",\n  60: \"CHAR\",\n  61: \"SHORT\",\n  62: \"INT\",\n  63: \"LONG\",\n  64: \"FLOAT\",\n  65: \"DOUBLE\",\n  66: \"SIGNED\",\n  67: \"UNSIGNED\",\n  68: \"_BOOL\",\n  69: \"TYPE_NAME\",\n  70: \"STRUCT\",\n  71: \"UNION\",\n  72: \"ENUM\",\n  73: \"CONST\",\n  74: \"INLINE\",\n  75: \"IMPORT\",\n  76: \"ELLIPSIS\",\n  77: \"CASE\",\n  78: \"DEFAULT\",\n  79: \"IF\",\n  80: \"ELSE\",\n  81: \"SWITCH\",\n  82: \"WHILE\",\n  83: \"DO\",\n  84: \"FOR\",\n  85: \"GOTO\",\n  86: \"CONTINUE\",\n  87: \"BREAK\",\n  88: \"RETURN\"\n},\nTERROR: 2,\n    EOF: 1,\n\n    // internals: defined here so the object *structure* doesn't get modified by parse() et al,\n    // thus helping JIT compilers like Chrome V8.\n    originalQuoteName: null,\n    originalParseError: null,\n    cleanupAfterParse: null,\n    constructParseErrorInfo: null,\n    yyMergeLocationInfo: null,\n\n    __reentrant_call_depth: 0,      // INTERNAL USE ONLY\n    __error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n    __error_recovery_infos: [],     // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n\n    // APIs which will be set up depending on user action code analysis:\n    //yyRecovering: 0,\n    //yyErrOk: 0,\n    //yyClearIn: 0,\n\n    // Helper APIs\n    // -----------\n\n    // Helper function which can be overridden by user code later on: put suitable quotes around\n    // literal IDs in a description string.\n    quoteName: function parser_quoteName(id_str) {\n        return '\"' + id_str + '\"';\n    },\n\n    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    getSymbolName: function parser_getSymbolName(symbol) {\n        if (this.terminals_[symbol]) {\n            return this.terminals_[symbol];\n        }\n\n        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.\n        //\n        // An example of this may be where a rule's action code contains a call like this:\n        //\n        //      parser.getSymbolName(#$)\n        //\n        // to obtain a human-readable name of the current grammar rule.\n        var s = this.symbols_;\n        for (var key in s) {\n            if (s[key] === symbol) {\n                return key;\n            }\n        }\n        return null;\n    },\n\n    // Return a more-or-less human-readable description of the given symbol, when available,\n    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    describeSymbol: function parser_describeSymbol(symbol) {\n        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {\n            return this.terminal_descriptions_[symbol];\n        }\n        else if (symbol === this.EOF) {\n            return 'end of input';\n        }\n        var id = this.getSymbolName(symbol);\n        if (id) {\n            return this.quoteName(id);\n        }\n        return null;\n    },\n\n    // Produce a (more or less) human-readable list of expected tokens at the point of failure.\n    //\n    // The produced list may contain token or token set descriptions instead of the tokens\n    // themselves to help turning this output into something that easier to read by humans\n    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,\n    // expected terminals and nonterminals is produced.\n    //\n    // The returned list (array) will not contain any duplicate entries.\n    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {\n        var TERROR = this.TERROR;\n        var tokenset = [];\n        var check = {};\n        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?\n        // If so, use that one instead of the less palatable token set.\n        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {\n            return [\n                this.state_descriptions_[state]\n            ];\n        }\n        for (var p in this.table[state]) {\n            p = +p;\n            if (p !== TERROR) {\n                var d = do_not_describe ? p : this.describeSymbol(p);\n                if (d && !check[d]) {\n                    tokenset.push(d);\n                    check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.\n                }\n            }\n        }\n        return tokenset;\n    },\nproductions_: bp({\n  pop: u([\n  89,\n  89,\n  90,\n  s,\n  [91, 5],\n  92,\n  93,\n  93,\n  s,\n  [94, 4],\n  s,\n  [95, 8],\n  96,\n  96,\n  s,\n  [97, 6],\n  s,\n  [98, 6],\n  99,\n  99,\n  s,\n  [100, 4],\n  s,\n  [101, 3],\n  s,\n  [102, 3],\n  s,\n  [103, 5],\n  s,\n  [104, 3],\n  105,\n  105,\n  106,\n  106,\n  107,\n  107,\n  108,\n  108,\n  109,\n  109,\n  110,\n  110,\n  111,\n  111,\n  s,\n  [112, 11],\n  113,\n  113,\n  114,\n  115,\n  115,\n  s,\n  [116, 8],\n  117,\n  117,\n  118,\n  118,\n  s,\n  [119, 3],\n  s,\n  [120, 13],\n  s,\n  [121, 3],\n  122,\n  122,\n  123,\n  123,\n  124,\n  s,\n  [125, 4],\n  126,\n  126,\n  127,\n  s,\n  [128, 5],\n  129,\n  129,\n  130,\n  130,\n  131,\n  132,\n  132,\n  133,\n  133,\n  s,\n  [134, 6],\n  s,\n  [135, 4],\n  136,\n  136,\n  137,\n  137,\n  138,\n  138,\n  s,\n  [139, 3],\n  140,\n  140,\n  s,\n  [141, 3],\n  s,\n  [142, 9],\n  s,\n  [143, 3],\n  144,\n  144,\n  s,\n  [145, 6],\n  s,\n  [146, 3],\n  147,\n  147,\n  148,\n  148,\n  149,\n  149,\n  150,\n  150,\n  s,\n  [151, 3],\n  s,\n  [152, 6],\n  s,\n  [153, 5],\n  154,\n  154,\n  155,\n  155,\n  156\n]),\n  rule: u([\n  2,\n  s,\n  [1, 9],\n  c,\n  [10, 4],\n  3,\n  1,\n  4,\n  3,\n  4,\n  3,\n  3,\n  2,\n  2,\n  c,\n  [10, 3],\n  s,\n  [2, 4],\n  4,\n  s,\n  [1, 7],\n  4,\n  1,\n  s,\n  [3, 3],\n  c,\n  [4, 3],\n  c,\n  [3, 6],\n  c,\n  [8, 7],\n  c,\n  [36, 3],\n  c,\n  [4, 6],\n  5,\n  c,\n  [4, 3],\n  s,\n  [1, 11],\n  c,\n  [59, 3],\n  c,\n  [3, 3],\n  c,\n  [80, 3],\n  c,\n  [4, 4],\n  c,\n  [32, 4],\n  s,\n  [1, 15],\n  5,\n  4,\n  c,\n  [107, 4],\n  2,\n  3,\n  c,\n  [31, 4],\n  c,\n  [114, 4],\n  5,\n  5,\n  6,\n  c,\n  [40, 8],\n  c,\n  [17, 4],\n  c,\n  [130, 4],\n  c,\n  [125, 3],\n  c,\n  [67, 4],\n  c,\n  [21, 3],\n  c,\n  [139, 3],\n  c,\n  [22, 4],\n  c,\n  [46, 3],\n  3,\n  3,\n  4,\n  c,\n  [4, 4],\n  c,\n  [33, 3],\n  c,\n  [83, 8],\n  c,\n  [41, 3],\n  c,\n  [39, 5],\n  c,\n  [31, 3],\n  5,\n  7,\n  5,\n  5,\n  7,\n  6,\n  7,\n  6,\n  7,\n  c,\n  [49, 3],\n  c,\n  [20, 6],\n  3\n])\n}),\nperformAction: function parser__PerformAction(yytext, yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack) {\n\n          /* this == yyval */\n\n          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!\n          var yy = this.yy;\n          var yyparser = yy.parser;\n          var yylexer = yy.lexer;\n\n          \n\n          switch (yystate) {\ncase 0:\n    /*! Production::    $accept : ast_tree $end */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yylstack[yysp - 1];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-)\n    break;\n\ncase 1:\n    /*! Production::    ast_tree : translation_unit EOF */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,-,-,LT,LA,-,-)\n    \n    \n    return yyvstack[yysp - 1];\n    break;\n\ncase 2:\n    /*! Production::    ast_tree : EOF */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-)\n    \n    \n    return [];\n    break;\n\ncase 3:\n    /*! Production::    identifier : IDENTIFIER */\ncase 9:\n    /*! Production::    string_literal : STRING_LITERAL */\ncase 100:\n    /*! Production::    storage_class_specifier : TYPEDEF */\ncase 101:\n    /*! Production::    storage_class_specifier : EXTERN */\ncase 102:\n    /*! Production::    storage_class_specifier : STATIC */\ncase 103:\n    /*! Production::    type_specifier : VOID */\ncase 104:\n    /*! Production::    type_specifier : CHAR */\ncase 105:\n    /*! Production::    type_specifier : SHORT */\ncase 106:\n    /*! Production::    type_specifier : INT */\ncase 107:\n    /*! Production::    type_specifier : LONG */\ncase 108:\n    /*! Production::    type_specifier : FLOAT */\ncase 109:\n    /*! Production::    type_specifier : DOUBLE */\ncase 110:\n    /*! Production::    type_specifier : SIGNED */\ncase 111:\n    /*! Production::    type_specifier : UNSIGNED */\ncase 142:\n    /*! Production::    function_specifier : IMPORT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yytext);\n    break;\n\ncase 4:\n    /*! Production::    constant : CONSTANT_FLOAT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"float\"));\n    break;\n\ncase 5:\n    /*! Production::    constant : CONSTANT_HEX */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"hex\"));\n    break;\n\ncase 6:\n    /*! Production::    constant : CONSTANT_OCTAL */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"oct\"));\n    break;\n\ncase 7:\n    /*! Production::    constant : CONSTANT_INT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"int\"));\n    break;\n\ncase 8:\n    /*! Production::    constant : CONSTANT_CHAR */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"char\"));\n    break;\n\ncase 10:\n    /*! Production::    concat_string_literals : string_literal */\ncase 13:\n    /*! Production::    primary_expression : constant */\ncase 16:\n    /*! Production::    postfix_expression : primary_expression */\ncase 26:\n    /*! Production::    unary_expression : postfix_expression */\ncase 38:\n    /*! Production::    cast_expression : unary_expression */\ncase 40:\n    /*! Production::    multiplicative_expression : cast_expression */\ncase 44:\n    /*! Production::    additive_expression : multiplicative_expression */\ncase 47:\n    /*! Production::    shift_expression : additive_expression */\ncase 50:\n    /*! Production::    relational_expression : shift_expression */\ncase 55:\n    /*! Production::    equality_expression : relational_expression */\ncase 58:\n    /*! Production::    and_expression : equality_expression */\ncase 60:\n    /*! Production::    exclusive_or_expression : and_expression */\ncase 62:\n    /*! Production::    inclusive_or_expression : exclusive_or_expression */\ncase 64:\n    /*! Production::    logical_and_expression : inclusive_or_expression */\ncase 66:\n    /*! Production::    logical_or_expression : logical_and_expression */\ncase 68:\n    /*! Production::    conditional_expression : logical_or_expression */\ncase 70:\n    /*! Production::    assignment_expression : conditional_expression */\ncase 83:\n    /*! Production::    expression : assignment_expression */\ncase 98:\n    /*! Production::    init_declarator : declarator */\ncase 113:\n    /*! Production::    type_specifier : struct_or_union_specifier */\ncase 114:\n    /*! Production::    type_specifier : enum_specifier */\ncase 130:\n    /*! Production::    struct_declarator : declarator */\ncase 144:\n    /*! Production::    declarator : direct_declarator */\ncase 167:\n    /*! Production::    abstract_declarator : direct_abstract_declarator */\ncase 178:\n    /*! Production::    initializer : assignment_expression */\ncase 183:\n    /*! Production::    statement : labeled_statement */\ncase 184:\n    /*! Production::    statement : compound_statement */\ncase 185:\n    /*! Production::    statement : expression_statement */\ncase 186:\n    /*! Production::    statement : selection_statement */\ncase 187:\n    /*! Production::    statement : iteration_statement */\ncase 188:\n    /*! Production::    statement : jump_statement */\ncase 196:\n    /*! Production::    block_item : declaration */\ncase 197:\n    /*! Production::    block_item : statement */\ncase 216:\n    /*! Production::    external_declaration : function_definition */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp]);\n    break;\n\ncase 11:\n    /*! Production::    concat_string_literals : concat_string_literals string_literal */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 1] + yyvstack[yysp]);\n    break;\n\ncase 12:\n    /*! Production::    primary_expression : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Identifier(this._$, yytext));\n    break;\n\ncase 14:\n    /*! Production::    primary_expression : concat_string_literals */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StringLiteral(this._$, yyvstack[yysp]));\n    break;\n\ncase 15:\n    /*! Production::    primary_expression : \"(\" expression \")\" */\ncase 146:\n    /*! Production::    direct_declarator : \"(\" declarator \")\" */\ncase 169:\n    /*! Production::    direct_abstract_declarator : \"(\" abstract_declarator \")\" */\ncase 179:\n    /*! Production::    initializer : \"{\" initializer_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 1]);\n    break;\n\ncase 17:\n    /*! Production::    postfix_expression : postfix_expression \"[\" expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"arraySubscript\", yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 18:\n    /*! Production::    postfix_expression : postfix_expression \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionCallExpression(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 19:\n    /*! Production::    postfix_expression : postfix_expression \"(\" argument_expression_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionCallExpression(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 20:\n    /*! Production::    postfix_expression : postfix_expression \".\" identifier */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.MemberAccessExpression(this._$, false, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 21:\n    /*! Production::    postfix_expression : postfix_expression PTR_OP identifier */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.MemberAccessExpression(this._$, true, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 22:\n    /*! Production::    postfix_expression : postfix_expression INC_OP */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"postfixIncrement\", yyvstack[yysp - 1]));\n    break;\n\ncase 23:\n    /*! Production::    postfix_expression : postfix_expression DEC_OP */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"postfixDecrement\", yyvstack[yysp - 1]));\n    break;\n\ncase 24:\n    /*! Production::    argument_expression_list : assignment_expression */\ncase 96:\n    /*! Production::    init_declarator_list : init_declarator */\ncase 121:\n    /*! Production::    struct_declaration_list : struct_declaration */\ncase 128:\n    /*! Production::    struct_declarator_list : struct_declarator */\ncase 136:\n    /*! Production::    enumerator_list : enumerator */\ncase 155:\n    /*! Production::    type_qualifier_list : type_qualifier */\ncase 159:\n    /*! Production::    parameter_list : parameter_declaration */\ncase 181:\n    /*! Production::    initializer_list : initializer */\ncase 194:\n    /*! Production::    block_item_list : block_item */\ncase 214:\n    /*! Production::    translation_unit : external_declaration */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ([yyvstack[yysp]]);\n    break;\n\ncase 25:\n    /*! Production::    argument_expression_list : argument_expression_list \",\" assignment_expression */\ncase 97:\n    /*! Production::    init_declarator_list : init_declarator_list \",\" init_declarator */\ncase 129:\n    /*! Production::    struct_declarator_list : struct_declarator_list \",\" struct_declarator */\ncase 137:\n    /*! Production::    enumerator_list : enumerator_list \",\" enumerator */\ncase 160:\n    /*! Production::    parameter_list : parameter_list \",\" parameter_declaration */\ncase 182:\n    /*! Production::    initializer_list : initializer_list \",\" initializer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 2].push(yyvstack[yysp]), yyvstack[yysp - 2]));\n    break;\n\ncase 27:\n    /*! Production::    unary_expression : INC_OP unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"prefixIncrement\", yyvstack[yysp]));\n    break;\n\ncase 28:\n    /*! Production::    unary_expression : DEC_OP unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"prefixDecrement\", yyvstack[yysp]));\n    break;\n\ncase 29:\n    /*! Production::    unary_expression : unary_operator cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 30:\n    /*! Production::    unary_expression : SIZEOF unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SizeofExpression(this._$, yyvstack[yysp]));\n    break;\n\ncase 31:\n    /*! Production::    unary_expression : SIZEOF \"(\" type_name \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SizeofExpression(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 32:\n    /*! Production::    unary_operator : \"&\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"addressOf\");\n    break;\n\ncase 33:\n    /*! Production::    unary_operator : \"*\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"dereference\");\n    break;\n\ncase 34:\n    /*! Production::    unary_operator : \"+\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"unaryPlus\");\n    break;\n\ncase 35:\n    /*! Production::    unary_operator : \"-\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"unaryMinus\");\n    break;\n\ncase 36:\n    /*! Production::    unary_operator : \"~\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseNot\");\n    break;\n\ncase 37:\n    /*! Production::    unary_operator : \"!\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"logicalNot\");\n    break;\n\ncase 39:\n    /*! Production::    cast_expression : \"(\" type_name \")\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CastExpression(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 41:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"*\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"mul\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 42:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"/\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"div\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 43:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"%\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"mod\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 45:\n    /*! Production::    additive_expression : additive_expression \"+\" multiplicative_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"add\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 46:\n    /*! Production::    additive_expression : additive_expression \"-\" multiplicative_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"sub\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 48:\n    /*! Production::    shift_expression : shift_expression LEFT_OP additive_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseShiftLeft\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 49:\n    /*! Production::    shift_expression : shift_expression RIGHT_OP additive_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseShiftRight\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 51:\n    /*! Production::    relational_expression : relational_expression \"<\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalLT\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 52:\n    /*! Production::    relational_expression : relational_expression \">\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalGT\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 53:\n    /*! Production::    relational_expression : relational_expression LE_OP shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalLEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 54:\n    /*! Production::    relational_expression : relational_expression GE_OP shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalGEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 56:\n    /*! Production::    equality_expression : equality_expression EQ_OP relational_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 57:\n    /*! Production::    equality_expression : equality_expression NE_OP relational_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalNEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 59:\n    /*! Production::    and_expression : and_expression \"&\" equality_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseAnd\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 61:\n    /*! Production::    exclusive_or_expression : exclusive_or_expression \"^\" and_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseXor\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 63:\n    /*! Production::    inclusive_or_expression : inclusive_or_expression \"|\" exclusive_or_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseOr\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 65:\n    /*! Production::    logical_and_expression : logical_and_expression AND_OP inclusive_or_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"logicalAnd\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 67:\n    /*! Production::    logical_or_expression : logical_or_expression OR_OP logical_and_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"logicalOr\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 69:\n    /*! Production::    conditional_expression : logical_or_expression \"?\" expression \":\" conditional_expression */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ConditionalExpression(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 71:\n    /*! Production::    assignment_expression : unary_expression assignment_operator assignment_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AssignmentExpression(this._$, yyvstack[yysp - 1], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 72:\n    /*! Production::    assignment_operator : \"=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (undefined);\n    break;\n\ncase 73:\n    /*! Production::    assignment_operator : MUL_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"mul\");\n    break;\n\ncase 74:\n    /*! Production::    assignment_operator : DIV_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"div\");\n    break;\n\ncase 75:\n    /*! Production::    assignment_operator : MOD_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"mod\");\n    break;\n\ncase 76:\n    /*! Production::    assignment_operator : ADD_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"add\");\n    break;\n\ncase 77:\n    /*! Production::    assignment_operator : SUB_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"sub\");\n    break;\n\ncase 78:\n    /*! Production::    assignment_operator : LEFT_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"leftShift\");\n    break;\n\ncase 79:\n    /*! Production::    assignment_operator : RIGHT_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"rightShift\");\n    break;\n\ncase 80:\n    /*! Production::    assignment_operator : AND_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseAnd\");\n    break;\n\ncase 81:\n    /*! Production::    assignment_operator : XOR_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseXor\");\n    break;\n\ncase 82:\n    /*! Production::    assignment_operator : OR_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseOr\");\n    break;\n\ncase 84:\n    /*! Production::    expression : expression \",\" assignment_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"comma\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 85:\n    /*! Production::    constant_expression : conditional_expression */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ConstantExpression(this._$, yyvstack[yysp]));\n    break;\n\ncase 86:\n    /*! Production::    declaration : declaration_specifiers \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Declaration(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 87:\n    /*! Production::    declaration : declaration_specifiers init_declarator_list \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Declaration(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1]));\n    break;\n\ncase 88:\n    /*! Production::    declaration_specifiers : storage_class_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [], [yyvstack[yysp]], []));\n    break;\n\ncase 89:\n    /*! Production::    declaration_specifiers : storage_class_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, yyvstack[yysp].qualifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].storageList], yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 90:\n    /*! Production::    declaration_specifiers : type_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [yyvstack[yysp]], [], [], []));\n    break;\n\ncase 91:\n    /*! Production::    declaration_specifiers : type_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [yyvstack[yysp - 1], ...yyvstack[yysp].specifierList], yyvstack[yysp].qualifierList, yyvstack[yysp].storageList, yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 92:\n    /*! Production::    declaration_specifiers : type_qualifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [yyvstack[yysp]], [], []));\n    break;\n\ncase 93:\n    /*! Production::    declaration_specifiers : type_qualifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].qualifierList], yyvstack[yysp].storageList, yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 94:\n    /*! Production::    declaration_specifiers : function_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [], [], [yyvstack[yysp]]));\n    break;\n\ncase 95:\n    /*! Production::    declaration_specifiers : function_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, yyvstack[yysp].qualifierList, yyvstack[yysp].storageList, [yyvstack[yysp - 1], ...yyvstack[yysp].fnSpecifierList]));\n    break;\n\ncase 99:\n    /*! Production::    init_declarator : declarator \"=\" initializer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.InitDeclarator(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 112:\n    /*! Production::    type_specifier : _BOOL */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bool\");\n    break;\n\ncase 115:\n    /*! Production::    type_specifier : TYPE_NAME */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CustomTypeSpecifier(this._$, yyvstack[yysp]));\n    break;\n\ncase 116:\n    /*! Production::    struct_or_union_specifier : struct_or_union identifier \"{\" struct_declaration_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 117:\n    /*! Production::    struct_or_union_specifier : struct_or_union \"{\" struct_declaration_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 3], undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 118:\n    /*! Production::    struct_or_union_specifier : struct_or_union identifier */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 119:\n    /*! Production::    struct_or_union : STRUCT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"struct\");\n    break;\n\ncase 120:\n    /*! Production::    struct_or_union : UNION */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"union\");\n    break;\n\ncase 122:\n    /*! Production::    struct_declaration_list : struct_declaration_list struct_declaration */\ncase 156:\n    /*! Production::    type_qualifier_list : type_qualifier_list type_qualifier */\ncase 195:\n    /*! Production::    block_item_list : block_item_list block_item */\ncase 215:\n    /*! Production::    translation_unit : translation_unit external_declaration */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 1].push(yyvstack[yysp]), yyvstack[yysp - 1]));\n    break;\n\ncase 123:\n    /*! Production::    struct_declaration : specifier_qualifier_list struct_declarator_list \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructDeclaration(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1]));\n    break;\n\ncase 124:\n    /*! Production::    specifier_qualifier_list : type_specifier specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [yyvstack[yysp - 1], ...yyvstack[yysp].specifierList], yyvstack[yysp].qualifierList));\n    break;\n\ncase 125:\n    /*! Production::    specifier_qualifier_list : type_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [yyvstack[yysp]], []));\n    break;\n\ncase 126:\n    /*! Production::    specifier_qualifier_list : type_qualifier specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, yyvstack[yysp].specifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].qualifierList]));\n    break;\n\ncase 127:\n    /*! Production::    specifier_qualifier_list : type_qualifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [], [yyvstack[yysp]]));\n    break;\n\ncase 131:\n    /*! Production::    enum_specifier : ENUM \"{\" enumerator_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 132:\n    /*! Production::    enum_specifier : ENUM identifier \"{\" enumerator_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 133:\n    /*! Production::    enum_specifier : ENUM \"{\" enumerator_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, undefined, yyvstack[yysp - 2]));\n    break;\n\ncase 134:\n    /*! Production::    enum_specifier : ENUM identifier \"{\" enumerator_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);\n    // END of default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2]));\n    break;\n\ncase 135:\n    /*! Production::    enum_specifier : ENUM identifier */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp]));\n    break;\n\ncase 138:\n    /*! Production::    enumerator : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Enumerator(this._$, yyvstack[yysp]));\n    break;\n\ncase 139:\n    /*! Production::    enumerator : identifier \"=\" constant_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Enumerator(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 140:\n    /*! Production::    type_qualifier : CONST */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"const\");\n    break;\n\ncase 141:\n    /*! Production::    function_specifier : INLINE */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"inline\");\n    break;\n\ncase 143:\n    /*! Production::    declarator : pointer direct_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.PointerDeclarator(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 145:\n    /*! Production::    direct_declarator : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IdentifierDeclarator(this._$, yyvstack[yysp]));\n    break;\n\ncase 147:\n    /*! Production::    direct_declarator : direct_declarator \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ArrayDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 148:\n    /*! Production::    direct_declarator : direct_declarator \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ArrayDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 149:\n    /*! Production::    direct_declarator : direct_declarator \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 150:\n    /*! Production::    direct_declarator : direct_declarator \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 151:\n    /*! Production::    pointer : \"*\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$));\n    break;\n\ncase 152:\n    /*! Production::    pointer : \"*\" type_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, yyvstack[yysp]));\n    break;\n\ncase 153:\n    /*! Production::    pointer : \"*\" pointer */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, undefined, yyvstack[yysp]));\n    break;\n\ncase 154:\n    /*! Production::    pointer : \"*\" type_qualifier_list pointer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 157:\n    /*! Production::    parameter_type_list : parameter_list */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp].variadic = false, yyvstack[yysp]));\n    break;\n\ncase 158:\n    /*! Production::    parameter_type_list : parameter_list \",\" ELLIPSIS */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 2].variadic = true, yyvstack[yysp - 2]));\n    break;\n\ncase 161:\n    /*! Production::    parameter_declaration : declaration_specifiers declarator */\ncase 162:\n    /*! Production::    parameter_declaration : declaration_specifiers abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ParameterDeclaration(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 163:\n    /*! Production::    parameter_declaration : declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ParameterDeclaration(this._$, yyvstack[yysp]));\n    break;\n\ncase 164:\n    /*! Production::    type_name : specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.TypeName(this._$, yyvstack[yysp]));\n    break;\n\ncase 165:\n    /*! Production::    type_name : specifier_qualifier_list abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.TypeName(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 166:\n    /*! Production::    abstract_declarator : pointer */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractPointerDeclarator(this._$, yyvstack[yysp]));\n    break;\n\ncase 168:\n    /*! Production::    abstract_declarator : pointer direct_abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractPointerDeclarator(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 170:\n    /*! Production::    direct_abstract_declarator : \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$));\n    break;\n\ncase 171:\n    /*! Production::    direct_abstract_declarator : \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 172:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 173:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 174:\n    /*! Production::    direct_abstract_declarator : \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$));\n    break;\n\ncase 175:\n    /*! Production::    direct_abstract_declarator : \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, undefined, yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 176:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 177:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 180:\n    /*! Production::    initializer : \"{\" initializer_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 2]);\n    break;\n\ncase 189:\n    /*! Production::    labeled_statement : identifier \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp].setLabel(yyvstack[yysp - 2]));\n    break;\n\ncase 190:\n    /*! Production::    labeled_statement : CASE constant_expression \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CaseStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 191:\n    /*! Production::    labeled_statement : DEFAULT \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DefaultStatement(this._$, yyvstack[yysp]));\n    break;\n\ncase 192:\n    /*! Production::    compound_statement : \"{\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CompoundStatement(this._$, []));\n    break;\n\ncase 193:\n    /*! Production::    compound_statement : \"{\" block_item_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CompoundStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 198:\n    /*! Production::    expression_statement : \";\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.NoOp(this._$));\n    break;\n\ncase 199:\n    /*! Production::    expression_statement : expression \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ExpressionStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 200:\n    /*! Production::    selection_statement : IF \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IfStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 201:\n    /*! Production::    selection_statement : IF \"(\" expression \")\" statement ELSE statement */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IfStatement(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 202:\n    /*! Production::    selection_statement : SWITCH \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SwitchStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 203:\n    /*! Production::    iteration_statement : WHILE \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.WhileLoop(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 204:\n    /*! Production::    iteration_statement : DO statement WHILE \"(\" expression \")\" \";\" */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DoWhileLoop(this._$, yyvstack[yysp - 5], yyvstack[yysp - 2]));\n    break;\n\ncase 205:\n    /*! Production::    iteration_statement : FOR \"(\" expression_statement expression_statement \")\" statement */\ncase 207:\n    /*! Production::    iteration_statement : FOR \"(\" declaration expression_statement \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);\n    // END of default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ForLoop(this._$, yyvstack[yysp - 3], yyvstack[yysp - 2], undefined, yyvstack[yysp]));\n    break;\n\ncase 206:\n    /*! Production::    iteration_statement : FOR \"(\" expression_statement expression_statement expression \")\" statement */\ncase 208:\n    /*! Production::    iteration_statement : FOR \"(\" declaration expression_statement expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ForLoop(this._$, yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 209:\n    /*! Production::    jump_statement : GOTO identifier \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.GotoStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 210:\n    /*! Production::    jump_statement : CONTINUE \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ContinueStatement(this._$));\n    break;\n\ncase 211:\n    /*! Production::    jump_statement : BREAK \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BreakStatement(this._$));\n    break;\n\ncase 212:\n    /*! Production::    jump_statement : RETURN \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ReturnStatement(this._$));\n    break;\n\ncase 213:\n    /*! Production::    jump_statement : RETURN expression \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ReturnStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 217:\n    /*! Production::    external_declaration : declaration */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yylexer.externalDeclaration(yyvstack[yysp]), yyvstack[yysp]));\n    break;\n\ncase 218:\n    /*! Production::    function_definition : declaration_specifiers declarator compound_statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDefinition(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\n}\n},\ntable: bt({\n  len: u([\n  34,\n  1,\n  32,\n  s,\n  [0, 4],\n  10,\n  s,\n  [35, 4],\n  s,\n  [0, 19],\n  3,\n  3,\n  s,\n  [0, 4],\n  5,\n  0,\n  2,\n  4,\n  7,\n  0,\n  10,\n  0,\n  7,\n  s,\n  [0, 5],\n  28,\n  23,\n  4,\n  28,\n  0,\n  40,\n  91,\n  0,\n  8,\n  7,\n  39,\n  32,\n  9,\n  0,\n  0,\n  1,\n  23,\n  23,\n  0,\n  9,\n  26,\n  26,\n  2,\n  0,\n  3,\n  4,\n  0,\n  0,\n  41,\n  0,\n  37,\n  8,\n  42,\n  25,\n  25,\n  26,\n  25,\n  c,\n  [25, 3],\n  s,\n  [0, 5],\n  10,\n  0,\n  0,\n  44,\n  61,\n  11,\n  s,\n  [0, 6],\n  12,\n  0,\n  14,\n  18,\n  20,\n  22,\n  25,\n  0,\n  0,\n  90,\n  c,\n  [25, 6],\n  s,\n  [0, 4],\n  39,\n  38,\n  1,\n  0,\n  2,\n  s,\n  [1, 3],\n  59,\n  1,\n  c,\n  [6, 3],\n  40,\n  c,\n  [113, 3],\n  1,\n  s,\n  [0, 3],\n  c,\n  [19, 3],\n  c,\n  [45, 3],\n  0,\n  0,\n  23,\n  0,\n  c,\n  [9, 3],\n  s,\n  [0, 4],\n  4,\n  38,\n  2,\n  2,\n  0,\n  38,\n  s,\n  [0, 11],\n  39,\n  35,\n  39,\n  40,\n  c,\n  [19, 3],\n  c,\n  [9, 3],\n  s,\n  [0, 3],\n  61,\n  34,\n  33,\n  c,\n  [68, 3],\n  7,\n  32,\n  31,\n  30,\n  30,\n  s,\n  [29, 4],\n  28,\n  28,\n  27,\n  27,\n  s,\n  [26, 3],\n  0,\n  0,\n  59,\n  1,\n  59,\n  0,\n  38,\n  s,\n  [39, 3],\n  1,\n  70,\n  c,\n  [85, 4],\n  c,\n  [46, 3],\n  30,\n  0,\n  0,\n  8,\n  4,\n  42,\n  c,\n  [51, 3],\n  8,\n  c,\n  [85, 5],\n  c,\n  [174, 3],\n  2,\n  9,\n  2,\n  c,\n  [99, 5],\n  1,\n  10,\n  11,\n  0,\n  26,\n  c,\n  [103, 3],\n  12,\n  14,\n  18,\n  18,\n  s,\n  [20, 4],\n  22,\n  22,\n  25,\n  c,\n  [168, 3],\n  c,\n  [67, 3],\n  c,\n  [56, 3],\n  2,\n  2,\n  1,\n  41,\n  41,\n  c,\n  [49, 5],\n  39,\n  32,\n  1,\n  c,\n  [156, 3],\n  c,\n  [77, 4],\n  0,\n  37,\n  0,\n  c,\n  [144, 5],\n  s,\n  [59, 3],\n  39,\n  40,\n  40,\n  c,\n  [21, 8],\n  0,\n  52,\n  c,\n  [47, 3],\n  59,\n  2,\n  59,\n  c,\n  [82, 3],\n  59,\n  1,\n  c,\n  [60, 3],\n  c,\n  [62, 3],\n  0,\n  0\n]),\n  symbol: u([\n  1,\n  s,\n  [56, 20, 1],\n  89,\n  115,\n  116,\n  s,\n  [119, 4, 1],\n  128,\n  131,\n  132,\n  154,\n  155,\n  156,\n  1,\n  c,\n  [35, 21],\n  c,\n  [34, 9],\n  155,\n  156,\n  3,\n  10,\n  24,\n  27,\n  90,\n  117,\n  118,\n  133,\n  134,\n  135,\n  3,\n  4,\n  5,\n  8,\n  c,\n  [13, 3],\n  c,\n  [48, 20],\n  c,\n  [47, 8],\n  c,\n  [35, 105],\n  25,\n  27,\n  90,\n  c,\n  [3, 3],\n  8,\n  23,\n  24,\n  25,\n  147,\n  8,\n  24,\n  3,\n  27,\n  90,\n  134,\n  c,\n  [52, 4],\n  c,\n  [14, 3],\n  c,\n  [59, 5],\n  27,\n  73,\n  131,\n  135,\n  136,\n  3,\n  10,\n  27,\n  90,\n  c,\n  [181, 9],\n  25,\n  c,\n  [77, 21],\n  c,\n  [17, 15],\n  s,\n  [120, 6, 1],\n  128,\n  131,\n  27,\n  90,\n  129,\n  130,\n  c,\n  [55, 28],\n  3,\n  s,\n  [9, 6, 1],\n  25,\n  s,\n  [27, 7, 1],\n  35,\n  36,\n  37,\n  s,\n  [90, 6, 1],\n  s,\n  [97, 15, 1],\n  143,\n  c,\n  [40, 7],\n  s,\n  [24, 10, 1],\n  c,\n  [42, 3],\n  c,\n  [80, 20],\n  77,\n  78,\n  79,\n  s,\n  [81, 8, 1],\n  c,\n  [73, 21],\n  113,\n  c,\n  [398, 9],\n  s,\n  [145, 9, 1],\n  c,\n  [221, 4],\n  c,\n  [403, 8],\n  c,\n  [246, 4],\n  6,\n  c,\n  [107, 6],\n  c,\n  [146, 30],\n  114,\n  4,\n  c,\n  [338, 28],\n  137,\n  138,\n  139,\n  c,\n  [317, 9],\n  4,\n  c,\n  [282, 23],\n  26,\n  c,\n  [24, 18],\n  c,\n  [23, 4],\n  c,\n  [142, 4],\n  126,\n  127,\n  c,\n  [143, 6],\n  10,\n  27,\n  c,\n  [36, 18],\n  c,\n  [35, 4],\n  c,\n  [26, 25],\n  8,\n  26,\n  8,\n  23,\n  26,\n  c,\n  [371, 5],\n  c,\n  [343, 39],\n  144,\n  4,\n  6,\n  s,\n  [8, 5, 1],\n  s,\n  [15, 10, 1],\n  26,\n  s,\n  [38, 18, 1],\n  112,\n  c,\n  [37, 3],\n  21,\n  22,\n  24,\n  26,\n  45,\n  s,\n  [3, 10, 1],\n  c,\n  [48, 11],\n  34,\n  35,\n  36,\n  c,\n  [51, 18],\n  c,\n  [128, 7],\n  c,\n  [127, 18],\n  c,\n  [25, 50],\n  99,\n  c,\n  [26, 25],\n  c,\n  [151, 7],\n  44,\n  45,\n  c,\n  [9, 3],\n  c,\n  [140, 3],\n  c,\n  [10, 4],\n  c,\n  [162, 21],\n  s,\n  [33, 4, 1],\n  c,\n  [163, 18],\n  92,\n  c,\n  [88, 17],\n  c,\n  [339, 15],\n  c,\n  [576, 22],\n  c,\n  [361, 6],\n  140,\n  c,\n  [115, 3],\n  c,\n  [94, 4],\n  c,\n  [126, 7],\n  9,\n  c,\n  [12, 18],\n  c,\n  [109, 4],\n  c,\n  [14, 4],\n  c,\n  [134, 6],\n  24,\n  26,\n  c,\n  [127, 6],\n  c,\n  [18, 12],\n  c,\n  [147, 8],\n  c,\n  [20, 4],\n  11,\n  12,\n  c,\n  [22, 20],\n  c,\n  [199, 11],\n  c,\n  [25, 10],\n  c,\n  [778, 85],\n  c,\n  [777, 7],\n  c,\n  [1182, 9],\n  5,\n  c,\n  [325, 16],\n  c,\n  [486, 46],\n  c,\n  [810, 13],\n  22,\n  c,\n  [1109, 3],\n  s,\n  [3, 3],\n  c,\n  [183, 8],\n  c,\n  [46, 10],\n  c,\n  [162, 33],\n  c,\n  [153, 3],\n  c,\n  [152, 5],\n  27,\n  90,\n  24,\n  24,\n  c,\n  [64, 8],\n  c,\n  [722, 31],\n  113,\n  c,\n  [963, 3],\n  6,\n  4,\n  4,\n  8,\n  c,\n  [895, 6],\n  c,\n  [1205, 4],\n  141,\n  142,\n  c,\n  [874, 23],\n  8,\n  24,\n  c,\n  [811, 3],\n  c,\n  [810, 8],\n  c,\n  [196, 31],\n  c,\n  [857, 3],\n  26,\n  c,\n  [42, 37],\n  111,\n  c,\n  [38, 38],\n  113,\n  c,\n  [39, 35],\n  c,\n  [74, 40],\n  4,\n  c,\n  [40, 22],\n  s,\n  [96, 16, 1],\n  27,\n  90,\n  27,\n  90,\n  c,\n  [157, 56],\n  c,\n  [794, 44],\n  c,\n  [100, 34],\n  c,\n  [34, 33],\n  4,\n  8,\n  4,\n  c,\n  [1252, 4],\n  c,\n  [443, 3],\n  c,\n  [43, 32],\n  c,\n  [32, 31],\n  c,\n  [31, 30],\n  c,\n  [30, 59],\n  c,\n  [29, 115],\n  c,\n  [28, 55],\n  c,\n  [27, 53],\n  c,\n  [26, 59],\n  c,\n  [993, 52],\n  22,\n  c,\n  [1053, 60],\n  c,\n  [918, 111],\n  c,\n  [39, 43],\n  82,\n  c,\n  [1204, 18],\n  c,\n  [1449, 20],\n  c,\n  [1438, 31],\n  150,\n  24,\n  8,\n  24,\n  s,\n  [56, 21, 1],\n  c,\n  [33, 8],\n  c,\n  [2155, 5],\n  c,\n  [2486, 3],\n  142,\n  c,\n  [8, 4],\n  c,\n  [2076, 5],\n  c,\n  [102, 21],\n  c,\n  [47, 8],\n  c,\n  [1299, 3],\n  c,\n  [2207, 3],\n  c,\n  [859, 3],\n  c,\n  [2280, 38],\n  c,\n  [2192, 4],\n  c,\n  [2191, 4],\n  c,\n  [1324, 11],\n  c,\n  [1658, 12],\n  c,\n  [2135, 22],\n  8,\n  22,\n  c,\n  [1948, 9],\n  6,\n  8,\n  c,\n  [974, 3],\n  c,\n  [1953, 10],\n  c,\n  [1848, 11],\n  c,\n  [587, 27],\n  4,\n  5,\n  c,\n  [205, 4],\n  10,\n  c,\n  [2403, 28],\n  c,\n  [197, 6],\n  c,\n  [1916, 56],\n  c,\n  [1934, 30],\n  c,\n  [20, 60],\n  c,\n  [1994, 22],\n  c,\n  [2016, 43],\n  c,\n  [2041, 34],\n  c,\n  [805, 50],\n  c,\n  [387, 3],\n  c,\n  [391, 3],\n  c,\n  [1924, 9],\n  c,\n  [697, 32],\n  150,\n  c,\n  [41, 42],\n  c,\n  [627, 4],\n  c,\n  [2865, 70],\n  c,\n  [549, 3],\n  c,\n  [856, 37],\n  c,\n  [1009, 45],\n  c,\n  [1106, 59],\n  c,\n  [59, 118],\n  c,\n  [2030, 56],\n  c,\n  [40, 56],\n  6,\n  4,\n  c,\n  [2640, 43],\n  s,\n  [80, 9, 1],\n  c,\n  [588, 3],\n  c,\n  [653, 60],\n  c,\n  [61, 120],\n  c,\n  [2629, 9],\n  c,\n  [475, 110]\n]),\n  type: u([\n  s,\n  [2, 21],\n  s,\n  [0, 13],\n  1,\n  c,\n  [35, 32],\n  c,\n  [15, 10],\n  s,\n  [2, 27],\n  c,\n  [45, 12],\n  c,\n  [35, 103],\n  c,\n  [3, 6],\n  c,\n  [5, 8],\n  c,\n  [52, 15],\n  c,\n  [69, 6],\n  c,\n  [76, 31],\n  c,\n  [92, 25],\n  c,\n  [55, 46],\n  c,\n  [338, 16],\n  c,\n  [314, 13],\n  s,\n  [2, 47],\n  s,\n  [0, 40],\n  c,\n  [43, 8],\n  c,\n  [73, 46],\n  c,\n  [491, 36],\n  c,\n  [333, 19],\n  c,\n  [409, 26],\n  c,\n  [142, 15],\n  c,\n  [97, 21],\n  c,\n  [26, 38],\n  c,\n  [35, 21],\n  c,\n  [253, 26],\n  c,\n  [329, 34],\n  s,\n  [2, 67],\n  c,\n  [112, 25],\n  c,\n  [25, 33],\n  c,\n  [51, 43],\n  c,\n  [146, 46],\n  c,\n  [576, 61],\n  s,\n  [2, 173],\n  c,\n  [777, 42],\n  c,\n  [1182, 34],\n  c,\n  [105, 50],\n  c,\n  [162, 65],\n  c,\n  [428, 23],\n  c,\n  [409, 35],\n  c,\n  [874, 32],\n  c,\n  [927, 19],\n  c,\n  [1006, 54],\n  c,\n  [42, 27],\n  c,\n  [576, 39],\n  c,\n  [74, 74],\n  c,\n  [40, 24],\n  c,\n  [1420, 3],\n  c,\n  [1389, 71],\n  c,\n  [794, 46],\n  c,\n  [34, 50],\n  c,\n  [1657, 13],\n  c,\n  [43, 29],\n  c,\n  [32, 31],\n  c,\n  [31, 30],\n  c,\n  [30, 59],\n  c,\n  [29, 115],\n  c,\n  [28, 55],\n  c,\n  [27, 53],\n  c,\n  [26, 69],\n  c,\n  [1357, 73],\n  c,\n  [623, 63],\n  c,\n  [918, 78],\n  c,\n  [922, 61],\n  c,\n  [1438, 53],\n  c,\n  [56, 33],\n  c,\n  [2037, 26],\n  c,\n  [902, 45],\n  c,\n  [314, 25],\n  c,\n  [1413, 8],\n  c,\n  [97, 20],\n  c,\n  [1822, 76],\n  c,\n  [116, 13],\n  c,\n  [200, 38],\n  s,\n  [2, 266],\n  c,\n  [865, 54],\n  c,\n  [48, 41],\n  c,\n  [89, 45],\n  c,\n  [2865, 60],\n  c,\n  [73, 33],\n  c,\n  [2165, 68],\n  c,\n  [1166, 59],\n  c,\n  [59, 105],\n  c,\n  [2030, 63],\n  c,\n  [938, 93],\n  c,\n  [2875, 93],\n  c,\n  [61, 121],\n  c,\n  [475, 88]\n]),\n  state: u([\n  1,\n  s,\n  [6, 4, 1],\n  25,\n  31,\n  26,\n  10,\n  11,\n  2,\n  s,\n  [4, 6, 1],\n  c,\n  [12, 5],\n  36,\n  5,\n  44,\n  39,\n  42,\n  37,\n  41,\n  40,\n  47,\n  c,\n  [16, 7],\n  48,\n  c,\n  [8, 7],\n  49,\n  c,\n  [8, 7],\n  50,\n  c,\n  [8, 7],\n  51,\n  54,\n  55,\n  44,\n  60,\n  65,\n  64,\n  63,\n  44,\n  66,\n  41,\n  40,\n  71,\n  25,\n  31,\n  68,\n  69,\n  70,\n  26,\n  72,\n  75,\n  73,\n  74,\n  97,\n  98,\n  107,\n  99,\n  89,\n  83,\n  81,\n  86,\n  s,\n  [115, 6, -1],\n  108,\n  101,\n  96,\n  88,\n  82,\n  80,\n  78,\n  77,\n  128,\n  c,\n  [22, 19],\n  142,\n  132,\n  119,\n  121,\n  c,\n  [76, 7],\n  120,\n  122,\n  123,\n  117,\n  118,\n  s,\n  [124, 4, 1],\n  44,\n  143,\n  144,\n  41,\n  40,\n  c,\n  [67, 6],\n  148,\n  c,\n  [45, 12],\n  147,\n  145,\n  153,\n  c,\n  [43, 7],\n  149,\n  151,\n  152,\n  155,\n  154,\n  c,\n  [112, 3],\n  157,\n  c,\n  [112, 4],\n  c,\n  [8, 3],\n  159,\n  c,\n  [7, 3],\n  44,\n  160,\n  161,\n  162,\n  c,\n  [133, 5],\n  163,\n  c,\n  [19, 5],\n  164,\n  c,\n  [137, 3],\n  168,\n  c,\n  [137, 22],\n  170,\n  169,\n  171,\n  c,\n  [24, 6],\n  191,\n  86,\n  c,\n  [8, 6],\n  193,\n  c,\n  [8, 7],\n  148,\n  86,\n  194,\n  c,\n  [9, 6],\n  195,\n  86,\n  199,\n  c,\n  [58, 20],\n  142,\n  200,\n  c,\n  [89, 3],\n  202,\n  26,\n  72,\n  201,\n  c,\n  [202, 34],\n  219,\n  c,\n  [201, 5],\n  39,\n  42,\n  c,\n  [202, 23],\n  221,\n  c,\n  [66, 22],\n  228,\n  s,\n  [122, 6, 1],\n  230,\n  c,\n  [125, 21],\n  234,\n  44,\n  238,\n  41,\n  240,\n  239,\n  241,\n  c,\n  [239, 7],\n  75,\n  248,\n  c,\n  [88, 20],\n  249,\n  c,\n  [58, 20],\n  254,\n  c,\n  [79, 21],\n  255,\n  c,\n  [64, 17],\n  256,\n  c,\n  [40, 21],\n  257,\n  c,\n  [22, 6],\n  259,\n  c,\n  [23, 14],\n  260,\n  261,\n  262,\n  c,\n  [290, 22],\n  c,\n  [312, 28],\n  263,\n  c,\n  [115, 16],\n  264,\n  c,\n  [17, 15],\n  265,\n  269,\n  268,\n  241,\n  c,\n  [19, 14],\n  271,\n  c,\n  [15, 13],\n  272,\n  c,\n  [14, 12],\n  273,\n  c,\n  [13, 12],\n  274,\n  c,\n  [13, 11],\n  275,\n  c,\n  [12, 11],\n  276,\n  c,\n  [12, 11],\n  277,\n  c,\n  [12, 11],\n  278,\n  c,\n  [12, 10],\n  279,\n  c,\n  [11, 10],\n  280,\n  c,\n  [11, 9],\n  281,\n  c,\n  [10, 9],\n  282,\n  c,\n  [10, 8],\n  283,\n  c,\n  [9, 8],\n  284,\n  c,\n  [9, 8],\n  285,\n  c,\n  [454, 22],\n  286,\n  s,\n  [122, 7, 1],\n  c,\n  [29, 21],\n  288,\n  c,\n  [29, 6],\n  c,\n  [295, 20],\n  289,\n  c,\n  [316, 21],\n  290,\n  c,\n  [22, 21],\n  291,\n  c,\n  [22, 21],\n  292,\n  c,\n  [22, 21],\n  132,\n  295,\n  c,\n  [665, 8],\n  294,\n  c,\n  [833, 8],\n  299,\n  44,\n  60,\n  300,\n  44,\n  c,\n  [13, 8],\n  66,\n  41,\n  240,\n  305,\n  151,\n  152,\n  303,\n  c,\n  [378, 15],\n  c,\n  [593, 6],\n  307,\n  44,\n  308,\n  c,\n  [854, 3],\n  c,\n  [621, 8],\n  c,\n  [841, 15],\n  311,\n  c,\n  [50, 8],\n  317,\n  300,\n  c,\n  [76, 8],\n  269,\n  c,\n  [74, 5],\n  c,\n  [251, 22],\n  318,\n  c,\n  [251, 26],\n  142,\n  132,\n  323,\n  c,\n  [23, 22],\n  324,\n  c,\n  [149, 20],\n  326,\n  c,\n  [110, 8],\n  328,\n  151,\n  152,\n  c,\n  [32, 19],\n  332,\n  c,\n  [75, 20],\n  333,\n  c,\n  [148, 22],\n  334,\n  c,\n  [428, 28],\n  335,\n  c,\n  [29, 28],\n  336,\n  c,\n  [206, 27],\n  337,\n  c,\n  [22, 21],\n  339,\n  c,\n  [22, 21],\n  341,\n  c,\n  [95, 22],\n  346,\n  c,\n  [124, 28],\n  348,\n  c,\n  [29, 28],\n  350,\n  c,\n  [29, 28],\n  352,\n  c,\n  [29, 28],\n  353,\n  c,\n  [29, 6]\n]),\n  mode: u([\n  s,\n  [1, 46],\n  s,\n  [2, 7],\n  c,\n  [27, 101],\n  c,\n  [31, 5],\n  1,\n  c,\n  [27, 7],\n  c,\n  [9, 3],\n  c,\n  [43, 8],\n  c,\n  [18, 5],\n  c,\n  [12, 8],\n  s,\n  [2, 20],\n  c,\n  [100, 22],\n  c,\n  [44, 38],\n  s,\n  [1, 57],\n  c,\n  [96, 6],\n  c,\n  [327, 43],\n  c,\n  [218, 8],\n  c,\n  [369, 35],\n  c,\n  [20, 35],\n  c,\n  [299, 11],\n  c,\n  [352, 20],\n  c,\n  [317, 10],\n  c,\n  [250, 19],\n  c,\n  [24, 7],\n  c,\n  [67, 6],\n  c,\n  [289, 19],\n  c,\n  [310, 86],\n  c,\n  [146, 12],\n  c,\n  [412, 22],\n  c,\n  [440, 60],\n  c,\n  [236, 15],\n  c,\n  [65, 20],\n  c,\n  [8, 22],\n  c,\n  [34, 18],\n  c,\n  [30, 22],\n  c,\n  [87, 7],\n  c,\n  [55, 20],\n  c,\n  [271, 60],\n  c,\n  [246, 30],\n  c,\n  [688, 75],\n  c,\n  [561, 7],\n  c,\n  [502, 7],\n  s,\n  [1, 217],\n  c,\n  [219, 219],\n  s,\n  [1, 232],\n  c,\n  [680, 7],\n  c,\n  [458, 70],\n  c,\n  [1605, 13],\n  c,\n  [1062, 14],\n  c,\n  [1676, 26],\n  c,\n  [123, 26],\n  c,\n  [1116, 48],\n  c,\n  [1134, 38],\n  c,\n  [20, 60],\n  c,\n  [1194, 23],\n  c,\n  [1216, 42],\n  c,\n  [1241, 80],\n  c,\n  [2006, 28],\n  c,\n  [690, 216],\n  s,\n  [2, 42],\n  c,\n  [538, 11],\n  s,\n  [1, 155]\n]),\n  goto: u([\n  3,\n  s,\n  [12, 13, 1],\n  27,\n  33,\n  34,\n  32,\n  28,\n  29,\n  30,\n  35,\n  c,\n  [21, 20],\n  45,\n  43,\n  38,\n  46,\n  s,\n  [88, 7],\n  c,\n  [31, 20],\n  s,\n  [90, 7],\n  c,\n  [27, 20],\n  s,\n  [92, 7],\n  c,\n  [27, 20],\n  s,\n  [94, 7],\n  c,\n  [27, 20],\n  52,\n  46,\n  53,\n  46,\n  98,\n  56,\n  98,\n  57,\n  59,\n  58,\n  45,\n  46,\n  62,\n  144,\n  61,\n  s,\n  [144, 4],\n  s,\n  [151, 4],\n  43,\n  151,\n  28,\n  45,\n  43,\n  46,\n  s,\n  [118, 6],\n  67,\n  s,\n  [118, 21],\n  c,\n  [74, 15],\n  46,\n  s,\n  [135, 6],\n  76,\n  s,\n  [135, 21],\n  100,\n  s,\n  [90, 6, 1],\n  79,\n  46,\n  s,\n  [102, 5, 1],\n  109,\n  84,\n  85,\n  87,\n  c,\n  [18, 7],\n  131,\n  57,\n  116,\n  c,\n  [20, 10],\n  c,\n  [159, 20],\n  129,\n  130,\n  s,\n  [133, 9, 1],\n  c,\n  [144, 3],\n  62,\n  143,\n  61,\n  s,\n  [143, 4],\n  100,\n  146,\n  c,\n  [62, 6],\n  c,\n  [59, 10],\n  150,\n  c,\n  [60, 20],\n  s,\n  [152, 4],\n  43,\n  152,\n  28,\n  156,\n  c,\n  [25, 15],\n  158,\n  c,\n  [16, 15],\n  c,\n  [88, 3],\n  s,\n  [125, 5],\n  c,\n  [23, 15],\n  s,\n  [127, 5],\n  c,\n  [20, 15],\n  166,\n  165,\n  138,\n  167,\n  138,\n  46,\n  c,\n  [206, 18],\n  s,\n  [38, 15],\n  172,\n  s,\n  [38, 10],\n  s,\n  [173, 10, 1],\n  s,\n  [68, 3],\n  183,\n  s,\n  [68, 3],\n  184,\n  186,\n  26,\n  185,\n  26,\n  187,\n  s,\n  [26, 16],\n  188,\n  189,\n  190,\n  s,\n  [26, 18],\n  192,\n  c,\n  [230, 16],\n  c,\n  [17, 17],\n  c,\n  [138, 7],\n  c,\n  [17, 10],\n  196,\n  c,\n  [17, 16],\n  s,\n  [66, 7],\n  197,\n  66,\n  s,\n  [64, 3],\n  198,\n  s,\n  [64, 6],\n  s,\n  [14, 21],\n  109,\n  s,\n  [14, 21],\n  c,\n  [96, 17],\n  c,\n  [272, 15],\n  s,\n  [62, 3],\n  203,\n  s,\n  [62, 7],\n  s,\n  [60, 3],\n  204,\n  s,\n  [60, 8],\n  s,\n  [58, 10],\n  205,\n  206,\n  58,\n  58,\n  s,\n  [55, 4],\n  207,\n  208,\n  s,\n  [55, 6],\n  209,\n  210,\n  s,\n  [55, 4],\n  s,\n  [50, 12],\n  211,\n  212,\n  s,\n  [50, 6],\n  s,\n  [47, 4],\n  213,\n  214,\n  s,\n  [47, 16],\n  s,\n  [44, 4],\n  215,\n  44,\n  44,\n  216,\n  217,\n  s,\n  [44, 16],\n  c,\n  [576, 9],\n  218,\n  c,\n  [576, 43],\n  38,\n  46,\n  s,\n  [12, 15],\n  220,\n  s,\n  [12, 23],\n  c,\n  [248, 17],\n  222,\n  224,\n  223,\n  225,\n  226,\n  227,\n  c,\n  [117, 9],\n  c,\n  [25, 10],\n  c,\n  [96, 11],\n  229,\n  46,\n  231,\n  232,\n  c,\n  [34, 7],\n  233,\n  c,\n  [33, 10],\n  c,\n  [860, 3],\n  235,\n  236,\n  157,\n  237,\n  242,\n  163,\n  243,\n  163,\n  43,\n  46,\n  244,\n  c,\n  [160, 15],\n  246,\n  245,\n  247,\n  c,\n  [590, 8],\n  c,\n  [50, 10],\n  251,\n  250,\n  253,\n  252,\n  c,\n  [21, 17],\n  c,\n  [17, 52],\n  258,\n  c,\n  [18, 16],\n  46,\n  c,\n  [109, 18],\n  c,\n  [482, 32],\n  c,\n  [49, 34],\n  266,\n  224,\n  267,\n  270,\n  164,\n  243,\n  43,\n  c,\n  [178, 69],\n  c,\n  [17, 193],\n  c,\n  [539, 23],\n  287,\n  c,\n  [31, 30],\n  c,\n  [129, 68],\n  293,\n  c,\n  [99, 8],\n  c,\n  [784, 30],\n  296,\n  224,\n  297,\n  c,\n  [23, 20],\n  298,\n  242,\n  166,\n  243,\n  166,\n  46,\n  302,\n  167,\n  301,\n  167,\n  242,\n  304,\n  243,\n  43,\n  46,\n  c,\n  [35, 20],\n  100,\n  306,\n  c,\n  [115, 16],\n  c,\n  [1337, 3],\n  309,\n  c,\n  [1293, 9],\n  310,\n  c,\n  [24, 10],\n  224,\n  312,\n  s,\n  [67, 7],\n  197,\n  67,\n  313,\n  224,\n  314,\n  315,\n  316,\n  s,\n  [65, 3],\n  198,\n  s,\n  [65, 6],\n  s,\n  [63, 3],\n  203,\n  s,\n  [63, 7],\n  c,\n  [193, 17],\n  270,\n  166,\n  243,\n  270,\n  c,\n  [124, 3],\n  c,\n  [123, 20],\n  s,\n  [61, 3],\n  204,\n  s,\n  [61, 8],\n  s,\n  [59, 10],\n  205,\n  206,\n  59,\n  59,\n  s,\n  [56, 4],\n  207,\n  208,\n  s,\n  [56, 6],\n  209,\n  210,\n  s,\n  [56, 4],\n  s,\n  [57, 4],\n  207,\n  208,\n  s,\n  [57, 6],\n  209,\n  210,\n  s,\n  [57, 4],\n  s,\n  [51, 12],\n  211,\n  212,\n  s,\n  [51, 6],\n  s,\n  [52, 12],\n  211,\n  212,\n  s,\n  [52, 6],\n  s,\n  [53, 12],\n  211,\n  212,\n  s,\n  [53, 6],\n  s,\n  [54, 12],\n  211,\n  212,\n  s,\n  [54, 6],\n  s,\n  [48, 4],\n  213,\n  214,\n  s,\n  [48, 16],\n  s,\n  [49, 4],\n  213,\n  214,\n  s,\n  [49, 16],\n  s,\n  [45, 4],\n  215,\n  45,\n  45,\n  216,\n  217,\n  s,\n  [45, 16],\n  s,\n  [46, 4],\n  215,\n  46,\n  46,\n  216,\n  217,\n  s,\n  [46, 16],\n  c,\n  [554, 30],\n  319,\n  224,\n  320,\n  224,\n  321,\n  224,\n  322,\n  c,\n  [492, 18],\n  c,\n  [18, 18],\n  302,\n  168,\n  301,\n  168,\n  100,\n  325,\n  c,\n  [358, 16],\n  327,\n  c,\n  [352, 20],\n  329,\n  330,\n  331,\n  c,\n  [738, 64],\n  c,\n  [30, 67],\n  c,\n  [107, 11],\n  338,\n  c,\n  [18, 17],\n  340,\n  c,\n  [18, 16],\n  342,\n  343,\n  s,\n  [200, 43],\n  344,\n  s,\n  [200, 8],\n  345,\n  224,\n  c,\n  [139, 30],\n  347,\n  c,\n  [32, 31],\n  349,\n  c,\n  [32, 31],\n  351,\n  c,\n  [264, 60]\n])\n}),\ndefaultActions: bda({\n  idx: u([\n  s,\n  [3, 4, 1],\n  s,\n  [12, 19, 1],\n  s,\n  [33, 4, 1],\n  38,\n  42,\n  44,\n  s,\n  [46, 5, 1],\n  55,\n  58,\n  64,\n  65,\n  69,\n  74,\n  77,\n  78,\n  80,\n  s,\n  [89, 7, 1],\n  97,\n  98,\n  s,\n  [102, 6, 1],\n  109,\n  115,\n  116,\n  118,\n  119,\n  120,\n  s,\n  [122, 6, 1],\n  131,\n  142,\n  143,\n  146,\n  147,\n  s,\n  [148, 4, 2],\n  155,\n  156,\n  158,\n  159,\n  s,\n  [161, 5, 1],\n  170,\n  s,\n  [172, 11, 1],\n  189,\n  190,\n  191,\n  193,\n  194,\n  195,\n  199,\n  218,\n  219,\n  223,\n  231,\n  232,\n  233,\n  235,\n  236,\n  238,\n  239,\n  244,\n  245,\n  s,\n  [247, 4, 1],\n  252,\n  254,\n  258,\n  260,\n  261,\n  262,\n  266,\n  268,\n  s,\n  [283, 4, 1],\n  288,\n  289,\n  s,\n  [296, 4, 1],\n  304,\n  306,\n  s,\n  [308, 4, 1],\n  313,\n  314,\n  316,\n  317,\n  318,\n  325,\n  327,\n  s,\n  [329, 5, 1],\n  335,\n  336,\n  342,\n  343,\n  346,\n  348,\n  s,\n  [350, 4, 1]\n]),\n  goto: u([\n  2,\n  214,\n  216,\n  217,\n  s,\n  [100, 16, 1],\n  140,\n  141,\n  142,\n  119,\n  120,\n  1,\n  215,\n  86,\n  96,\n  145,\n  3,\n  s,\n  [89, 4, 2],\n  218,\n  87,\n  153,\n  155,\n  121,\n  136,\n  99,\n  178,\n  70,\n  16,\n  s,\n  [32, 6, 1],\n  12,\n  13,\n  s,\n  [4, 5, 1],\n  10,\n  9,\n  40,\n  192,\n  194,\n  196,\n  197,\n  s,\n  [183, 6, 1],\n  198,\n  83,\n  97,\n  148,\n  85,\n  38,\n  150,\n  159,\n  154,\n  156,\n  146,\n  117,\n  122,\n  128,\n  130,\n  124,\n  126,\n  131,\n  181,\n  s,\n  [72, 11, 1],\n  22,\n  23,\n  s,\n  [27, 4, 1],\n  11,\n  193,\n  195,\n  199,\n  210,\n  211,\n  212,\n  147,\n  149,\n  161,\n  162,\n  116,\n  123,\n  133,\n  137,\n  139,\n  132,\n  179,\n  71,\n  18,\n  24,\n  20,\n  21,\n  15,\n  165,\n  41,\n  42,\n  43,\n  189,\n  191,\n  84,\n  209,\n  213,\n  158,\n  160,\n  174,\n  170,\n  129,\n  134,\n  180,\n  182,\n  17,\n  19,\n  31,\n  39,\n  190,\n  172,\n  176,\n  169,\n  175,\n  171,\n  69,\n  25,\n  202,\n  203,\n  173,\n  177,\n  205,\n  207,\n  201,\n  204,\n  206,\n  208\n])\n}),\nparseError: function parseError(str, hash, ExceptionClass) {\n    if (hash.recoverable) {\n        if (typeof this.trace === 'function') {\n            this.trace(str);\n        }\n        hash.destroy();             // destroy... well, *almost*!\n    } else {\n        if (typeof this.trace === 'function') {\n            this.trace(str);\n        }\n        if (!ExceptionClass) {\n            ExceptionClass = this.JisonParserError;\n        }\n        throw new ExceptionClass(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this;\n    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)\n    var sstack = new Array(128);        // state stack: stores states (column storage)\n\n    var vstack = new Array(128);        // semantic value stack\n    var lstack = new Array(128);        // location stack\n    var table = this.table;\n    var sp = 0;                         // 'stack pointer': index into the stacks\n    var yyloc;\n    var yytext;\n    \n\n\n    var symbol = 0;\n\n\n\n    var TERROR = this.TERROR;\n    var EOF = this.EOF;\n    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;\n    var NO_ACTION = [0, 354 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];\n\n    var lexer;\n    if (this.__lexer__) {\n        lexer = this.__lexer__;\n    } else {\n        lexer = this.__lexer__ = Object.create(this.lexer);\n    }\n\n    var sharedState_yy = {\n        parseError: undefined,\n        quoteName: undefined,\n        lexer: undefined,\n        parser: undefined,\n        pre_parse: undefined,\n        post_parse: undefined,\n        pre_lex: undefined,\n        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!\n    };\n\n    var ASSERT;\n    if (typeof assert !== 'function') {\n        ASSERT = function JisonAssert(cond, msg) {\n            if (!cond) {\n                throw new Error('assertion failed: ' + (msg || '***'));\n            }\n        };\n    } else {\n        ASSERT = assert;\n    }\n\n    this.yyGetSharedState = function yyGetSharedState() {\n        return sharedState_yy;\n    };\n\n\n    // shallow clone objects, straight copy of simple `src` values\n    // e.g. `lexer.yytext` MAY be a complex value object,\n    // rather than a simple string/value.\n    function shallow_copy(src) {\n        if (typeof src === 'object') {\n            var dst = {};\n            for (var k in src) {\n                if (Object.prototype.hasOwnProperty.call(src, k)) {\n                    dst[k] = src[k];\n                }\n            }\n            return dst;\n        }\n        return src;\n    }\n    function shallow_copy_noclobber(dst, src) {\n        for (var k in src) {\n            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {\n                dst[k] = src[k];\n            }\n        }\n    }\n    function copy_yylloc(loc) {\n        var rv = shallow_copy(loc);\n        if (rv && rv.range) {\n            rv.range = rv.range.slice(0);\n        }\n        return rv;\n    }\n\n    // copy state\n    shallow_copy_noclobber(sharedState_yy, this.yy);\n\n    sharedState_yy.lexer = lexer;\n    sharedState_yy.parser = this;\n\n\n\n\n\n\n    // Does the shared state override the default `parseError` that already comes with this instance?\n    if (typeof sharedState_yy.parseError === 'function') {\n        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {\n            if (!ExceptionClass) {\n                ExceptionClass = this.JisonParserError;\n            }\n            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);\n        };\n    } else {\n        this.parseError = this.originalParseError;\n    }\n\n    // Does the shared state override the default `quoteName` that already comes with this instance?\n    if (typeof sharedState_yy.quoteName === 'function') {\n        this.quoteName = function quoteNameAlt(id_str) {\n            return sharedState_yy.quoteName.call(this, id_str);\n        };\n    } else {\n        this.quoteName = this.originalQuoteName;\n    }\n\n    // set up the cleanup function; make it an API so that external code can re-use this one in case of\n    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which\n    // case this parse() API method doesn't come with a `finally { ... }` block any more!\n    //\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `sharedState`, etc. references will be *wrong*!\n    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {\n        var rv;\n\n        if (invoke_post_methods) {\n            var hash;\n\n            if (sharedState_yy.post_parse || this.post_parse) {\n                // create an error hash info instance: we re-use this API in a **non-error situation**\n                // as this one delivers all parser internals ready for access by userland code.\n                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);\n            }\n\n            if (sharedState_yy.post_parse) {\n                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== 'undefined') resultValue = rv;\n            }\n            if (this.post_parse) {\n                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== 'undefined') resultValue = rv;\n            }\n\n            // cleanup:\n            if (hash && hash.destroy) {\n                hash.destroy();\n            }\n        }\n\n        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.\n\n        // clean up the lingering lexer structures as well:\n        if (lexer.cleanupAfterLex) {\n            lexer.cleanupAfterLex(do_not_nuke_errorinfos);\n        }\n\n        // prevent lingering circular references from causing memory leaks:\n        if (sharedState_yy) {\n            sharedState_yy.lexer = undefined;\n            sharedState_yy.parser = undefined;\n            if (lexer.yy === sharedState_yy) {\n                lexer.yy = undefined;\n            }\n        }\n        sharedState_yy = undefined;\n        this.parseError = this.originalParseError;\n        this.quoteName = this.originalQuoteName;\n\n        // nuke the vstack[] array at least as that one will still reference obsoleted user values.\n        // To be safe, we nuke the other internal stack columns as well...\n        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC\n        sstack.length = 0;\n        lstack.length = 0;\n        vstack.length = 0;\n        sp = 0;\n\n        // nuke the error hash info instances created during this run.\n        // Userland code must COPY any data/references\n        // in the error hash instance(s) it is more permanently interested in.\n        if (!do_not_nuke_errorinfos) {\n            for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n                var el = this.__error_infos[i];\n                if (el && typeof el.destroy === 'function') {\n                    el.destroy();\n                }\n            }\n            this.__error_infos.length = 0;\n\n\n        }\n\n        return resultValue;\n    };\n\n    // merge yylloc info into a new yylloc instance.\n    //\n    // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.\n    //\n    // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which\n    // case these override the corresponding first/last indexes.\n    //\n    // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search\n    // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)\n    // yylloc info.\n    //\n    // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.\n    this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {\n        var i1 = first_index | 0,\n            i2 = last_index | 0;\n        var l1 = first_yylloc,\n            l2 = last_yylloc;\n        var rv;\n\n        // rules:\n        // - first/last yylloc entries override first/last indexes\n\n        if (!l1) {\n            if (first_index != null) {\n                for (var i = i1; i <= i2; i++) {\n                    l1 = lstack[i];\n                    if (l1) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (!l2) {\n            if (last_index != null) {\n                for (var i = i2; i >= i1; i--) {\n                    l2 = lstack[i];\n                    if (l2) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        // - detect if an epsilon rule is being processed and act accordingly:\n        if (!l1 && first_index == null) {\n            // epsilon rule span merger. With optional look-ahead in l2.\n            if (!dont_look_back) {\n                for (var i = (i1 || sp) - 1; i >= 0; i--) {\n                    l1 = lstack[i];\n                    if (l1) {\n                        break;\n                    }\n                }\n            }\n            if (!l1) {\n                if (!l2) {\n                    // when we still don't have any valid yylloc info, we're looking at an epsilon rule\n                    // without look-ahead and no preceding terms and/or `dont_look_back` set:\n                    // in that case we ca do nothing but return NULL/UNDEFINED:\n                    return undefined;\n                } else {\n                    // shallow-copy L2: after all, we MAY be looking\n                    // at unconventional yylloc info objects...\n                    rv = shallow_copy(l2);\n                    if (rv.range) {\n                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n                        rv.range = rv.range.slice(0);\n                    }\n                    return rv;\n                }\n            } else {\n                // shallow-copy L1, then adjust first col/row 1 column past the end.\n                rv = shallow_copy(l1);\n                rv.first_line = rv.last_line;\n                rv.first_column = rv.last_column;\n                if (rv.range) {\n                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n                    rv.range = rv.range.slice(0);\n                    rv.range[0] = rv.range[1];\n                }\n\n                if (l2) {\n                    // shallow-mixin L2, then adjust last col/row accordingly.\n                    shallow_copy_noclobber(rv, l2);\n                    rv.last_line = l2.last_line;\n                    rv.last_column = l2.last_column;\n                    if (rv.range && l2.range) {\n                        rv.range[1] = l2.range[1];\n                    }\n                }\n                return rv;\n            }\n        }\n\n        if (!l1) {\n            l1 = l2;\n            l2 = null;\n        }\n        if (!l1) {\n            return undefined;\n        }\n\n        // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking\n        // at unconventional yylloc info objects...\n        rv = shallow_copy(l1);\n\n        // first_line: ...,\n        // first_column: ...,\n        // last_line: ...,\n        // last_column: ...,\n        if (rv.range) {\n            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n            rv.range = rv.range.slice(0);\n        }\n\n        if (l2) {\n            shallow_copy_noclobber(rv, l2);\n            rv.last_line = l2.last_line;\n            rv.last_column = l2.last_column;\n            if (rv.range && l2.range) {\n                rv.range[1] = l2.range[1];\n            }\n        }\n\n        return rv;\n    };\n\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!\n    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {\n        var pei = {\n            errStr: msg,\n            exception: ex,\n            text: lexer.match,\n            value: lexer.yytext,\n            token: this.describeSymbol(symbol) || symbol,\n            token_id: symbol,\n            line: lexer.yylineno,\n            loc: copy_yylloc(lexer.yylloc),\n            expected: expected,\n            recoverable: recoverable,\n            state: state,\n            action: action,\n            new_state: newState,\n            symbol_stack: stack,\n            state_stack: sstack,\n            value_stack: vstack,\n            location_stack: lstack,\n            stack_pointer: sp,\n            yy: sharedState_yy,\n            lexer: lexer,\n            parser: this,\n\n            // and make sure the error info doesn't stay due to potential\n            // ref cycle via userland code manipulations.\n            // These would otherwise all be memory leak opportunities!\n            //\n            // Note that only array and object references are nuked as those\n            // constitute the set of elements which can produce a cyclic ref.\n            // The rest of the members is kept intact as they are harmless.\n            destroy: function destructParseErrorInfo() {\n                // remove cyclic references added to error info:\n                // info.yy = null;\n                // info.lexer = null;\n                // info.value = null;\n                // info.value_stack = null;\n                // ...\n                var rec = !!this.recoverable;\n                for (var key in this) {\n                    if (this.hasOwnProperty(key) && typeof key === 'object') {\n                        this[key] = undefined;\n                    }\n                }\n                this.recoverable = rec;\n            }\n        };\n        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n        this.__error_infos.push(pei);\n        return pei;\n    };\n\n\n\n\n\n\n\n\n\n\n\n\n\n    function getNonTerminalFromCode(symbol) {\n        var tokenName = self.getSymbolName(symbol);\n        if (!tokenName) {\n            tokenName = symbol;\n        }\n        return tokenName;\n    }\n\n\n    function stdLex() {\n        var token = lexer.lex();\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    function fastLex() {\n        var token = lexer.fastLex();\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    var lex = stdLex;\n\n\n    var state, action, r, t;\n    var yyval = {\n        $: true,\n        _$: undefined,\n        yy: sharedState_yy\n    };\n    var p;\n    var yyrulelen;\n    var this_production;\n    var newState;\n    var retval = false;\n\n\n    try {\n        this.__reentrant_call_depth++;\n\n        lexer.setInput(input, sharedState_yy);\n\n        // NOTE: we *assume* no lexer pre/post handlers are set up *after* \n        // this initial `setInput()` call: hence we can now check and decide\n        // whether we'll go with the standard, slower, lex() API or the\n        // `fast_lex()` one:\n        if (typeof lexer.canIUse === 'function') {\n            var lexerInfo = lexer.canIUse();\n            if (lexerInfo.fastLex && typeof fastLex === 'function') {\n                lex = fastLex;\n            }\n        } \n\n        yyloc = lexer.yylloc;\n        lstack[sp] = yyloc;\n        vstack[sp] = null;\n        sstack[sp] = 0;\n        stack[sp] = 0;\n        ++sp;\n\n        yytext = lexer.yytext;\n\n\n\n        if (this.pre_parse) {\n            this.pre_parse.call(this, sharedState_yy);\n        }\n        if (sharedState_yy.pre_parse) {\n            sharedState_yy.pre_parse.call(this, sharedState_yy);\n        }\n\n        newState = sstack[sp - 1];\n        for (;;) {\n            // retrieve state number from top of stack\n            state = newState;               // sstack[sp - 1];\n\n            // use default actions if available\n            if (this.defaultActions[state]) {\n                action = 2;\n                newState = this.defaultActions[state];\n            } else {\n                // The single `==` condition below covers both these `===` comparisons in a single\n                // operation:\n                //\n                //     if (symbol === null || typeof symbol === 'undefined') ...\n                if (!symbol) {\n                    symbol = lex();\n                }\n                // read action for current state and first input\n                t = (table[state] && table[state][symbol]) || NO_ACTION;\n                newState = t[1];\n                action = t[0];\n\n\n\n\n\n\n\n\n\n\n\n                // handle parse error\n                if (!action) {\n                    var errStr;\n                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);\n                    var expected = this.collect_expected_token_set(state);\n\n                    // Report error\n                    if (typeof lexer.yylineno === 'number') {\n                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';\n                    } else {\n                        errStr = 'Parse error: ';\n                    }\n                    if (typeof lexer.showPosition === 'function') {\n                        errStr += '\\n' + lexer.showPosition(79 - 10, 10) + '\\n';\n                    }\n                    if (expected.length) {\n                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;\n                    } else {\n                        errStr += 'Unexpected ' + errSymbolDescr;\n                    }\n                    // we cannot recover from the error!\n                    p = this.constructParseErrorInfo(errStr, null, expected, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== 'undefined') {\n                        retval = r;\n                    }\n                    break;\n                }\n\n\n            }\n\n\n\n\n\n\n\n\n\n\n            switch (action) {\n            // catch misc. parse failures:\n            default:\n                // this shouldn't happen, unless resolve defaults are off\n                if (action instanceof Array) {\n                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== 'undefined') {\n                        retval = r;\n                    }\n                    break;\n                }\n                // Another case of better safe than sorry: in case state transitions come out of another error recovery process\n                // or a buggy LUT (LookUp Table):\n                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);\n                r = this.parseError(p.errStr, p, this.JisonParserError);\n                if (typeof r !== 'undefined') {\n                    retval = r;\n                }\n                break;\n\n            // shift:\n            case 1:\n                stack[sp] = symbol;\n                vstack[sp] = lexer.yytext;\n                lstack[sp] = copy_yylloc(lexer.yylloc);\n                sstack[sp] = newState; // push state\n\n                ++sp;\n                symbol = 0;\n\n\n\n\n                // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:\n\n                yytext = lexer.yytext;\n\n                yyloc = lexer.yylloc;\n                continue;\n\n            // reduce:\n            case 2:\n\n\n\n                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\n                yyrulelen = this_production[1];\n\n\n\n\n\n\n\n\n\n\n                r = this.performAction.call(yyval, yytext, yyloc, newState, sp - 1, vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    retval = r;\n                    break;\n                }\n\n                // pop off stack\n                sp -= yyrulelen;\n\n                // don't overwrite the `symbol` variable: use a local var to speed things up:\n                var ntsymbol = this_production[0];    // push nonterminal (reduce)\n                stack[sp] = ntsymbol;\n                vstack[sp] = yyval.$;\n                lstack[sp] = yyval._$;\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[sstack[sp - 1]][ntsymbol];\n                sstack[sp] = newState;\n                ++sp;\n\n\n\n\n\n\n\n\n\n                continue;\n\n            // accept:\n            case 3:\n                if (sp !== -2) {\n                    retval = true;\n                    // Return the `$accept` rule's `$$` result, if available.\n                    //\n                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,\n                    // default, action):\n                    //\n                    //     $accept: <startSymbol> $end\n                    //                  %{ $$ = $1; @$ = @1; %}\n                    //\n                    // which, combined with the parse kernel's `$accept` state behaviour coded below,\n                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,\n                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)\n                    //\n                    // In code:\n                    //\n                    //                  %{\n                    //                      @$ = @1;            // if location tracking support is included\n                    //                      if (typeof $1 !== 'undefined')\n                    //                          return $1;\n                    //                      else\n                    //                          return true;           // the default parse result if the rule actions don't produce anything\n                    //                  %}\n                    sp--;\n                    if (typeof vstack[sp] !== 'undefined') {\n                        retval = vstack[sp];\n                    }\n                }\n                break;\n            }\n\n            // break out of loop: we accept or fail with error\n            break;\n        }\n    } catch (ex) {\n        // report exceptions through the parseError callback too, but keep the exception intact\n        // if it is a known parser or lexer error which has been thrown by parseError() already:\n        if (ex instanceof this.JisonParserError) {\n            throw ex;\n        }\n        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {\n            throw ex;\n        }\n\n        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);\n        retval = false;\n        r = this.parseError(p.errStr, p, this.JisonParserError);\n        if (typeof r !== 'undefined') {\n            retval = r;\n        }\n    } finally {\n        retval = this.cleanupAfterParse(retval, true, true);\n        this.__reentrant_call_depth--;\n    }   // /finally\n\n    return retval;\n}\n};\nparser.originalParseError = parser.parseError;\nparser.originalQuoteName = parser.quoteName;\n\nconst t = require(\"../parsetree\");\n\nfunction Parser() {\n  this.yy = {};\n}\nParser.prototype = parser;\nparser.Parser = Parser;\n\nreturn new Parser();\n})();\n\n        \n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\n  exports.parser = c_grammar;\n  exports.Parser = c_grammar.Parser;\n  exports.parse = function () {\n    return c_grammar.parse.apply(c_grammar, arguments);\n  };\n  \n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module\n__webpack_require__(4156);\n// This entry module used 'exports' so it can't be inlined\n"],"sourceRoot":""}