{"version":3,"sources":["webpack://c2wasm/./node_modules/moo/moo.js","webpack://c2wasm/./demos/ctree.ts","webpack://c2wasm/./src/c_error.ts","webpack://c2wasm/./src/parsing/index.ts","webpack://c2wasm/./src/parsing/lexer.ts","webpack://c2wasm/./src/parsing/parser.ts","webpack://c2wasm/./src/parsing/parsetree.ts","webpack://c2wasm/./src/parsing/validation.ts","webpack://c2wasm/./src/tree/declarations.ts","webpack://c2wasm/./src/tree/expressions.ts","webpack://c2wasm/./src/tree/index.ts","webpack://c2wasm/./src/tree/internal_scope.ts","webpack://c2wasm/./src/tree/scope.ts","webpack://c2wasm/./src/tree/statements.ts","webpack://c2wasm/./src/tree/transform/constant_expressions.ts","webpack://c2wasm/./src/tree/transform/expr_transform.ts","webpack://c2wasm/./src/tree/transform/transform.ts","webpack://c2wasm/./src/tree/transform/type_transform.ts","webpack://c2wasm/./src/tree/type_checking.ts","webpack://c2wasm/./src/tree/types.ts","webpack://c2wasm/./src/parsing/gen/c_grammar.js","webpack://c2wasm/webpack/bootstrap","webpack://c2wasm/webpack/startup"],"names":["hasOwnProperty","Object","prototype","toString","hasSticky","RegExp","sticky","isRegExp","o","call","isObject","Array","isArray","reEscape","s","replace","reGroups","exec","length","reCapture","reUnion","regexps","map","join","regexpOrLiteral","obj","ignoreCase","Error","global","multiline","source","objectToRules","object","keys","getOwnPropertyNames","result","i","key","thing","rules","concat","match","forEach","rule","push","ruleOptions","j","include","arrayToRules","array","type","JSON","stringify","options","defaultType","lineBreaks","error","fallback","pop","next","value","shouldThrow","sort","a","b","toRules","spec","defaultErrorRule","compileRules","hasStates","errorRule","fast","create","fastAllowed","unicodeFlag","groups","parts","slice","shift","charCodeAt","unicode","pat","regexp","test","fallbackRule","flags","suffix","compile","Lexer","start","checkStateGroup","g","name","state","compileStates","states","all","$all","ruleMap","included","splice","newRules","k","newRule","indexOf","apply","fastKeys","keywordTransform","reverseMap","byLength","types","tokenType","item","keyword","str","x","keywords","Function","this","startState","buffer","stack","reset","data","info","index","line","col","queuedToken","queuedThrow","setState","save","re","popState","pushState","eat","tokenToString","_getGroup","groupCount","undefined","queuedGroup","token","_token","queuedText","group","charAt","lastIndex","text","offset","matchNL","nl","size","formatError","Symbol","iterator","LexerIterator","lexer","done","message","Math","max","eol","firstLine","substring","clone","has","freeze","testInput","trimStart","currentId","displayedMap","WeakMap","getId","id","get","set","displayObject","parent","li","document","createElement","appendChild","innerHTML","idNew","classList","add","CArithmetic","getPrototypeOf","constructor","qualifier","addEventListener","e","stopPropagation","rect","getBoundingClientRect","clientX","left","clientY","top","toggle","ul","Map","entries","children","remove","update","input","identifiers","window","getElementById","tags","typedefs","errors","ir","innerText","toIR","write","textInput","console","log","CError","node","node2","super","loc","locationString","label","lines","_source","split","first_line","output","lnumDigits","ceil","log10","last_line","outputLine","lnum","padStart","first_column","last_column","ParseNode","ParseTreeValidationError","parse","$comment","IDENTIFIER","fromEntries","toUpperCase","CONSTANT_FLOAT","CONSTANT_HEX","CONSTANT_OCTAL","CONSTANT_INT","CONSTANT_CHAR","STRING_LITERAL","ELLIPSIS","RIGHT_ASSIGN","LEFT_ASSIGN","ADD_ASSIGN","SUB_ASSIGN","MUL_ASSIGN","DIV_ASSIGN","MOD_ASSIGN","AND_ASSIGN","XOR_ASSIGN","OR_ASSIGN","RIGHT_OP","LEFT_OP","INC_OP","DEC_OP","PTR_OP","AND_OP","OR_OP","LE_OP","GE_OP","EQ_OP","NE_OP","$whitespace","tok","nextSourceId","generatedParser","parser","WrappedLexer","yylloc","_sourceId","yylineno","yytext","clear","d","typeInfo","storageList","declarator","list","parsetree","IdentifierDeclarator","body","tree","validate","hash","Expression","_expression","Identifier","Constant","valueType","StringLiteral","UnaryOperations","UnaryExpression","_unaryExpr","BinaryOperations","BinaryExpression","lhs","rhs","_binaryExpr","SizeofExpression","CastExpression","targetType","FunctionCallExpression","fn","args","MemberAccessExpression","pointer","ConditionalExpression","condition","trueValue","falseValue","AssignmentExpression","assignType","ConstantExpression","expr","CustomTypeSpecifier","SpecifierQualifiers","specifierList","qualifierList","specifier","DeclarationSpecifiers","fnSpecifierList","EnumSpecifier","Enumerator","Declaration","InitDeclarator","initializer","exploreInitializer","StructUnionSpecifier","structure","declarations","StructDeclaration","PointerDeclarator","abstractDeclarator","ArrayDeclarator","FunctionDeclarator","variadic","ParameterDeclaration","Pointer","TypeName","AbstractPointerDeclarator","AbstractArrayDeclarator","AbstractFunctionDeclarator","Statement","_statement","IfStatement","expression","ifBody","elseBody","SwitchStatement","CaseStatement","DefaultStatement","CompoundStatement","ExpressionStatement","NoOp","ForLoop","init","WhileLoop","DoWhileLoop","GotoStatement","target","ContinueStatement","BreakStatement","ReturnStatement","FunctionDefinition","validatorMap","nodeList","parents","validator","validators","typeValidation","every","v","getArithmeticType","typeLookup","constExprValidation","n","pt","CVarDeclaration","storage","linkage","declType","_addressUsed","_definition","addressUsed","CVarDefinition","dependencies","CArgument","CFuncDeclaration","fnImport","CFuncImport","declaration","CFuncDefinition","translationUnit","CCompoundStatement","t","CConstant","lvalue","equals","newValue","BOOL","Number","maxValue","minValue","checks","ExpressionTypeError","BigInt","CIdentifier","CFuncType","CArrayPointer","arrayIdentifier","CArray","CPointer","CStringLiteral","U8","CFunctionCall","fnType","asFunction","returnType","parameterTypes","CAssignment","checkAssignmentValid","CMemberAccess","member","pointerType","asPointer","structUnion","asStructOrUnion","memberType","CIncrDecr","op","pos","checkLvalue","asNonFunctionPointer","asArithmeticOrPointer","checkTypeComplete","CSizeof","CSizeT","incomplete","bytes","typeName","CAddressOf","CDereference","CUnaryPlusMinus","bodyType","asArithmetic","integerPromotion","CBitwiseNot","asInteger","S32","CLogicalNot","CCast","CMulDiv","usualArithmeticConversion","CMod","CAddSub","CShift","dir","CRelational","commonType","CEquality","CBitwiseAndOr","CLogicalAndOr","CConditional","CVoid","otherValue","assignmentType","initialAssignment","getQualifier","CStruct","CUnion","hasConstMember","CInitializer","rhsType","_checkAssignmentTypeValid","varType","CComma","_memberTypes","_type","Infinity","typeCheck","members","c","desiredType","changeType","ptTransform","fakeParseNode","INTERNAL_FNS","wasm","U32","wasm_i32","wasm_i64","U64","wasm_f32","Fp32","wasm_f64","Fp64","wasm_ssp","wasm_rload","INTERNAL_SCOPE","Scope","values","addIdentifier","func","tag","_getTag","wantedType","ScopeError","_getId","existing","definition","_getTypedef","statements","scope","CExpressionStatement","CNop","CIf","CForLoop","CWhileLoop","CDoLoop","CGoto","CSwitch","CContinue","loop","CBreak","CReturn","CLabelledStatement","constExpression","extra","staticValue","normalizeType","constInteger","isNaN","bitmask","normalizeValueType","ptExpression","ptConstant","lookupIdentifier","arr","charRegex","unescapeChar","codePointAt","ptUnary","ptBinary","bodyExpr","getType","num","possibleTypes","unsigned","long","toLowerCase","endsWith","S64","parseFloat","startsWith","parseInt","String","fromCharCode","codePoint","ptDeclaration","inFunction","baseType","decl","getDeclaratorType","getDeclaratorName","addTypedef","ptTypedef","assignments","entry","initialValue","ptInitializer","cvar","identifier","ptFunction","cfn","parameterNames","ptCompound","checkReturns","statement","labelledStatement","find","default","ptStatement","p","child","block","cases","evalIntegerConstant","unshift","_compoundBody","ptSwitchBody","labelled","filter","assignment","fileScope","specifiers","singleSpecifier","lookupTag","addTag","CCompoundMember","cEnum","CEnum","nextValue","enumConstant","addQualifier","lookupTypedef","getSpecifierType","ptr","includes","param","actualType","arithmetic","alignment","other","constant","_members","reduce","total","m","_values","S8","U16","S16","constType","setPrototypeOf","_base","t1","t2","copy","idx","check","c_grammar","JisonParserError","msg","stacktrace","defineProperty","enumerable","writable","exception","ex2","captureStackTrace","l","u","rv","trace","yy","hasPartialLrUpgradeOnConflict","errorRecoveryTokenDiscardCount","symbols_","terminals_","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","TERROR","EOF","originalQuoteName","originalParseError","cleanupAfterParse","constructParseErrorInfo","yyMergeLocationInfo","__reentrant_call_depth","__error_infos","__error_recovery_infos","quoteName","id_str","getSymbolName","symbol","describeSymbol","terminal_descriptions_","collect_expected_token_set","do_not_describe","tokenset","state_descriptions_","table","productions_","r","bp","performAction","yyloc","yystate","yysp","yyvstack","yylstack","yyparser","yylexer","$","_$","setLabel","externalDeclaration","len","y","mode","goto","q","z","bt","defaultActions","bda","parseError","ExceptionClass","recoverable","destroy","self","sstack","vstack","lstack","sp","NO_ACTION","__lexer__","sharedState_yy","pre_parse","post_parse","pre_lex","post_lex","shallow_copy","src","dst","shallow_copy_noclobber","copy_yylloc","range","fastLex","assert","yyGetSharedState","resultValue","invoke_post_methods","do_not_nuke_errorinfos","cleanupAfterLex","el","first_index","last_index","first_yylloc","last_yylloc","dont_look_back","i1","i2","l1","l2","ex","expected","pei","errStr","token_id","action","new_state","newState","symbol_stack","state_stack","value_stack","location_stack","stack_pointer","rec","yyrulelen","this_production","lex","yyval","retval","setInput","canIUse","errSymbolDescr","showPosition","ntsymbol","JisonLexerError","Parser","exports","arguments","__webpack_module_cache__","__webpack_require__","moduleId","module","__webpack_modules__"],"mappings":"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ACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,MAEA6B,KAAMomB,EAAE,CACR,EACAjoB,EACA,CAAC,EAAG,GACJie,EACA,CAAC,GAAI,GACL,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLje,EACA,CAAC,EAAG,GACJ,EACAA,EACA,CAAC,EAAG,GACJ,EACA,EACAA,EACA,CAAC,EAAG,GACJie,EACA,CAAC,EAAG,GACJA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJ,EACAA,EACA,CAAC,EAAG,GACJje,EACA,CAAC,EAAG,IACJie,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLje,EACA,CAAC,EAAG,IACJ,EACA,EACAie,EACA,CAAC,IAAK,GACN,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,C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,EAAGA,EAAIuV,EAAGvV,IAAK,CACxB,IAAI0uB,EAAIJ,EAAEtsB,QACV,OAAQ0U,EAAE1U,SACV,KAAK,EACDysB,EAAEC,GAAK,CACHjK,EAAEziB,QACFa,EAAEb,SAEN,MAEJ,KAAK,EACDysB,EAAEC,GAAKztB,EAAEe,QACT,MAEJ,QAEIysB,EAAEC,GAAK,CACH,IAIZxI,EAAGpmB,KAAK2uB,GAEZ,OAAOvI,EAk8EZyI,CAAG,CACRN,IAAKpI,EAAE,CACP,GACA,EACA,GACAjoB,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,IACJ,EACA,EACAA,EACA,CAAC,EAAG,GACJ,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACAA,EACA,CAAC,EAAG,GACJ,GACA,GACA,EACA,GACA,EACA,GACA,GACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,GACA,EACA,GACA,GACA,GACA,GACA,GACAie,EACA,CAAC,GAAI,GACLje,EACA,CAAC,EAAG,GACJ,GACA,EACA,EACA,GACA,GACA,GACAA,EACA,CAAC,EAAG,GACJ,GACA,EACA,GACA,GACA,GACA,GACA,GACA,EACA,EACA,GACAie,EACA,CAAC,GAAI,GACLje,EACA,CAAC,EAAG,GACJ,GACA,GACA,EACA,EACA,EACAA,EACA,CAAC,EAAG,GACJ,GACA,EACAie,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,IAAK,GACN,EACAje,EACA,CAAC,EAAG,GACJie,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,GACA,EACAA,EACA,CAAC,EAAG,GACJje,EACA,CAAC,EAAG,GACJ,EACA,GACA,EACA,EACA,EACA,GACAA,EACA,CAAC,EAAG,IACJ,GACA,GACA,GACA,GACAie,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJje,EACA,CAAC,EAAG,GACJ,GACA,GACA,GACAie,EACA,CAAC,GAAI,GACL,EACA,GACA,GACA,GACA,GACAje,EACA,CAAC,GAAI,GACL,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,EACA,EACA,GACA,EACA,GACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,EACA,GACAie,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,EACA,EACA,EACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACL,EACA,GACA,GACA,EACA,GACAA,EACA,CAAC,IAAK,GACN,GACA,GACA,GACA,GACAje,EACA,CAAC,GAAI,GACL,GACA,GACA,GACAie,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,EACA,EACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,GACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACL,EACA,GACA,EACAA,EACA,CAAC,IAAK,GACNje,EACA,CAAC,GAAI,GACL,GACA,GACA,GACAie,EACA,CAAC,GAAI,GACL,EACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,EACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,EACA,IAEA6Q,OAAQ7G,EAAE,CACV,EACAjoB,EACA,CAAC,GAAI,GAAI,GACT,GACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,EACAie,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,IACA,EACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,KACL,GACA,GACA,GACAA,EACA,CAAC,EAAG,GACJ,EACA,GACA,GACA,GACA,IACA,EACA,GACA,EACA,GACA,GACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,GACA,GACA,IACA,IACA,IACA,EACA,GACA,GACA,GACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLje,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,GACA,GACA,IACA,IACAie,EACA,CAAC,GAAI,IACL,EACAje,EACA,CAAC,EAAG,EAAG,GACP,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACRA,EACA,CAAC,GAAI,GAAI,GACT,IACAie,EACA,CAAC,GAAI,GACLje,EACA,CAAC,GAAI,GAAI,GACTie,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,GACA,GACA,GACAje,EACA,CAAC,GAAI,EAAG,GACRie,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,GACNje,EACA,CAAC,IAAK,EAAG,GACTie,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACA,EACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,IACA,IACAA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,EACA,GACA,EACA,GACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACA,EACA,EACAje,EACA,CAAC,EAAG,EAAG,GACPA,EACA,CAAC,GAAI,GAAI,GACT,GACAA,EACA,CAAC,GAAI,GAAI,GACT,IACAie,EACA,CAAC,GAAI,GACL,GACA,GACA,GACA,GACA,GACAje,EACA,CAAC,EAAG,GAAI,GACRie,EACA,CAAC,GAAI,IACL,GACA,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACNje,EACA,CAAC,GAAI,EAAG,GACRie,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,EACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,GACL,GACA,GACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACP,EACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,KAAM,GACPje,EACA,CAAC,EAAG,GACJie,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,EACA,EACA,EACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACP,IACA,IACAA,EACA,CAAC,IAAK,IACN,EACA,GACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,EACAA,EACA,CAAC,GAAI,IACLje,EACA,CAAC,GAAI,GAAI,GACT,GACA,GACA,GACA,GACAie,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,EACA,EACA,EACAA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,KACNA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACP,IACA,GACA,EACA,GACAje,EACA,CAAC,GAAI,GAAI,GACTie,EACA,CAAC,GAAI,GACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACP,EACA,GACAA,EACA,CAAC,KAAM,GACP,EACA,EACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACN,EACA,EACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACL,EACA,EACAA,EACA,CAAC,KAAM,IACPje,EACA,CAAC,GAAI,EAAG,GACRie,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,IAAK,OAEN7b,KAAM6lB,EAAE,CACRjoB,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,IACJ,EACAie,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLje,EACA,CAAC,EAAG,IACJie,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNje,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,IACJie,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNje,EACA,CAAC,EAAG,IACJie,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNje,EACA,CAAC,EAAG,KACJie,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,GACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNje,EACA,CAAC,EAAG,KACJie,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,IAAK,MAENlZ,MAAOkjB,EAAE,CACT,EACAjoB,EACA,CAAC,EAAG,EAAG,GACP,GACA,GACA,GACA,GACA,GACA,EACAA,EACA,CAAC,EAAG,EAAG,GACPie,EACA,CAAC,GAAI,GACL,GACA,EACA,GACA,GACA,GACA,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,GACAA,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,EAAG,GACJ,GACAA,EACA,CAAC,EAAG,GACJ,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,GACA,GACAje,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACAie,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,IACA,IACA,IACAje,EACA,CAAC,IAAK,EAAG,GACT,GACA,IACA,IACA,GACA,GACAie,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,GACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,GACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,IACA,GACA,IACAA,EACA,CAAC,EAAG,GACJ,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,GACA,GACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAje,EACA,CAAC,IAAK,EAAG,GACT,IACAie,EACA,CAAC,IAAK,IACN,IACA,GACA,IACA,GACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACN,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,EAAG,GACJ,IACAA,EACA,CAAC,IAAK,IACN,IACAje,EACA,CAAC,IAAK,EAAG,GACTie,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,GACA,GACA,IACA,GACAA,EACA,CAAC,GAAI,GACL,GACA,GACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACN,IACA,GACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,KAELsS,KAAMtI,EAAE,CACRjoB,EACA,CAAC,EAAG,IACJA,EACA,CAAC,EAAG,GACJie,EACA,CAAC,GAAI,KACLA,EACA,CAAC,GAAI,GACL,EACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,EAAG,GACJA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLje,EACA,CAAC,EAAG,IACJie,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLje,EACA,CAAC,EAAG,IACJie,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,EAAG,IACJA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACNje,EACA,CAAC,EAAG,KACJie,EACA,CAAC,IAAK,KACNje,EACA,CAAC,EAAG,KACJie,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,KAAM,IACPA,EACA,CAAC,IAAK,KACNje,EACA,CAAC,EAAG,IACJie,EACA,CAAC,IAAK,IACNje,EACA,CAAC,EAAG,OAEJwwB,KAAMvI,EAAE,CACR,EACAjoB,EACA,CAAC,GAAI,GAAI,GACT,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACAie,EACA,CAAC,GAAI,IACL,GACA,GACA,GACA,GACAje,EACA,CAAC,GAAI,GACLie,EACA,CAAC,GAAI,IACLje,EACA,CAAC,GAAI,GACLie,EACA,CAAC,GAAI,IACLje,EACA,CAAC,GAAI,GACLie,EACA,CAAC,GAAI,IACLje,EACA,CAAC,GAAI,GACLie,EACA,CAAC,GAAI,IACL,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACAje,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,GACN,GACA,IACA,GACA,GACA,GACA,GACAA,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,IAAK,IACNie,EACA,CAAC,GAAI,IACL,GACAje,EACA,CAAC,IAAK,GACN,GACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,GACA,GACA,GACAie,EACA,CAAC,GAAI,GACL,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACA,IACAje,EACA,CAAC,IAAK,EAAG,GACTie,EACA,CAAC,IAAK,GACN,GACA,IACA,GACAje,EACA,CAAC,IAAK,GACN,IACA,IACAie,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLje,EACA,CAAC,IAAK,GACN,GACA,IACA,GACA,IACAie,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACLje,EACA,CAAC,IAAK,GACNie,EACA,CAAC,GAAI,IACLje,EACA,CAAC,IAAK,GACNie,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,GACAA,EACA,CAAC,IAAK,IACNje,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GAAI,GACVA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACA,GACA,IACA,GACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACAie,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLje,EACA,CAAC,GAAI,GACL,IACA,GACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLie,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACNje,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACLie,EACA,CAAC,IAAK,GACN,IACAA,EACA,CAAC,IAAK,IACN,GACA,GACAje,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACLie,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,IACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,GACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,GACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,IACA,GACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,KACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,KAAM,GACP,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAje,EACA,CAAC,GAAI,GACL,IACA,GACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLie,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,GACNA,EACA,CAAC,IAAK,IACNje,EACA,CAAC,GAAI,GACL,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,IACL,IACA,IACAA,EACA,CAAC,GAAI,GACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,GAAI,GACL,IACA,GACA,GACA,IACA,IACAA,EACA,CAAC,GAAI,IACLie,EACA,CAAC,IAAK,IACN,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACL,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,IACN,IACA,IACA,IACAA,EACA,CAAC,IAAK,IACNA,EACA,CAAC,GAAI,IACLA,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACA,IACAje,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,IAAK,GACN,IACA,IACAie,EACA,CAAC,IAAK,IACN,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,GAAI,IACL,IACAA,EACA,CAAC,IAAK,QAGR2S,eA5+IQ,SAAa5wB,GAIT,IAHA,IAAIkoB,EAAK,GACLjX,EAAIjR,EAAEonB,IACNviB,EAAI7E,EAAEwwB,KACDlvB,EAAI,EAAG0mB,EAAI/W,EAAE7Q,OAAQkB,EAAI0mB,EAAG1mB,IAAK,CAEtC4mB,EADQjX,EAAE3P,IACFuD,EAAEvD,GAEd,OAAO4mB,EAo+IH2I,CAAI,CAClBzJ,IAAKa,EAAE,CACPjoB,EACA,CAAC,EAAG,EAAG,GACPA,EACA,CAAC,GAAI,GAAI,GACTA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACAA,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,IACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,KAETwwB,KAAMvI,EAAE,CACR,EACA,IACA,IACA,IACAjoB,EACA,CAAC,IAAK,GAAI,GACV,IACA,IACA,IACA,IACA,IACA,EACA,IACA,GACA,GACA,IACA,EACAA,EACA,CAAC,GAAI,EAAG,GACR,IACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,GACA,GACAA,EACA,CAAC,GAAI,EAAG,GACR,GACA,GACAA,EACA,CAAC,EAAG,EAAG,GACP,GACA,EACA,GACA,IACA,IACA,IACA,IACAA,EACA,CAAC,IAAK,EAAG,GACT,IACA,GACA,GACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,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","file":"ctree.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var unicodeFlag = null\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match.slice()\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // Check unicode flag is used everywhere or nowhere\n      for (var j = 0; j < match.length; j++) {\n        var obj = match[j]\n        if (!isRegExp(obj)) {\n          continue\n        }\n\n        if (unicodeFlag === null) {\n          unicodeFlag = obj.unicode\n        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n          throw new Error('If one rule is /u then all must be')\n        }\n      }\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: … ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n\n    if (unicodeFlag === true) flags += \"u\"\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n    var reverseMap = Object.create(null)\n    var byLength = Object.create(null)\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        reverseMap[keyword] = tokenType\n      })\n    }\n\n    // fast string lookup\n    // https://jsperf.com/string-lookups\n    function str(x) { return JSON.stringify(x) }\n    var source = ''\n    source += 'switch (value.length) {\\n'\n    for (var length in byLength) {\n      var keywords = byLength[length]\n      source += 'case ' + length + ':\\n'\n      source += 'switch (value) {\\n'\n      keywords.forEach(function(keyword) {\n        var tokenType = reverseMap[keyword]\n        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n'\n      })\n      source += '}\\n'\n    }\n    source += '}\\n'\n    return Function('value', source) // type\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      throw new Error(this.formatError(token, \"invalid syntax\"))\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    if (token == null) {\n      // An undefined token indicates EOF\n      var text = this.buffer.slice(this.index)\n      var token = {\n        text: text,\n        offset: this.index,\n        lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n        line: this.line,\n        col: this.col,\n      }\n    }\n    var start = Math.max(0, token.offset - token.col + 1)\n    var eol = token.lineBreaks ? token.text.indexOf('\\n') : token.text.length\n    var firstLine = this.buffer.substring(start, token.offset + eol)\n    message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\"\n    message += \"  \" + firstLine + \"\\n\"\n    message += \"  \" + Array(token.col).join(\" \") + \"^\"\n    return message\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n","import {toIR} from \"../src/tree\";\nimport {CArithmetic} from \"../src/tree/types\";\n\nconst testInput = `\nstatic const struct Node {\n  enum NodeType {TYPE_A = 3, TYPE_B} type;\n  char tag[8];\n  struct Node* child;\n} myPair = {TYPE_B, \"testing\"};\n\nint getTag(struct Node *node) {\n  return node->type;\n}\n`.trimStart();\n\nlet currentId = 0;\nlet displayedMap: WeakMap<any, number> = new WeakMap();\n\nfunction getId(obj: object): [id: number, isNew: boolean] {\n    let id = displayedMap.get(obj);\n    if (id === undefined) {\n        id = currentId++;\n        displayedMap.set(obj, id);\n        return [id, true];\n    }\n    return [id, false];\n}\n\nfunction displayObject(parent: HTMLElement, key: string, obj: any): void {\n    const li = document.createElement(\"li\");\n    parent.appendChild(li);\n    if (typeof obj !== \"object\") {\n        li.innerHTML = `<span class=\"key\">${key}:</span> ${obj}`;\n        return;\n    }\n\n    // body for this element\n    const [id, idNew] = getId(obj);\n    li.classList.add(`objID${id}`);\n    if (idNew) li.id = `objID${id}`;\n    li.innerHTML = `<span class=\"key\">${key}:</span> <code>${obj instanceof CArithmetic ? obj.name : Object.getPrototypeOf(obj).constructor.name}</code>`;\n    if (obj instanceof CArithmetic && !(obj as any).qualifier) return; // reduce tree clutter\n\n    if (idNew) {\n        li.innerHTML += ` <span class=\"id\">[${id}]</span>`;\n    } else {\n        li.innerHTML += ` <a class=\"id\" href=\"#objID${id}\">${id}</a>`;\n    }\n\n    // add children\n    if (idNew) {\n        // tree setup\n        li.classList.add(\"expandable\");\n        li.addEventListener(\"click\", e => {\n            e.stopPropagation();\n            const rect = li.getBoundingClientRect();\n            if (e.clientX < rect.left + 20 && e.clientY < rect.top + 20) {\n                li.classList.toggle(\"hidden\");\n            }\n        });\n\n        const ul = document.createElement(\"ul\");\n        li.appendChild(ul);\n\n        if (obj instanceof Map) {\n            for (const [key, value] of obj.entries()) {\n                displayObject(ul, key, value);\n            }\n        } else {\n            for (const [key, value] of Object.entries(obj)) {\n                if (key === \"node\") continue;\n                displayObject(ul, key, value);\n            }\n        }\n\n        if (ul.children.length === 0) {\n            // no children found - remove sublist\n            ul.remove();\n            li.classList.remove(\"expandable\");\n        }\n    }\n}\n\nfunction update(input: string) {\n    const identifiers = window.document.getElementById(\"identifiers\");\n    const tags = window.document.getElementById(\"tags\");\n    const typedefs = window.document.getElementById(\"typedefs\");\n    const errors = window.document.getElementById(\"errors\");\n    if (!identifiers || !tags || !errors || !typedefs) throw new Error(\"Element not found\");\n    identifiers.innerHTML = tags.innerText = typedefs.innerText = \"\";\n    currentId = 0;\n    displayedMap = new WeakMap<any, number>();\n\n    let ir;\n    try {\n        ir = toIR(input);\n    } catch (e) {\n        errors.innerText = e.toString();\n        throw e;\n    }\n\n    errors.innerHTML = \"\";\n    getId(ir);\n    for (const [key, value] of (ir as any).identifiers) {\n        displayObject(identifiers, key, value);\n    }\n    for (const [key, value] of (ir as any).tags) {\n        displayObject(tags, key, value);\n    }\n    for (const [key, value] of (ir as any).typedefs) {\n        displayObject(typedefs, key, value);\n    }\n}\n\n\nif (typeof window !== 'undefined' && window.document) {\n    window.document.write(`\n        <h1>c2wasm ctree</h1>\n        <div>\n            <textarea id=\"textInput\" rows=\"20\" style=\"width: 100%; resize: vertical\">${testInput}</textarea>\n\n            <pre id=\"errors\"></pre>\n            <div id=\"objID0\"></div>\n            <h3>Identifiers:</h3>\n            <ul id=\"identifiers\" class=\"treelist\"></ul>\n            <h3>Tags:</h3>\n            <ul id=\"tags\" class=\"treelist\"></ul>\n            <h3>Typedefs:</h3>\n            <ul id=\"typedefs\" class=\"treelist\"></ul>\n        </div>\n\n        <style>\n            ul.treelist {\n                padding: 0;\n            }\n\n            ul.treelist ul {\n              padding-inline-start: 18px;\n              border-left: 1px dashed black;\n              margin-left: 6px;\n            }\n\n            ul.treelist li {\n              list-style-type: none;\n              position: relative;\n            }\n\n            ul.treelist li::before {\n              content: \"\\\\25BB\";\n              font-size: 0.8em;\n              color: black;\n              user-select: none;\n              pointer-events: auto;\n              display: inline-block;\n              width: 20px;\n            }\n\n            ul.treelist li.expandable::before {\n              content: \"\\\\25BC\";\n              cursor: pointer;\n            }\n\n            ul.treelist li.expandable.hidden::before {\n              content: \"\\\\25B6\";\n              transform: none;\n            }\n\n            ul.treelist li.expandable.hidden ul {\n              display: none;\n            }\n        </style>\n    `);\n\n    const textInput = window.document.getElementById(\"textInput\") as HTMLTextAreaElement;\n    textInput.addEventListener(\"input\", () => update(textInput.value));\n    update(textInput.value);\n} else {\n    console.log(toIR(testInput));\n}\n","import type {Location, ParseNode} from \"./parsing\";\n\nexport class CError extends Error {\n    name = \"CError\";\n\n    constructor(message: string, readonly node?: ParseNode, readonly node2?: ParseNode) {\n        super(message);\n\n        if (node?.loc) {\n            this.message += \"\\n\\n\" + locationString(node.loc);\n            if (node2?.loc) this.message += \"\\n\\n\" + locationString(node2.loc, \"Secondary location\");\n        }\n    }\n}\n\nexport function locationString(loc: Location, label: string = \"Location\"): string {\n    const lines = loc._source.split(\"\\n\");\n    if (loc.first_line >= lines.length) return `${label}: [UNKNOWN]`;\n\n    let output = `${label}:\\n`;\n\n    const lnumDigits = Math.ceil(Math.log10(loc.last_line + 4));\n    function outputLine(lnum: number) {\n        output += `L${(lnum + 1).toString().padStart(lnumDigits, '0')}: ${lines[lnum]}\\n`;\n    }\n\n    if (loc.first_line > 1) outputLine(loc.first_line - 2);\n    if (loc.first_line > 0) outputLine(loc.first_line - 1);\n    outputLine(loc.first_line);\n\n    // output ^^^ arrows\n    output += new Array(3 + lnumDigits + loc.first_column).join(\" \");\n    if (loc.first_line === loc.last_line) {\n        output += new Array(1 + loc.last_column - loc.first_column).join(\"^\");\n    } else {\n        output += \"^\";\n    }\n    output += \"\\n\";\n\n    if (loc.first_line + 1 < lines.length) outputLine(loc.first_line + 1);\n    if (loc.first_line + 2 < lines.length) outputLine(loc.first_line + 2);\n    return output;\n}\n","export * as pt from \"./parsetree\";\nexport {ParseNode, Location} from \"./parsetree\"; // the most common parsetree imports\nexport {ParseTreeValidationError} from \"./validation\";\nexport {parse} from \"./parser\";\n","import moo from \"moo\";\n\nconst keywords = [\n    \"if\", \"break\", \"case\", \"char\", \"const\", \"continue\", \"default\", \"do\", \"double\", \"else\", \"enum\", \"extern\", \"float\",\n    \"for\", \"inline\", \"int\", \"long\", \"return\", \"short\", \"signed\", \"sizeof\", \"static\", \"struct\", \"switch\", \"typedef\",\n    \"union\", \"unsigned\", \"void\", \"while\", \"_Bool\",\n\n    // currently unsupported (but still lex so parser throws error)\n    \"auto\", \"goto\", \"register\", \"volatile\",\n\n    // special for c2wasm, not on spec\n    \"import\"\n];\n\nconst simpleSymbols = [';','{','}',',',':','=','(',')','[',']','.','&','!','~','-','+','*','/','%','<','>','^','|','?'];\n\nexport const lexer = moo.compile({\n    $comment: {match: /(?:\\/\\*[^]*?\\*\\/)|(?:\\/\\/.*?$)/, multiline: true},\n    IDENTIFIER: {\n        match: /[a-zA-Z_][a-zA-Z0-9_]*/,\n        type: moo.keywords(Object.fromEntries(keywords.map(x => [x.toUpperCase(), x])))\n    },\n    CONSTANT_FLOAT: /(?:[0-9]+[Ee][+-]?[0-9]+|(?:[0-9]*\\.[0-9]+|[0-9]+\\.[0-9]*)(?:[Ee][+-]?[0-9]+)?)[fFlL]?|(?:[1-9][0-9]*|0)[fF]/,\n    CONSTANT_HEX: /0[xX][a-fA-F0-9]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    CONSTANT_OCTAL: /0[0-7]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    CONSTANT_INT: /(?:[1-9][0-9]*|0)(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,\n    CONSTANT_CHAR: {match: /'(?:[^\\\\\\n']|\\\\(?:.|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))'/, value: x => x.slice(1, -1)},\n    STRING_LITERAL: {match: /\"(?:[^\\\\\\n\"]|\\\\(?:[^x0-7\\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))*\"/, value: x => x.slice(1, -1)},\n    ELLIPSIS: \"...\",\n    RIGHT_ASSIGN: \">>=\",\n    LEFT_ASSIGN: \"<<=\",\n    ADD_ASSIGN: \"+=\",\n    SUB_ASSIGN: \"-=\",\n    MUL_ASSIGN: \"*=\",\n    DIV_ASSIGN: \"/=\",\n    MOD_ASSIGN: \"%=\",\n    AND_ASSIGN: \"&=\",\n    XOR_ASSIGN: \"^=\",\n    OR_ASSIGN: \"|=\",\n    RIGHT_OP: \">>\",\n    LEFT_OP: \"<<\",\n    INC_OP: \"++\",\n    DEC_OP: \"--\",\n    PTR_OP: \"->\",\n    AND_OP: \"&&\",\n    OR_OP: \"||\",\n    LE_OP: \"<=\",\n    GE_OP: \">=\",\n    EQ_OP: \"==\",\n    NE_OP: \"!=\",\n    ...Object.fromEntries(simpleSymbols.map(x => [x,x])),\n    $whitespace: [\n        {match: /[ \\t\\v\\f]+/},\n        {match: /\\n/, lineBreaks: true},\n    ],\n});\n\n// automatically skip tokens starting with \"$\", i.e. whitespace, line breaks and comments\nlexer.next = (next => () => {\n    let tok = next.call(lexer);\n    while (tok?.type?.charAt(0) === '$') tok = next.call(lexer);\n    return tok;\n})(lexer.next);\n","import {locationString} from \"../c_error\";\nimport {lexer} from \"./lexer\";\nimport gen from \"./gen/c_grammar\";\nimport * as parsetree from \"./parsetree\";\nimport {validate} from \"./validation\";\n\nfunction newLocation(): parsetree.Location {\n    return {first_line: 0, first_column: 0, last_line: 0, last_column: 0, _source: \"\", _sourceId: 0};\n}\nlet nextSourceId: number = 1;\n\n// adapt moo parser to work with Jison\nclass WrappedLexer {\n    yytext?: string;\n    yylloc: parsetree.Location = newLocation();\n    yylineno: number = 0;\n    types = new Map<string, boolean>();\n\n    /** return the token type and update yytext, yylloc, yylineno */\n    lex(): string {\n        const token = lexer.next();\n        this.yytext = token?.value;\n        if (!token || !token.type) {\n            // no more tokens, end of file reached\n            return \"EOF\";\n        }\n\n        this.yylloc = {\n            first_line: token.line - 1,\n            first_column: token.col,\n            last_line: token.line + token.lineBreaks - 1,\n            last_column: token.lineBreaks ? 0 : token.col + token.text.length,\n            _sourceId: this.yylloc._sourceId,\n            _source: this.yylloc._source\n        };\n        this.yylineno = this.yylloc.first_line;\n\n        if (token.type === \"IDENTIFIER\" && this.types.get(token.text)) {\n            return \"TYPE_NAME\";\n        }\n        return token.type;\n    }\n\n    setInput(input: string): void {\n        // completely reset all state\n        this.yylloc = newLocation();\n        this.yylineno = 0;\n        this.yytext = undefined;\n        this.types.clear();\n\n        lexer.reset(input);\n        this.yylloc._source = input; // store source on the parser tokens, allowing error information to be easily printed\n        this.yylloc._sourceId = nextSourceId++; // identifier which can be used to check if tokens are from the same file\n    }\n\n    externalDeclaration(d: parsetree.Declaration) {\n        if (d.typeInfo.storageList[0] !== \"typedef\") return;\n\n        for (let declarator of d.list) {\n            while (!(declarator instanceof parsetree.IdentifierDeclarator)) declarator = declarator.body;\n            this.types.set(declarator.id, true);\n        }\n    }\n}\n\n// provide the generated parser with our custom lexer\nconst generatedParser = gen as any;\ngeneratedParser.parser.lexer = new WrappedLexer();\n\n/**\n * Parse the input string into a parse tree and perform some basic validation\n */\nexport function parse(input: string): parsetree.TranslationUnit {\n    try {\n        const tree = generatedParser.parse(input);\n        return validate(tree);\n    } catch (e) {\n        if (e?.hash?.loc) { // Jison parse errors\n            e.message += \"\\n\\n\" + locationString(e.hash?.loc);\n        }\n        throw e;\n    }\n}\n","export type Location = {\n    first_line: number, last_line: number, first_column: number, last_column: number,\n    _source: string, _sourceId: number // hidden attributes for error printing\n};\n\n// Classes used to build up the C parse tree - mostly just simple objects storing the relevant fields.\n\nexport abstract class ParseNode {\n    abstract readonly type: string;\n\n    constructor(readonly loc: Location) {\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        // return any children of the node\n    }\n}\n\n// Expressions\n\nexport abstract class Expression extends ParseNode {\n    // typescript does structural equality when type checking, so for this class to be different from\n    // the base ParseNode add a simple private field.\n    private readonly _expression: boolean = true;\n}\n\nexport class Identifier extends Expression {\n    readonly type = \"identifier\";\n\n    constructor(loc: Location, readonly name: string) {\n        super(loc);\n    }\n}\n\nexport class Constant extends Expression {\n    readonly type = \"constant\";\n\n    constructor(loc: Location, readonly value: string, readonly valueType: \"float\" | \"char\" | \"int\" | \"oct\" | \"hex\") {\n        super(loc);\n    }\n}\n\nexport class StringLiteral extends Expression {\n    readonly type = \"stringLiteral\";\n\n    constructor(loc: Location, readonly value: string) {\n        super(loc);\n    }\n}\n\nexport const UnaryOperations = [\n    \"postfixIncrement\", \"postfixDecrement\", \"prefixIncrement\", \"prefixDecrement\",\n    \"addressOf\", \"dereference\", \"unaryPlus\", \"unaryMinus\", \"bitwiseNot\", \"logicalNot\"] as const;\nexport type UnaryOp = typeof UnaryOperations[number];\nexport class UnaryExpression extends Expression {\n    private readonly _unaryExpr = true;\n\n    constructor(loc: Location, readonly type: UnaryOp, readonly body: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport const BinaryOperations = [\"arraySubscript\", \"comma\",\n    \"mul\", \"div\", \"mod\", \"add\", \"sub\", \"bitwiseShiftLeft\", \"bitwiseShiftRight\",\n    \"relationalLT\", \"relationalGT\", \"relationalLEq\", \"relationalGEq\", \"relationalEq\", \"relationalNEq\",\n    \"bitwiseAnd\", \"bitwiseXor\", \"bitwiseOr\", \"logicalAnd\", \"logicalOr\"] as const;\nexport type BinaryOp = typeof BinaryOperations[number];\nexport class BinaryExpression extends Expression {\n    private readonly _binaryExpr = true;\n\n    constructor(loc: Location, readonly type: BinaryOp, readonly lhs: Expression, readonly rhs: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n        yield this.rhs;\n    }\n}\n\nexport class SizeofExpression extends Expression {\n    readonly type = \"sizeof\";\n\n    constructor(loc: Location, readonly body: Expression | TypeName) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport class CastExpression extends Expression {\n    readonly type = \"cast\";\n\n    constructor(loc: Location, readonly targetType: TypeName, readonly body: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.targetType;\n        yield this.body;\n    }\n}\n\nexport class FunctionCallExpression extends Expression {\n    readonly type = \"functionCall\";\n\n    constructor(loc: Location, readonly fn: Expression, readonly args: ReadonlyArray<Expression> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.fn;\n        yield* this.args;\n    }\n}\n\nexport class MemberAccessExpression extends Expression {\n    readonly type = \"access\";\n\n    constructor(loc: Location, readonly pointer: boolean, readonly lhs: Expression, readonly rhs: string) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n    }\n}\n\nexport class ConditionalExpression extends Expression {\n    readonly type = \"conditional\";\n\n    constructor(loc: Location, readonly condition: Expression, readonly trueValue: Expression, readonly falseValue: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.condition;\n        yield this.trueValue;\n        yield this.falseValue;\n    }\n}\n\nexport type AssignmentType = undefined | \"mul\" | \"div\" | \"mod\" | \"add\" | \"sub\" | \"leftShift\"| \"rightShift\" | \"bitwiseAnd\" | \"bitwiseXor\" | \"bitwiseOr\";\nexport class AssignmentExpression extends Expression {\n    readonly type = \"assign\";\n\n    constructor(loc: Location, readonly assignType: AssignmentType, readonly lhs: Expression, readonly rhs: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.lhs;\n        yield this.rhs;\n    }\n}\n\nexport class ConstantExpression extends Expression {\n    readonly type = \"constantExpr\";\n\n    constructor(loc: Location, readonly expr: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expr;\n    }\n}\n\n// Declarations\nexport class CustomTypeSpecifier extends ParseNode {\n    readonly type = \"customType\";\n\n    public constructor(loc: Location, readonly name: string) {\n        super(loc);\n    }\n}\n\nexport type StorageClass = \"typedef\" | \"extern\" | \"static\"; // | \"auto\" | \"register\";\nexport type TypeSpecifier =\n    \"void\" | \"char\" | \"short\" | \"int\" | \"long\" | \"float\" | \"double\" | \"signed\" | \"unsigned\" | \"bool\" // | \"complex\" | \"imaginary\"]\n    | StructUnionSpecifier\n    | EnumSpecifier\n    | CustomTypeSpecifier;\nexport type TypeQualifier = \"const\"; // | \"restrict\" | \"volatile\";\nexport type FnSpecifier = \"import\" | \"inline\";\n\nexport class SpecifierQualifiers extends ParseNode {\n    readonly type = \"specifiersAndQualifiers\";\n\n    constructor(loc: Location,\n                readonly specifierList: ReadonlyArray<TypeSpecifier>,\n                readonly qualifierList: ReadonlyArray<TypeQualifier>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        for (const specifier of this.specifierList) {\n            if (specifier instanceof ParseNode) yield specifier;\n        }\n    }\n}\n\nexport class DeclarationSpecifiers extends ParseNode {\n    readonly type = \"declarationSpecifiers\";\n\n    constructor(loc: Location,\n                readonly specifierList: ReadonlyArray<TypeSpecifier>,\n                readonly qualifierList: ReadonlyArray<TypeQualifier>,\n                readonly storageList: ReadonlyArray<StorageClass>,\n                readonly fnSpecifierList: ReadonlyArray<FnSpecifier>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        for (const specifier of this.specifierList) {\n            if (specifier instanceof ParseNode) yield specifier;\n        }\n    }\n}\n\nexport class EnumSpecifier extends ParseNode {\n    type = \"enum\";\n\n    constructor(loc: Location, readonly id?: string, readonly body?: ReadonlyArray<Enumerator>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield* this.body;\n    }\n}\n\nexport class Enumerator extends ParseNode {\n    type = \"enumerator\";\n\n    constructor(loc: Location, readonly id: string, readonly value?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.value) yield this.value;\n    }\n}\n\nexport class Declaration extends ParseNode{\n    readonly type = \"declaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly list: ReadonlyArray<Declarator | InitDeclarator> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield* this.list;\n    }\n}\n\nexport class InitDeclarator extends ParseNode {\n    readonly type= \"initDeclarator\";\n\n    constructor(loc: Location, readonly body: Declarator, readonly initializer: Initializer) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        yield* this.exploreInitializer();\n    }\n\n    private *exploreInitializer(initializer: Initializer = this.initializer): Iterable<ParseNode> {\n        if (initializer instanceof AssignmentExpression) {\n            yield initializer;\n        } else if (Array.isArray(initializer)) {\n            for (const x of initializer) yield* this.exploreInitializer(x);\n        }\n    }\n}\n\nexport class StructUnionSpecifier extends ParseNode {\n    readonly type = \"structUnionSpecifier\";\n\n    constructor(loc: Location, readonly structure: \"struct\" | \"union\", readonly id?: string, readonly declarations?: ReadonlyArray<StructDeclaration>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.declarations) yield* this.declarations;\n    }\n}\n\nexport class StructDeclaration extends ParseNode {\n    readonly type= \"structDeclaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly list: ReadonlyArray<Declarator> = []) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield* this.list;\n    }\n}\n\nexport type Declarator = PointerDeclarator | IdentifierDeclarator | ArrayDeclarator | FunctionDeclarator;\n\nexport class PointerDeclarator extends ParseNode {\n    readonly type= \"pointerDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly pointer: Pointer, readonly body: Declarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.pointer;\n        yield this.body;\n    }\n}\n\nexport class IdentifierDeclarator extends ParseNode {\n    readonly type= \"identifierDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly id: string) {\n        super(loc);\n    }\n}\n\nexport class ArrayDeclarator extends ParseNode {\n    readonly type= \"arrayDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly body: Declarator, readonly length?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        if (this.length) yield this.length;\n    }\n}\n\nexport class FunctionDeclarator extends ParseNode {\n    readonly type= \"functionDeclarator\";\n    readonly abstractDeclarator = false;\n\n    constructor(loc: Location, readonly body: Declarator, readonly args?: ReadonlyArray<ParameterDeclaration>, readonly variadic: boolean = false) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        for (const value of this.args ?? []) {\n            if (value instanceof ParseNode) yield value;\n        }\n    }\n}\n\nexport class ParameterDeclaration extends ParseNode {\n    readonly type= \"parameterDeclaration\";\n\n    constructor(loc: Location, readonly typeInfo: DeclarationSpecifiers, readonly declarator?: Declarator | AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        if (this.declarator) yield this.declarator;\n    }\n}\n\nexport class Pointer extends ParseNode {\n    readonly type= \"pointer\";\n\n    constructor(loc: Location, readonly qualifierList?: ReadonlyArray<TypeQualifier>, readonly body?: Pointer) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n    }\n}\n\nexport class TypeName extends ParseNode {\n    readonly type= \"typeName\";\n\n    constructor(loc: Location, readonly typeInfo: SpecifierQualifiers, readonly declarator?: AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        if (this.declarator) yield this.declarator;\n    }\n}\n\nexport type AbstractDeclarator = AbstractPointerDeclarator | AbstractArrayDeclarator | AbstractFunctionDeclarator;\n\nexport class AbstractPointerDeclarator extends ParseNode {\n    readonly type= \"abstractPointerDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly pointer: Pointer, readonly body?: AbstractDeclarator) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.pointer;\n        if (this.body) yield this.body;\n    }\n}\n\nexport class AbstractArrayDeclarator extends ParseNode {\n    readonly type= \"abstractArrayDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly body?: AbstractDeclarator, readonly length?: ConstantExpression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n        if (this.length) yield this.length;\n    }\n}\n\nexport class AbstractFunctionDeclarator extends ParseNode {\n    readonly type= \"abstractFunctionDeclarator\";\n    readonly abstractDeclarator = true;\n\n    constructor(loc: Location, readonly body?: AbstractDeclarator, readonly args?: ReadonlyArray<ParameterDeclaration>, readonly variadic: boolean = false) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.body) yield this.body;\n        if (this.args) yield* this.args;\n    }\n}\n\nexport type Initializer = Expression | ReadonlyArray<Initializer>;\n\n// Statements\n\nexport abstract class Statement extends ParseNode {\n    private readonly _statement: boolean = true;\n    label?: string;\n\n    setLabel(label: string): this {\n        this.label = label;\n        return this;\n    }\n}\n\nexport class IfStatement extends Statement {\n    readonly type = \"ifStatement\";\n\n    constructor(loc: Location, readonly expression: Expression, readonly ifBody: Statement, readonly elseBody?: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n        yield this.ifBody;\n        if (this.elseBody) yield this.elseBody;\n    }\n}\n\nexport class SwitchStatement extends Statement {\n    readonly type = \"switchStatement\";\n\n    constructor(loc: Location, readonly expression: Expression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n        yield this.body;\n    }\n}\n\nexport class CaseStatement extends Statement {\n    readonly type = \"caseStatement\";\n\n    constructor(loc: Location, readonly value: ConstantExpression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.value;\n        yield this.body;\n    }\n}\n\nexport class DefaultStatement extends Statement {\n    readonly type = \"defaultStatement\";\n\n    constructor(loc: Location, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n    }\n}\n\nexport class CompoundStatement extends Statement {\n    readonly type = \"compoundStatement\";\n\n    constructor(loc: Location, readonly body: ReadonlyArray<Statement | Declaration>) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield* this.body;\n    }\n}\n\nexport class ExpressionStatement extends Statement {\n    readonly type = \"expressionStatement\";\n\n    constructor(loc: Location, readonly expression: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.expression;\n    }\n}\n\nexport class NoOp extends Statement {\n    readonly type= \"nopStatement\";\n\n    constructor(loc: Location) {\n        super(loc);\n    }\n}\n\nexport class ForLoop extends Statement {\n    readonly type = \"forStatement\";\n\n    constructor(loc: Location,\n                readonly init: ExpressionStatement | NoOp | Declaration,\n                readonly test: ExpressionStatement | NoOp,\n                readonly update: Expression | undefined,\n                readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.init;\n        yield this.test;\n        if (this.update) yield this.update;\n        yield this.body;\n    }\n}\n\nexport class WhileLoop extends Statement {\n    readonly type = \"whileStatement\";\n\n    constructor(loc: Location, readonly test: Expression, readonly body: Statement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.test;\n        yield this.body;\n    }\n}\n\nexport class DoWhileLoop extends Statement {\n    readonly type = \"doWhileStatement\";\n\n    constructor(loc: Location, readonly body: Statement, readonly test: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.body;\n        yield this.test;\n    }\n}\n\nexport class GotoStatement extends Statement {\n    readonly type = \"gotoStatement\";\n\n    constructor(loc: Location, readonly target: string) {\n        super(loc);\n    }\n}\n\nexport class ContinueStatement extends Statement {\n    readonly type = \"continueStatement\";\n}\n\nexport class BreakStatement extends Statement {\n    readonly type = \"breakStatement\";\n}\n\nexport class ReturnStatement extends Statement {\n    readonly type = \"returnStatement\";\n\n    constructor(loc: Location, readonly value?: Expression) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        if (this.value) yield this.value;\n    }\n}\n\nexport class FunctionDefinition extends ParseNode {\n    readonly type = \"functionDefinition\";\n\n    constructor(loc: Location,\n                readonly typeInfo: DeclarationSpecifiers,\n                readonly declarator: Declarator,\n                readonly body: CompoundStatement) {\n        super(loc);\n    }\n\n    *children(): IterableIterator<ParseNode> {\n        yield this.typeInfo;\n        yield this.declarator;\n        yield this.body;\n    }\n}\n\nexport type TranslationUnit = ReadonlyArray<FunctionDefinition | Declaration>;\n","import {CError} from \"../c_error\";\nimport {getArithmeticType} from \"../tree/types\";\nimport * as pt from \"./parsetree\";\nimport {ParseNode, TypeSpecifier} from \"./parsetree\";\n\nconst validatorMap = new Map<typeof ParseNode, ((node: ParseNode, parents: ParseNode[]) => void)[]>();\n\nexport function validate<T extends Iterable<ParseNode>>(nodeList: T, parents: ParseNode[] = []): T {\n    for (const node of nodeList) {\n        parents.push(node);\n        validate(node.children(), parents);\n        parents.pop();\n\n        for (const validator of validatorMap.get(Object.getPrototypeOf(node).constructor) ?? []) {\n            validator(node, parents);\n        }\n    }\n    return nodeList;\n}\n\nexport class ParseTreeValidationError extends CError {\n    readonly name = \"TreeValidationError\";\n\n    constructor(node: ParseNode | undefined, message: string, node2?: ParseNode) {\n        super(node && node.loc ? `Line ${node.loc.first_line + 1}: ${message}` : message, node, node2);\n    }\n}\n\nfunction validator<T extends ParseNode>(type: { new(...args: any[]): T}, fn: (node: T, parents: ParseNode[]) => void) {\n    const validators = validatorMap.get(type);\n    if (validators) {\n        validators.push(fn as any);\n    } else {\n        validatorMap.set(type, [fn as any]);\n    }\n}\n\n// DeclarationSpecifiers/SpecifierQualifiers validation\nfunction typeLookup(specifierList: ReadonlyArray<pt.TypeSpecifier>, node?: ParseNode) {\n    if (specifierList.every(v => typeof v === 'string')) {\n        if (!getArithmeticType(specifierList as ReadonlyArray<TypeSpecifier & string>)) {\n            throw new ParseTreeValidationError(node, \"Invalid specifiers - \" + specifierList.join(\", \"));\n        }\n    }\n}\n\nconst typeValidation = (d: pt.SpecifierQualifiers | pt.DeclarationSpecifiers) => {\n    if (d.qualifierList.length > 1) throw new ParseTreeValidationError(d, \"Invalid qualifiers.\");\n    typeLookup(d.specifierList, d);\n};\n\nvalidator(pt.SpecifierQualifiers, typeValidation);\nvalidator(pt.DeclarationSpecifiers, typeValidation);\nvalidator(pt.DeclarationSpecifiers, (d, parents) => {\n    if (d.storageList.length > 1) throw new ParseTreeValidationError(d, \"Invalid storage class list.\");\n    if (d.fnSpecifierList.length > 1) throw new ParseTreeValidationError(d, \"Invalid fn specifier list.\");\n\n    if (d.storageList[0] === \"typedef\" && parents.length !== 1) {\n        throw new ParseTreeValidationError(d, \"Nested typedefs are not allowed\");\n    }\n});\n\n// Constant expr validation\nfunction constExprValidation(n: ParseNode, parents: ParseNode[]) {\n    for (let i = parents.length - 1; i >= 0; i--) {\n        if (!(parents[i] instanceof pt.Expression) || parents[i].type === \"sizeof\") return;\n        if (parents[i].type === \"constantExpr\") throw new ParseTreeValidationError(n, \"Invalid constant expr.\");\n    }\n}\n\nvalidator(pt.UnaryExpression, (node, parent) => {\n    switch (node.type) {\n    case \"postfixIncrement\":\n    case \"postfixDecrement\":\n    case \"prefixIncrement\":\n    case \"prefixDecrement\":\n    case \"addressOf\": // If integers are required (believe this is always the case?)\n    case \"dereference\":\n        constExprValidation(node, parent);\n    }\n});\nvalidator(pt.BinaryExpression, (node, parent) => {\n    switch (node.type) {\n    case \"comma\":\n    case \"arraySubscript\": // If int\n        constExprValidation(node, parent);\n    }\n});\nvalidator(pt.FunctionCallExpression, constExprValidation);\n\n// If int\nvalidator(pt.MemberAccessExpression, constExprValidation);\n","import type {FunctionDefinition, ParseNode} from \"../parsing/parsetree\";\nimport type {CInitializer, CExpression} from \"./expressions\";\nimport type {Scope} from \"./scope\";\nimport {CCompoundStatement} from \"./statements\";\nimport type {CFuncType, CNotFuncType, CQualifiedType} from \"./types\";\n\n// classes to represent all the different types of declarations in the IR\nexport type CDeclaration = CVariable | CFunction;\nexport type CVariable = CVarDeclaration | CVarDefinition | CArgument;\nexport type CFunction = CFuncDefinition | CFuncDeclaration;\n\nexport class CVarDeclaration {\n    readonly declType = \"variable\";\n    _addressUsed: boolean = false;\n    _definition?: CVarDefinition;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly storage: \"static\" | \"local\",\n                readonly linkage: \"none\" | \"internal\" | \"external\") {\n    }\n\n    set addressUsed(b: boolean) {\n        if (this._definition) this._definition.addressUsed ||= b;\n        else this._addressUsed ||= b;\n    }\n\n    get addressUsed(): boolean {\n        return this._definition ? this._definition.addressUsed : this._addressUsed;\n    }\n\n    set definition(v: CVarDefinition | undefined) {\n        if (v === undefined) throw new Error(\"Cannot set definition to undefined\");\n        v.addressUsed ||= this._addressUsed;\n        this._definition = v;\n    }\n\n    get definition(): CVarDefinition | undefined {\n        return this._definition;\n    }\n}\n\nexport class CVarDefinition {\n    readonly declType = \"variable\";\n    staticValue?: CExpression | CInitializer;\n    addressUsed: boolean = false;\n    readonly dependencies = new Map<CDeclaration, boolean>(); // direct dependencies of initializer only\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly storage: \"static\" | \"local\",\n                public linkage: \"none\" | \"internal\" | \"external\") {\n    }\n}\n\nexport class CArgument {\n    readonly declType = \"variable\";\n    readonly storage = \"argument\";\n    readonly linkage = \"none\";\n    addressUsed: boolean = false;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CNotFuncType>,\n                readonly index: number) {\n    }\n}\n\nexport class CFuncDeclaration {\n    readonly declType = \"function\";\n    definition?: CFuncDefinition | CFuncImport;\n\n    constructor(readonly node: ParseNode,\n                readonly name: string,\n                readonly type: CQualifiedType<CFuncType>,\n                readonly linkage: \"none\" | \"internal\" | \"external\",\n                public fnImport: boolean = false) {\n    }\n}\n\nexport class CFuncImport {\n    readonly declType = \"import\";\n    readonly node: ParseNode;\n\n    constructor(readonly declaration: CFuncDeclaration) {\n        this.node = declaration.node;\n    }\n\n    getFunction(): CFuncDeclaration {\n        return this.declaration;\n    }\n}\n\nexport class CFuncDefinition {\n    readonly declType = \"function\";\n    readonly body: CCompoundStatement;\n    readonly dependencies = new Map<CDeclaration, boolean>(); // direct dependencies only\n\n    constructor(readonly node: FunctionDefinition,\n                readonly name: string,\n                readonly type: CQualifiedType<CFuncType>,\n                public linkage: \"none\" | \"internal\" | \"external\",\n                readonly translationUnit: Scope) {\n        this.body = new CCompoundStatement(node.body, this);\n    }\n\n    get scope(): Scope {\n        return this.translationUnit;\n    }\n\n    equals(t: object): boolean {\n        return t === this;\n    }\n\n    getFunction(): CFuncDefinition {\n        return this;\n    }\n}\n","import type {ParseNode, pt} from \"../parsing\";\nimport type {CDeclaration, CVariable, CArgument} from \"./declarations\";\nimport * as checks from \"./type_checking\";\nimport {\n    CArithmetic, CType, CArray, CPointer, CUnion, CStruct,\n    CSizeT, usualArithmeticConversion, integerPromotion, CFuncType, CVoid, checkTypeComplete, getQualifier\n} from \"./types\";\n\n// Classes to represent all the possible expression types in the IR\n\nexport type CExpression =\n    CConstant | CIdentifier | CArrayPointer | CStringLiteral |\n    CFunctionCall | CMemberAccess | CIncrDecr | // postfix\n    CAddressOf | CDereference | CUnaryPlusMinus | CBitwiseNot | CLogicalNot | CSizeof | // unary\n    CCast |\n    CMulDiv | CMod | CAddSub | CShift |\n    CRelational | CEquality |\n    CBitwiseAndOr | CLogicalAndOr |\n    CConditional | CAssignment | CComma;\n\n// evaluated expression, value and type pair\nexport type CValue = {readonly value: number | bigint, readonly type: CArithmetic | CPointer};\n\nexport class CConstant {\n    readonly lvalue = false;\n\n    constructor(readonly node: ParseNode, readonly type: CArithmetic, readonly value: bigint | number) {\n    }\n\n    changeType(type: CArithmetic): CConstant {\n        if (this.type.equals(type)) return this;\n\n        let newValue: bigint | number;\n        if (type.equals(CArithmetic.BOOL)) {\n            // eslint-disable-next-line eqeqeq\n            newValue = this.value == 0 ? 0 : 1;\n        } else if (type.type === \"float\") {\n            newValue = Number(this.value);\n        } else {\n            if (this.value > type.maxValue || this.value < type.minValue) {\n                throw new checks.ExpressionTypeError(this.node, `value which fits in ${type.name}`, this.value.toString());\n            }\n            newValue = BigInt(this.value);\n        }\n        return new CConstant(this.node, type, newValue);\n    }\n\n    // for analyzing expression dependencies\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CIdentifier {\n    readonly lvalue: boolean;\n\n    constructor(readonly node: ParseNode, readonly value: CDeclaration) {\n        this.lvalue = !(value.type instanceof CFuncType);\n    }\n\n    get type(): CType {\n        return this.value.type;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield this;\n    }\n}\n\n/**\n * Array identifiers are used as pointers to arrays everywhere excluding:\n * - the unary & operator\n * - the sizeof operator\n */\nexport class CArrayPointer {\n    readonly lvalue = false;\n    readonly type: CPointer;\n\n    constructor(readonly node: ParseNode, readonly arrayIdentifier: CIdentifier | CStringLiteral) {\n        if (!(arrayIdentifier.type instanceof CArray)) {\n            throw new checks.ExpressionTypeError(this.node, \"array\");\n        }\n        this.type = new CPointer(this.node, arrayIdentifier.type.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        if (this.arrayIdentifier instanceof CIdentifier) yield this.arrayIdentifier;\n    }\n}\n\nexport class CStringLiteral {\n    readonly lvalue = false;\n    readonly type: CArray;\n\n    constructor(readonly node: ParseNode, readonly value: bigint[]) {\n        // currently only supports UTF8\n        if (value.length === 0 || value[value.length - 1] !== 0n) {\n            throw new checks.ExpressionTypeError(node, \"null terminated char[]\", \"char[]\");\n        }\n        this.type = new CArray(node, CArithmetic.U8, value.length);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CFunctionCall {\n    readonly lvalue = false;\n    readonly fnType: CFuncType;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly args: CExpression[]) {\n        this.fnType = checks.asFunction(body.node, body.type);\n        this.type = this.fnType.returnType;\n\n        // check arguments correct for the function type\n        if (this.fnType.variadic && this.fnType.parameterTypes.length > args.length) {\n            throw new checks.ExpressionTypeError(node, `at least ${this.fnType.parameterTypes.length} argument(s) to variadic function`);\n        } else if (!this.fnType.variadic && this.fnType.parameterTypes.length !== args.length) {\n            throw new checks.ExpressionTypeError(node, `${this.fnType.parameterTypes.length} argument(s)`, `${args.length}`);\n        }\n        for (let i = 0; i < this.fnType.parameterTypes.length; i++) {\n            CAssignment.checkAssignmentValid(args[i].node, this.fnType.parameterTypes[i], args[i]);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n        for (const a of this.args) yield* a.identifiers();\n    }\n}\n\nexport class CMemberAccess {\n    readonly lvalue: boolean;\n    readonly structUnion: CStruct | CUnion;\n    readonly type: CType;\n\n    /** transform `e.member` to `(&e)->member` before calling */\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly member: string) {\n        const pointerType = checks.asPointer(body.node, body.type);\n        this.structUnion = checks.asStructOrUnion(body.node, pointerType.type);\n\n        const type = this.structUnion.memberType(member);\n        this.type = type instanceof CArray ? new CPointer(type.node, type.type) : type;\n        this.lvalue = !(this.type instanceof CArray);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CIncrDecr {\n    readonly lvalue = false;\n    readonly type: CArithmetic | CPointer;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression,\n                readonly op: \"++\" | \"--\", readonly pos: \"pre\" | \"post\") {\n        checks.checkLvalue(body, true);\n\n        this.type = checks.asNonFunctionPointer(body.node, checks.asArithmeticOrPointer(body.node, body.type));\n        if (this.type instanceof CPointer) checkTypeComplete(this.type.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CSizeof {\n    readonly lvalue = false;\n    readonly type = CSizeT;\n\n    constructor(readonly node: ParseNode, readonly body: CType) {\n        if (body.incomplete || body.bytes === 0 || body instanceof CFuncType) {\n            throw new checks.ExpressionTypeError(node, \"Complete non-function type\", body.typeName);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        // no identifier children\n    }\n}\n\nexport class CAddressOf { // &\n    readonly lvalue = false;\n    readonly type: CPointer;\n    readonly body: CExpression;\n\n    constructor(readonly node: ParseNode, body: CExpression) {\n        if (body instanceof CArrayPointer) body = body.arrayIdentifier;\n        if (!(body instanceof CIdentifier && body.type instanceof CFuncType)) checks.checkLvalue(body, true);\n        this.type = new CPointer(node, body.type);\n\n        if (body instanceof CIdentifier) {\n            // when translating to wasm all variables which have their address taken have to be stored on the shadow stack\n            (body.value as CVariable | CArgument).addressUsed = true;\n        }\n        this.body = body;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CDereference { // * or 'indirection'\n    readonly lvalue = true;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        this.type = checks.asPointer(node, body.type).type;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CUnaryPlusMinus {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n    readonly bodyType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression, readonly op: \"+\" | \"-\") {\n        this.bodyType = checks.asArithmetic(body.node, body.type);\n        this.type = integerPromotion(this.bodyType);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CBitwiseNot {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n    readonly bodyType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        this.bodyType = checks.asInteger(body.node, body.type);\n        this.type = this.bodyType.bytes < CArithmetic.S32.bytes ? CArithmetic.S32 : this.bodyType;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CLogicalNot {\n    readonly lvalue = false;\n    readonly type = CArithmetic.S32;\n\n    constructor(readonly node: ParseNode, readonly body: CExpression) {\n        checks.asArithmeticOrPointer(body.node, body.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CCast {\n    readonly lvalue = false;\n\n    constructor(readonly node: ParseNode, readonly type: CType, readonly body: CExpression) {\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.body.identifiers();\n    }\n}\n\nexport class CMulDiv {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"*\" | \"/\") {\n        this.type = usualArithmeticConversion(\n            checks.asArithmetic(lhs.node, lhs.type),\n            checks.asArithmetic(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CMod {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression) {\n        this.type = usualArithmeticConversion(\n            checks.asInteger(lhs.node, lhs.type),\n            checks.asInteger(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\n// Array subscript a[b] becomes *(a + b)\nexport class CAddSub {\n    readonly lvalue = false;\n    readonly type: CArithmetic | CPointer;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"+\" | \"-\") {\n        if (lhs.type instanceof CPointer && rhs.type instanceof CPointer) { // both pointers\n            if (!lhs.type.equals(rhs.type)) throw new checks.ExpressionTypeError(node, \"both pointers to have the same type\");\n            checkTypeComplete(lhs.type.type);\n            this.type = checks.asNonFunctionPointer(lhs.node, lhs.type);\n            checks.asNonFunctionPointer(rhs.node, rhs.type);\n\n        } else if (lhs.type instanceof CPointer) { // one pointer, one integral\n            checks.asInteger(rhs.node, rhs.type);\n            checkTypeComplete(lhs.type.type);\n            this.type = checks.asNonFunctionPointer(lhs.node, lhs.type);\n\n        } else if (rhs.type instanceof CPointer) { // one pointer, one integral\n            checks.asInteger(lhs.node, lhs.type);\n            checkTypeComplete(rhs.type.type);\n            this.type = checks.asNonFunctionPointer(rhs.node, rhs.type);\n\n        } else {\n            this.type = usualArithmeticConversion(checks.asArithmetic(lhs.node, lhs.type), checks.asArithmetic(rhs.node, rhs.type));\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CShift {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly dir: \"left\" | \"right\") {\n        this.type = integerPromotion(checks.asInteger(lhs.node, lhs.type));\n        checks.asInteger(rhs.node, rhs.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CRelational {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n    readonly commonType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"LT\" | \"GT\" | \"LEq\" | \"GEq\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n\n        this.commonType = usualArithmeticConversion(\n            lhs.type instanceof CArithmetic ? lhs.type : CSizeT,\n            rhs.type instanceof CArithmetic ? rhs.type : CSizeT);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CEquality {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n    readonly commonType: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"==\" | \"!=\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n\n        this.commonType = usualArithmeticConversion(\n            lhs.type instanceof CArithmetic ? lhs.type : CSizeT,\n            rhs.type instanceof CArithmetic ? rhs.type : CSizeT);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CBitwiseAndOr {\n    readonly lvalue = false;\n    readonly type: CArithmetic;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"and\" | \"or\" | \"xor\") {\n        this.type = usualArithmeticConversion(\n            checks.asInteger(lhs.node, lhs.type),\n            checks.asInteger(rhs.node, rhs.type));\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CLogicalAndOr {\n    readonly lvalue = false;\n    readonly type = CArithmetic.BOOL;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression, readonly op: \"and\" | \"or\") {\n        checks.asArithmeticOrPointer(lhs.node, lhs.type);\n        checks.asArithmeticOrPointer(rhs.node, rhs.type);\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\nexport class CConditional { // [test] ? [trueValue] : [falseValue]\n    readonly lvalue = false;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly test: CExpression, readonly trueValue: CExpression, readonly falseValue: CExpression) {\n        checks.asArithmeticOrPointer(test.node, test.type);\n\n        if (trueValue.type instanceof CArithmetic && falseValue.type instanceof CArithmetic) {\n            this.type = usualArithmeticConversion(trueValue.type, falseValue.type);\n            return;\n        } else if (trueValue.type.equals(falseValue.type)) {\n            this.type = trueValue.type;\n            return;\n        } else if (trueValue.type instanceof CPointer && falseValue.type instanceof CPointer) {\n            // both pointers - check if either is void* pointer\n            if (trueValue.type.type instanceof CVoid) {\n                this.type = falseValue.type;\n                return;\n            } else if (falseValue.type.type instanceof CVoid) {\n                this.type = trueValue.type;\n                return;\n            }\n        } else if (trueValue.type instanceof CPointer || falseValue.type instanceof CPointer) {\n            // one pointer - check if other null constant\n            const otherValue = trueValue.type instanceof CPointer ? falseValue : trueValue;\n            // eslint-disable-next-line eqeqeq\n            if (otherValue instanceof CConstant && otherValue.value == 0) {\n                this.type = trueValue.type instanceof CPointer ? trueValue.type : falseValue.type;\n                return;\n            }\n        }\n        throw new checks.ExpressionTypeError(node, \"both conditional branches to have the same type\", \"different types\");\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.test.identifiers();\n        yield* this.trueValue.identifiers();\n        yield* this.falseValue.identifiers();\n    }\n}\n\nexport class CAssignment {\n    readonly lvalue = false;\n    readonly type: CType;\n\n    // rhs may require casting\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression | CInitializer,\n                readonly assignmentType: pt.AssignmentType, readonly initialAssignment: boolean = false) {\n        // check lvalue\n        checks.checkLvalue(lhs, true);\n        if ((lhs.type instanceof CArray && !initialAssignment) || lhs.type instanceof CFuncType || lhs.type.incomplete) {\n            throw new checks.ExpressionTypeError(lhs.node, \"assignable type\");\n        } else if (getQualifier(lhs.type) === \"const\" && !initialAssignment) {\n            throw new checks.ExpressionTypeError(lhs.node, \"non-const location\");\n        } else if ((lhs.type instanceof CStruct || lhs.type instanceof CUnion) && lhs.type.hasConstMember() && !initialAssignment) {\n            throw new checks.ExpressionTypeError(lhs.node, \"structure without a const member\");\n        }\n        this.type = lhs.type;\n\n        // fix string constants being wrapped into pointers\n        if (lhs.type instanceof CArray && rhs instanceof CArrayPointer) this.rhs = rhs = rhs.arrayIdentifier;\n\n        // check assignment types are valid\n        if (assignmentType) {\n            if (rhs instanceof CInitializer) {\n                throw new checks.ExpressionTypeError(node,\"simple assignments with structure initializers\");\n            }\n            let rhsType = rhs.type;\n\n            // typecheck `lhs op= rhs` as `lhs = lhs op rhs`\n            // LHS only evaluated once so can't just be transformed: see `a[i++] += 1;`\n            switch (assignmentType) {\n            case \"mul\": rhsType = new CMulDiv(node, lhs, rhs, \"*\").type; break;\n            case \"div\": rhsType = new CMulDiv(node, lhs, rhs, \"/\").type; break;\n            case \"mod\": rhsType = new CMod(node, lhs, rhs).type; break;\n            case \"add\": rhsType = new CAddSub(node, lhs, rhs, \"+\").type; break;\n            case \"sub\": rhsType = new CAddSub(node, lhs, rhs, \"-\").type; break;\n            case \"leftShift\": rhsType = new CShift(node, lhs, rhs, \"left\").type; break;\n            case \"rightShift\": rhsType = new CShift(node, lhs, rhs, \"right\").type; break;\n            case \"bitwiseAnd\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"and\").type; break;\n            case \"bitwiseOr\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"or\").type; break;\n            case \"bitwiseXor\": rhsType = new CBitwiseAndOr(node, lhs, rhs, \"xor\").type; break;\n            default: throw new checks.ExpressionTypeError(node, \"valid assignment type\");\n            }\n            CAssignment._checkAssignmentTypeValid(node, lhs.type, rhsType);\n        } else {\n            CAssignment.checkAssignmentValid(node, lhs.type, rhs);\n        }\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n\n    static checkAssignmentValid(node: ParseNode, varType: CType, value: CExpression | CInitializer): void {\n        // also allow constant 0 to be assigned to a pointer\n        if (varType instanceof CPointer && value instanceof CConstant) {\n            if (value.value === 0n) return;\n        }\n        this._checkAssignmentTypeValid(node, varType, value.type);\n    }\n\n    private static _checkAssignmentTypeValid(node: ParseNode, varType: CType, valueType: CType): void {\n        if (varType.equals(valueType)) return;\n        if (varType instanceof CArithmetic && valueType instanceof CArithmetic) {\n            return; // arithmetic types always assignable\n        }\n        if (varType instanceof CPointer && valueType instanceof CPointer) {\n            // void pointers can be assigned to any pointer and any pointer can be assigned to a void pointer\n            if (varType.type instanceof CVoid || valueType.type instanceof CVoid) return;\n            // allow non-constant pointers to be assigned to constant pointers\n            if (varType.type.equals(valueType.type) && valueType.qualifier !== \"const\") return;\n        }\n        if (varType instanceof CPointer && valueType instanceof CFuncType) {\n            // implicit function pointer conversion\n            if (varType.type.equals(valueType)) return;\n        }\n\n        throw new checks.ExpressionTypeError(node, varType.typeName, valueType.typeName);\n    }\n}\n\nexport class CComma {\n    readonly lvalue = false;\n    readonly type: CType;\n\n    constructor(readonly node: ParseNode, readonly lhs: CExpression, readonly rhs: CExpression) {\n        this.type = rhs.type;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        yield* this.lhs.identifiers();\n        yield* this.rhs.identifiers();\n    }\n}\n\n/** Special type of expression permitted only in declarations */\nexport class CInitializer {\n    private _type: CType;\n    private _memberTypes: CType[] = [];\n\n    constructor(readonly node: ParseNode, readonly body: (CExpression | CInitializer)[], type?: CType) {\n        // default to a void* array which isn't the true type but lets the array size be used when declaring arrays\n        this._type = type ?? new CArray(undefined, new CPointer(undefined, new CVoid()), body.length);\n    }\n\n    get memberTypes(): ReadonlyArray<CType> {\n        return this._memberTypes;\n    }\n\n    get type(): CType {\n        return this._type;\n    }\n\n    /** Once the initializer is recursively constructed and the declaration's type is known, set the type of the\n     * initializer to the type of the declaration, checking that this initializer is valid for the provided type */\n    set type(value: CType) {\n        const error = () => {\n            throw new checks.ExpressionTypeError(this.node, \"initializer to match type\");\n        };\n        this._memberTypes = [];\n\n        if (value instanceof CArray) {\n            if (this.body.length > (value.length ?? Infinity)) error(); // too many elements in this initializer\n            for (let i = 0; i < this.body.length; i++) {\n                this.body[i] = CInitializer.typeCheck(value.type, this.body[i]);\n                this._memberTypes.push(value.type);\n            }\n\n        } else if (value instanceof CStruct) {\n            if (this.body.length > value.members.length) error(); // too many members\n            for (let i = 0; i < this.body.length; i++) {\n                this.body[i] = CInitializer.typeCheck(value.members[i].type, this.body[i]);\n                this._memberTypes.push(value.members[i].type);\n            }\n\n        } else if (value instanceof CUnion) {\n            if (this.body.length > 1) error();\n            // unions have to be initialized to the first member in the union\n            if (this.body.length === 1) {\n                this.body[0] = CInitializer.typeCheck(value.members[0].type, this.body[0]);\n                this._memberTypes.push(value.members[0].type);\n            }\n\n        } else {\n            error();\n        }\n        this._type = value;\n    }\n\n    *identifiers(): IterableIterator<CIdentifier> {\n        for (const c of this.body) yield* c.identifiers();\n    }\n\n    private static typeCheck(desiredType: CType, expr: CExpression | CInitializer): CExpression | CInitializer {\n        if (expr instanceof CInitializer) {\n            expr.type = desiredType;\n        } else {\n            CAssignment.checkAssignmentValid(expr.node, desiredType, expr);\n\n            if (expr instanceof CConstant && desiredType instanceof CArithmetic && expr.type !== desiredType) {\n                expr = expr.changeType(desiredType);\n            }\n        }\n        return expr;\n    }\n}\n","import {parse} from \"../parsing\";\nimport {Scope} from \"./scope\";\nimport {ptTransform} from \"./transform/transform\";\n\nexport function toIR(source: string): Scope {\n    const translationUnit = parse(source);\n    return ptTransform(translationUnit);\n}\n","import {ParseNode} from \"../parsing\";\nimport {CFuncDeclaration} from \"./declarations\";\nimport {Scope} from \"./scope\";\nimport {CFuncType, CVoid, CArithmetic, CPointer} from \"./types\";\n\nconst fakeParseNode: ParseNode = new class extends ParseNode {\n    readonly type: string = \"__internal__\";\n\n    constructor() {\n        super({first_line: 0, first_column: 0, last_line: 0, last_column: 0, _source: \"\", _sourceId: -1});\n    }\n}();\n\nexport const INTERNAL_FNS = {\n    /** For executing arbitrary Wasm\n     *\n     * __wasm_push__([#parameters], [parameter1], [parameter2], ..., [byte1], [byte2]...);\n     */\n    wasm: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm__\",\n        new CFuncType(fakeParseNode, new CVoid(), [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm returning i32 */\n    wasm_i32: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_i32__\",\n        new CFuncType(fakeParseNode, CArithmetic.U32, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm returning i64 */\n    wasm_i64: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_i64__\",\n        new CFuncType(fakeParseNode, CArithmetic.U64, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm returning f32 */\n    wasm_f32: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_f32__\",\n        new CFuncType(fakeParseNode, CArithmetic.Fp32, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For executing arbitrary Wasm returning f64 */\n    wasm_f64: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_f64__\",\n        new CFuncType(fakeParseNode, CArithmetic.Fp64, [CArithmetic.U32], undefined, true),\n        \"internal\"\n    ),\n    /** For getting the value of the shadow stack pointer\n     *\n     * __wasm_ssp__();\n     */\n    wasm_ssp: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_ssp__\",\n        new CFuncType(fakeParseNode, new CPointer(fakeParseNode, new CVoid(), true), []),\n        \"internal\"\n    ),\n    /**\n     * Wasm real type load - compensates for conversation/type_conversion.ts realType()\n     * Most C values are directly stored as Wasm values, but CStruct and CUnions have to be stored as pointers.\n     * This isn't directly expressed in the type information, and so this function is needed for any C directly manipulating memory.\n     *\n     * __wasm_rload__([ptr]);\n     */\n    wasm_rload: new CFuncDeclaration(\n        fakeParseNode,\n        \"__wasm_rload__\",\n        new CFuncType(fakeParseNode, new CPointer(fakeParseNode, new CVoid(), true), [new CPointer(fakeParseNode, new CVoid(), true)]),\n        \"internal\"\n    )\n};\n\nexport const INTERNAL_SCOPE = new Scope();\nObject.values(INTERNAL_FNS).forEach(x => INTERNAL_SCOPE.addIdentifier(x));\n","import {CError} from \"../c_error\";\nimport type {ParseNode} from \"../parsing\";\nimport type {CDeclaration} from \"./declarations\";\nimport {CFuncDeclaration, CFuncDefinition, CVarDeclaration, CVarDefinition} from \"./declarations\";\nimport type {CLabelledStatement} from \"./statements\";\nimport type {CCompound, CType} from \"./types\";\n\n/**\n * Represents a scope storing identifiers (variables & functions) and tags (struct, union & enum names) in the IR.\n * Each one has a parent scope excluding the base scope for the translation unit.\n *\n * e.g. base scope (function declarations) <- function scope (contains parameters) <- compound statement scope (fn locals).\n *\n * If a tag or identifier isn't found in the current scope, parents are checked.\n */\nexport class Scope {\n    private tags = new Map<string, CCompound>(); // names of structs, unions & enums\n    private identifiers = new Map<string, CDeclaration>(); // names of variables and functions\n    private typedefs = new Map<string, CType>();\n    labelledStatement?: CLabelledStatement;\n\n    constructor(readonly node?: ParseNode,\n                readonly parent?: Scope,\n                readonly func: CFuncDefinition | undefined = parent?.func) {\n    }\n\n    private _getTag(tag: string): CCompound | undefined {\n        // perform recursive lookup in parents if not found\n        return this.tags.get(tag) ?? this.parent?._getTag(tag);\n    }\n\n    lookupTag<T extends CCompound>(tag: string, wantedType?: { new(...args: any[]): T }, node?: ParseNode): T | undefined {\n        const result = this._getTag(tag);\n        if (wantedType && result && wantedType.prototype !== Object.getPrototypeOf(result)) {\n            throw new ScopeError(\"`\" + tag + \"` was already declared as a \" + result.typeName, result.node, node);\n        }\n        return result as T | undefined;\n    }\n\n    addTag(value: CCompound): void {\n        if (!value.name) throw new Error(\"Cannot add nameless compound type to scope\"); // shouldn't happen\n        if (this._getTag(value.name)) throw new ScopeError(\"Compound type `\" + value.name + \"` is already defined!\", value.node);\n        this.tags.set(value.name, value);\n    }\n\n    private _getId(name: string): CDeclaration | undefined {\n        return this.identifiers.get(name) ?? this.parent?._getId(name);\n    }\n\n    lookupIdentifier(name: string, node?: ParseNode): CDeclaration {\n        const result = this._getId(name);\n        if (!result) {\n            throw new ScopeError(\"Failed to find `\" + name + \"`\", node);\n        }\n        return result;\n    }\n\n    addIdentifier(value: CDeclaration): void {\n        const existing = this.identifiers.get(value.name); // allowing redefining identifiers defined in parent scopes\n        if (existing) {\n            if (existing.type.equals(value.type) && existing instanceof CFuncDeclaration && value instanceof CFuncDefinition) {\n                // allow replacement of function declaration with definition\n                if (existing.linkage !== \"external\" && value.linkage === \"external\") {\n                    // linkage inherited from first declaration\n                    value.linkage = existing.linkage;\n                }\n                existing.definition = value;\n            } else if (existing.type.equals(value.type) && value instanceof CFuncDeclaration) {\n                // allow functions to be redeclared (but don't override instance in scope)\n                if (existing instanceof CFuncDeclaration) existing.fnImport ||= value.fnImport;\n                return;\n            } else if (existing.type.equals(value.type) && existing instanceof CVarDeclaration && value instanceof CVarDefinition) {\n                // allow replacement of variable declaration with definition\n                if (existing.linkage !== \"external\" && existing.linkage !== value.linkage) {\n                    // check linkage is the same\n                    throw new ScopeError(\"Variable `\" + value.name + \"` is already defined with \" + existing.linkage + \" linkage\", existing.node, value.node);\n                }\n                existing.definition = value;\n            } else if (existing.type.equals(value.type) && value instanceof CVarDeclaration) {\n                // allow variables to be redeclared (but don't override instance in scope)\n                if (existing.linkage !== \"external\" && existing.linkage !== value.linkage) {\n                    // check linkage is the same\n                    throw new ScopeError(\"Variable `\" + value.name + \"` is already defined with \" + existing.linkage + \" linkage\", existing.node, value.node);\n                }\n                return;\n            } else {\n                throw new ScopeError(\"Identifier `\" + value.name + \"` is already defined in this scope!\", existing.node, value.node);\n            }\n        }\n        this.identifiers.set(value.name, value);\n    }\n\n    get declarations(): ReadonlyArray<CDeclaration> {\n        return [...this.identifiers.values()];\n    }\n\n    private _getTypedef(id: string): CType | undefined {\n        // perform recursive lookup in parents if not found\n        return this.typedefs.get(id) ?? this.parent?._getTypedef(id);\n    }\n\n    lookupTypedef(id: string, node?: ParseNode): CType {\n        const result = this._getTypedef(id);\n        if (result === undefined) {\n            throw new ScopeError(\"typedef `\" + id + \"` not found in scope\", node);\n        }\n        return result;\n    }\n\n    addTypedef(id: string, type: CType, node?: ParseNode): void {\n        const existing = this._getTypedef(id);\n        if (existing) {\n            if (existing.equals(type)) return;\n            throw new ScopeError(\"typedef already defined with a different type\", node);\n        }\n        this.typedefs.set(id, type);\n    }\n}\n\nclass ScopeError extends CError {\n    name = \"ScopeError\";\n}\n","import type * as pt from \"../parsing/parsetree\";\nimport {CFuncDefinition} from \"./declarations\";\nimport {CExpression, CAssignment, CValue} from \"./expressions\";\nimport {Scope} from \"./scope\";\nimport {ExpressionTypeError, asArithmeticOrPointer} from \"./type_checking\";\n\n// classes to represent the various C statements in the IR\nexport type CStatement =\n    CCompoundStatement | CExpressionStatement | CNop |\n    CIf | CForLoop | CWhileLoop | CDoLoop | CSwitch |\n    CGoto | CContinue | CBreak | CReturn;\n\nexport class CCompoundStatement {\n    readonly scope: Scope;\n    readonly statements: CStatement[] = [];\n\n    constructor(readonly node: pt.ParseNode, readonly parent: CStatement | CFuncDefinition) {\n        this.scope = new Scope(node, parent.scope, parent instanceof CFuncDefinition ? parent : undefined);\n    }\n}\n\nexport class CExpressionStatement {\n    constructor(readonly node: pt.ParseNode, readonly expression: CExpression, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CNop {\n    constructor(readonly node: pt.NoOp, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CIf {\n    ifBody?: CStatement;\n    elseBody?: CStatement;\n\n    constructor(readonly node: pt.IfStatement, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CForLoop {\n    init?: CExpressionStatement | CExpressionStatement[] | CNop;\n    test?: CExpressionStatement | CNop;\n    update?: CExpression;\n    body?: CStatement;\n\n    readonly scope: Scope; // own scope for init variable\n\n    constructor(readonly node: pt.ForLoop, readonly parent: CStatement) {\n        this.scope = new Scope(node, parent.scope);\n    }\n}\n\nexport class CWhileLoop {\n    body?: CStatement;\n\n    constructor(readonly node: pt.WhileLoop, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CDoLoop {\n    body?: CStatement;\n\n    constructor(readonly node: pt.DoWhileLoop, readonly test: CExpression, readonly parent: CStatement) {\n        asArithmeticOrPointer(test.node, test.type);\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CGoto {\n    constructor(readonly node: pt.GotoStatement, readonly target: CLabelledStatement, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CSwitch {\n    children: {cases: CValue[], body: CCompoundStatement, default: boolean}[] = [];\n\n    constructor(readonly node: pt.SwitchStatement, readonly expression: CExpression, readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CContinue {\n    constructor(readonly node: pt.ContinueStatement,\n                readonly loop: CForLoop | CWhileLoop | CDoLoop,\n                readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CBreak {\n    constructor(readonly node: pt.BreakStatement,\n                readonly target: CForLoop | CWhileLoop | CDoLoop | CSwitch,\n                readonly parent: CStatement) {\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\nexport class CReturn {\n    constructor(readonly node: pt.ReturnStatement,\n                readonly func: CFuncDefinition,\n                public value: CExpression | undefined,\n                readonly parent: CStatement) {\n\n        if (value === undefined) {\n            if (func.type.returnType.bytes > 0) {\n                // function return type is not void but a value was not provided\n                throw new ExpressionTypeError(node, \"`return [expression]`\", \"`return;`\");\n            }\n        } else {\n            if (!func.type.returnType.equals(value.type)) {\n                // check provided return value matches the function's return type\n                CAssignment.checkAssignmentValid(node, func.type.returnType, value);\n            }\n        }\n    }\n\n    get scope(): Scope {\n        return this.parent.scope;\n    }\n}\n\n// not a CStatement, used to store labelled statements in Scopes\nexport class CLabelledStatement {\n    body?: CStatement;\n\n    constructor(readonly node: pt.Statement, readonly label: string) {\n    }\n}\n","import {CVarDefinition} from \"../declarations\";\nimport {CExpression, CConstant, CIdentifier, CSizeof, CBitwiseNot, CLogicalNot, CCast, CMulDiv, CMod, CAddSub, CShift, CRelational, CEquality, CBitwiseAndOr, CLogicalAndOr, CConditional, CUnaryPlusMinus, CValue, CInitializer} from \"../expressions\";\nimport {ExpressionTypeError} from \"../type_checking\";\nimport {CArithmetic, CSizeT, CPointer} from \"../types\";\n\ntype ExtraFn = (e: CExpression) => CValue;\n\nexport function constExpression(e: CExpression, extra?: ExtraFn): CValue {\n    if (e instanceof CConstant) {\n        return {value: e.value, type: e.type};\n    } else if (e instanceof CIdentifier && e.value instanceof CVarDefinition && e.value.type.qualifier === \"const\" && e.value.staticValue instanceof CConstant) {\n        return constExpression(e.value.staticValue, extra);\n\n    } else if (e instanceof CSizeof) {\n        return normalizeType({value: e.body.bytes, type: CSizeT});\n\n    } else if (e instanceof CUnaryPlusMinus) {\n        const v = constExpression(e.body, extra);\n        return e.op === \"+\" ? v : {value: -v.value, type: e.type};\n\n    } else if (e instanceof CBitwiseNot) {\n        const v = constInteger(e.body, extra);\n        return normalizeType({value: ~v.value, type: v.type});\n\n    } else if (e instanceof CLogicalNot) {\n        const v = constExpression(e.body, extra);\n        // eslint-disable-next-line eqeqeq\n        return {value: v.value == 0 ? 1n : 0n, type: CArithmetic.S32};\n\n    } else if (e instanceof CCast && (e.type instanceof CArithmetic || e.type instanceof CPointer)) {\n        const v = constExpression(e.body, extra);\n        return normalizeType({value: v.value, type: e.type});\n\n    } else if (e instanceof CMulDiv) {\n        const lhs = constExpression(e.lhs, extra), rhs = constExpression(e.rhs, extra);\n        if (e.op === \"*\") {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) * Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) * BigInt(rhs.value), type: e.type});\n        } else {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) / Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) / BigInt(rhs.value), type: e.type});\n        }\n\n    } else if (e instanceof CMod) {\n        const lhs = constInteger(e.lhs, extra), rhs = constInteger(e.rhs, extra);\n        return normalizeType({value: lhs.value % rhs.value, type: e.type});\n\n    } else if (e instanceof CAddSub && e.type instanceof CArithmetic) {\n        const lhs = constExpression(e.lhs, extra), rhs = constExpression(e.rhs, extra);\n        if (e.op === \"+\") {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) + Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) + BigInt(rhs.value), type: e.type});\n        } else {\n            if (e.type.type === \"float\") {\n                return {value: Number(lhs.value) - Number(rhs.value), type: e.type};\n            }\n            return normalizeType({value: BigInt(lhs.value) - BigInt(rhs.value), type: e.type});\n        }\n\n    } else if (e instanceof CShift) {\n        const lhs = constInteger(e.lhs, extra), rhs = constInteger(e.rhs, extra);\n        if (e.dir === \"left\") {\n            return normalizeType({value: lhs.value << rhs.value, type: e.type});\n        }\n        return normalizeType({value: lhs.value >> rhs.value, type: e.type});\n\n    } else if (e instanceof CRelational) {\n        const lhs = constExpression(e.lhs, extra), rhs = constExpression(e.rhs, extra);\n        if (e.op === \"LT\") {\n            return {value: lhs.value < rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else if (e.op === \"GT\") {\n            return {value: lhs.value > rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else if (e.op === \"LEq\") {\n            return {value: lhs.value <= rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else {\n            return {value: lhs.value >= rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CEquality) {\n        const lhs = constExpression(e.lhs, extra), rhs = constExpression(e.rhs, extra);\n        if (e.op === \"==\") {\n            // eslint-disable-next-line eqeqeq\n            return {value: lhs.value == rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        } else {\n            // eslint-disable-next-line eqeqeq\n            return {value: lhs.value != rhs.value ? 1n : 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CBitwiseAndOr) {\n        const lhs = constInteger(e.lhs, extra), rhs = constInteger(e.rhs, extra);\n        if (e.op === \"and\") {\n            return normalizeType({value: lhs.value & rhs.value, type: e.type});\n        } else if (e.op === \"or\") {\n            return normalizeType({value: lhs.value | rhs.value, type: e.type});\n        } else {\n            return normalizeType({value: lhs.value ^ rhs.value, type: e.type});\n        }\n\n    } else if (e instanceof CLogicalAndOr) {\n        const lhs = constExpression(e.lhs, extra);\n        if (e.op === \"and\") {\n            // eslint-disable-next-line eqeqeq\n            if (lhs.value != 0 && constExpression(e.rhs, extra).value != 0) {\n                return {value: 1n, type: CArithmetic.S32};\n            }\n            return {value: 0n, type: CArithmetic.S32};\n        } else {\n            // eslint-disable-next-line eqeqeq\n            if (lhs.value != 0 || constExpression(e.rhs, extra).value != 0) {\n                return {value: 1n, type: CArithmetic.S32};\n            }\n            return {value: 0n, type: CArithmetic.S32};\n        }\n\n    } else if (e instanceof CConditional && (e.type instanceof CArithmetic || e.type instanceof CPointer)) {\n        const test = constExpression(e.test, extra);\n        let value: CValue;\n        // eslint-disable-next-line eqeqeq\n        if (test.value != 0) {\n            value = constExpression(e.trueValue, extra);\n        } else {\n            value = constExpression(e.falseValue, extra);\n        }\n        return normalizeType({value: value.value, type: e.type});\n\n    }\n\n    // for adding addressof support etc for static initializers\n    if (extra !== undefined) return extra(e);\n\n    throw new ExpressionTypeError(e.node, \"constant expression\");\n}\n\nexport function constInteger(e: CExpression, extra?: ExtraFn): CValue & {readonly value: bigint} {\n    const v = constExpression(e, extra);\n    if (v.type instanceof CArithmetic && v.type.type !== \"float\") return {value: BigInt(v.value), type: v.type};\n    throw new ExpressionTypeError(e.node, \"expected constant integer expression\");\n}\n\nfunction normalizeType(v: CValue): CValue {\n    if (v.type instanceof CArithmetic) {\n        if (CArithmetic.BOOL.equals(v.type)) {\n            // eslint-disable-next-line eqeqeq\n            return {value: v.value == 0 ? 0n : 1n, type: CArithmetic.BOOL};\n        } else if (v.type.type === \"float\") {\n            return {value: typeof v.value === \"number\" ? v.value : Number(v.value), type: v.type};\n        } else {\n            let value: bigint;\n            if (typeof v.value === \"number\") {\n                // need to emulate runtime behaviour - i.e. the use of the trunc_sat instructions\n                if (isNaN(v.value)) {\n                    value = 0n;\n                } else if (v.value > v.type.maxValue) {\n                    value = BigInt(v.type.maxValue);\n                } else if (v.value < v.type.minValue) {\n                    value = BigInt(v.type.minValue);\n                } else {\n                    value = BigInt(v.value);\n                }\n            } else {\n                value = v.value;\n            }\n\n            const bitmask = 2n ** BigInt(8 * v.type.bytes) - 1n;\n            if (v.type.type === \"unsigned\") {\n                value &= bitmask;\n            } else { // signed\n                const minValue = BigInt(v.type.minValue);\n                value = ((value - minValue) & bitmask) + minValue;\n            }\n\n            return {value, type: v.type};\n        }\n    } else { // instanceof CPointer\n        // normalize as if U32\n        const value = normalizeType({value: v.value, type: CArithmetic.U32}).value;\n        return {value: value, type: v.type};\n    }\n}\n\nexport const normalizeValueType = normalizeType;\n","import {ParseNode, ParseTreeValidationError, pt} from \"../../parsing\";\nimport {CFuncDefinition, CFuncDeclaration} from \"../declarations\";\nimport {\n    CExpression, CConstant, CIdentifier, CFunctionCall, CMemberAccess, CDereference, CConditional,\n    CAssignment, CStringLiteral, CIncrDecr, CAddressOf, CUnaryPlusMinus, CBitwiseNot, CLogicalNot, CSizeof, CAddSub,\n    CCast, CComma, CMulDiv, CMod, CShift, CRelational, CEquality, CBitwiseAndOr, CLogicalAndOr, CArrayPointer, CValue\n} from \"../expressions\";\nimport {Scope} from \"../scope\";\nimport {CArithmetic, CArray} from \"../types\";\nimport {constInteger} from \"./constant_expressions\";\nimport {getType} from \"./type_transform\";\n\n/** Transform expressions from the parse tree */\nexport function ptExpression(e: pt.Expression, scope: Scope): CExpression {\n    if (e instanceof pt.ConstantExpression) {\n        // pt.ConstantExpression is a wrapped class in the parse tree denoting where constant expressions are expected.\n        return ptExpression(e.expr, scope);\n\n    } else if (e instanceof pt.Constant) {\n        return ptConstant(e);\n\n    } else if (e instanceof pt.Identifier) {\n        const id = new CIdentifier(e, scope.lookupIdentifier(e.name, e));\n        if (scope.func) scope.func.dependencies.set(id.value, true);\n\n        if (id.type instanceof CArray) {\n            return new CArrayPointer(e, id);\n        }\n        return id;\n\n    } else if (e instanceof pt.StringLiteral) {\n        const arr: bigint[] = []; // split the literal into characters taking into account escape sequences\n        const charRegex = /[^\\\\\\n\"]|\\\\(?:[^x0-7\\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3})/y;\n        while (charRegex.lastIndex < e.value.length) {\n            const match = charRegex.exec(e.value);\n            if (match && charRegex.lastIndex !== 0) {\n                arr.push(BigInt(unescapeChar(match[0], e).codePointAt(0) ?? 0)); // unescape the char if needed\n            } else {\n                // regex didn't match the body for some reason, this shouldn't happen\n                throw new ParseTreeValidationError(e, \"Invalid string literal\");\n            }\n        }\n        arr.push(0n); // null terminator\n        return new CArrayPointer(e, new CStringLiteral(e, arr));\n\n    } else if (e instanceof pt.UnaryExpression) {\n        return ptUnary(e, scope);\n\n    } else if (e instanceof pt.BinaryExpression) {\n        return ptBinary(e, scope);\n\n    } else if (e instanceof pt.SizeofExpression) {\n        if (e.body instanceof pt.Expression) { // sizeof [expression]\n            let bodyExpr = ptExpression(e.body, scope);\n            if (bodyExpr instanceof CArrayPointer) bodyExpr = bodyExpr.arrayIdentifier;\n            return new CSizeof(e, bodyExpr.type);\n        } else { // sizeof [type]\n            return new CSizeof(e, getType(e.body, scope));\n        }\n\n    } else if (e instanceof pt.CastExpression) {\n        return new CCast(e, getType(e.targetType, scope), ptExpression(e.body, scope));\n\n    } else if (e instanceof pt.FunctionCallExpression) {\n        return new CFunctionCall(e, ptExpression(e.fn, scope), (e.args ?? []).map(e => ptExpression(e, scope)));\n\n    } else if (e instanceof pt.MemberAccessExpression) {\n        let body = ptExpression(e.lhs, scope);\n        if (!e.pointer) { // transform into pointer access\n            body = new CAddressOf(e, body);\n        }\n        return new CMemberAccess(e, body, e.rhs);\n\n    } else if (e instanceof pt.ConditionalExpression) {\n        return new CConditional(e, ptExpression(e.condition, scope), ptExpression(e.trueValue, scope), ptExpression(e.falseValue, scope));\n\n    } else if (e instanceof pt.AssignmentExpression) {\n        return new CAssignment(e, ptExpression(e.lhs, scope), ptExpression(e.rhs, scope), e.assignType);\n\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid expression\");\n}\n\n/** Evaluate an expression at compile time to an integer constant */\nexport function evalIntegerConstant(c: pt.ConstantExpression, scope: Scope): CValue & {value: bigint} {\n    const expr = ptExpression(c.expr, scope);\n    return constInteger(expr);\n}\n\nfunction ptUnary(e: pt.UnaryExpression, scope: Scope): CExpression {\n    // transform unary expressions\n    const body = ptExpression(e.body, scope);\n    if (e.type === \"prefixIncrement\") return new CIncrDecr(e, body, \"++\", \"pre\");\n    if (e.type === \"prefixDecrement\") return new CIncrDecr(e, body, \"--\", \"pre\");\n    if (e.type === \"postfixIncrement\") return new CIncrDecr(e, body, \"++\", \"post\");\n    if (e.type === \"postfixDecrement\") return new CIncrDecr(e, body, \"--\", \"post\");\n    if (e.type === \"addressOf\") return new CAddressOf(e, body);\n    if (e.type === \"dereference\") return new CDereference(e, body);\n    if (e.type === \"unaryPlus\") return new CUnaryPlusMinus(e, body, \"+\");\n    if (e.type === \"unaryMinus\") return new CUnaryPlusMinus(e, body, \"-\");\n    if (e.type === \"bitwiseNot\") return new CBitwiseNot(e, body);\n    if (e.type === \"logicalNot\") return new CLogicalNot(e, body);\n\n    throw new ParseTreeValidationError(e, \"Invalid unary expression\");\n}\n\nfunction ptBinary(e: pt.BinaryExpression, scope: Scope): CExpression {\n    // transform binary expressions\n    const lhs = ptExpression(e.lhs, scope), rhs = ptExpression(e.rhs, scope);\n\n    if (e.type === \"mul\") return new CMulDiv(e, lhs, rhs, \"*\");\n    if (e.type === \"div\") return new CMulDiv(e, lhs, rhs, \"/\");\n    if (e.type === \"mod\") return new CMod(e, lhs, rhs);\n    if (e.type === \"add\") return new CAddSub(e, lhs, rhs, \"+\");\n    if (e.type === \"sub\") return new CAddSub(e, lhs, rhs, \"-\");\n    if (e.type === \"bitwiseShiftLeft\") return new CShift(e, lhs, rhs, \"left\");\n    if (e.type === \"bitwiseShiftRight\") return new CShift(e, lhs, rhs, \"right\");\n\n    if (e.type === \"relationalLT\") return new CRelational(e, lhs, rhs, \"LT\");\n    if (e.type === \"relationalGT\") return new CRelational(e, lhs, rhs, \"GT\");\n    if (e.type === \"relationalLEq\") return new CRelational(e, lhs, rhs, \"LEq\");\n    if (e.type === \"relationalGEq\") return new CRelational(e, lhs, rhs, \"GEq\");\n    if (e.type === \"relationalEq\") return new CEquality(e, lhs, rhs, \"==\");\n    if (e.type === \"relationalNEq\") return new CEquality(e, lhs, rhs, \"!=\");\n\n    if (e.type === \"bitwiseAnd\") return new CBitwiseAndOr(e, lhs, rhs, \"and\");\n    if (e.type === \"bitwiseXor\") return new CBitwiseAndOr(e, lhs, rhs, \"xor\");\n    if (e.type === \"bitwiseOr\") return new CBitwiseAndOr(e, lhs, rhs, \"or\");\n    if (e.type === \"logicalAnd\") return new CLogicalAndOr(e, lhs, rhs, \"and\");\n    if (e.type === \"logicalOr\") return new CLogicalAndOr(e, lhs, rhs, \"or\");\n\n    if (e.type === \"comma\") return new CComma(e, lhs, rhs);\n    if (e.type === \"arraySubscript\") {\n        // transform `a[b]` into `*(a+b)`\n        return new CDereference(e, new CAddSub(e, ptExpression(e.lhs, scope), ptExpression(e.rhs, scope), \"+\"));\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid binary expression\");\n}\n\n/** Transform a constant\n *\n * This is quite complicated because we have to work out what type to give the constant, following the rules set out in\n * the standard\n */\nexport function ptConstant(e: pt.Constant): CConstant {\n    let value = e.value;\n    let type: CArithmetic;\n\n    if (e.valueType === \"int\" || e.valueType === \"oct\" || e.valueType === \"hex\") {\n        let unsigned = false, long = false;\n        value = value.toLowerCase();\n        if (value.endsWith(\"u\")) {\n            value = value.slice(0, -1);\n            unsigned = true;\n        }\n        if (value.endsWith(\"l\")) {\n            value = value.slice(0, -1);\n            long = true;\n            // may be a second l for long long\n            if (value.endsWith(\"l\")) value = value.slice(0, -1);\n        }\n        if (!unsigned && value.endsWith(\"u\")) {\n            // check u again as u and l can appear in either order\n            value = value.slice(0, -1);\n            unsigned = true;\n        }\n\n        let num: bigint; // all integer constants are stored as BigInt\n        if (e.valueType !== \"oct\") {\n            // BigInt constructor natively handles decimal values and hexadecimal values prefixed with 0x\n            num = BigInt(value);\n        } else {\n            // Have to manually construct octal constants\n            num = 0n;\n            for (let i = 0; i < value.length - 1; i++) { // ignore the leading 0\n                num += BigInt(value[value.length - 1 - i]) * (8n ** BigInt(i));\n            }\n        }\n\n        // Choose the list of possible types from the suffixes and the constant type used (decimal, hex, octal)\n        let possibleTypes;\n        if (e.valueType === \"int\" && !unsigned && !long) {\n            possibleTypes = [CArithmetic.S32, CArithmetic.S64, CArithmetic.U64];\n        } else if (e.valueType !== \"int\" && !unsigned && !long) {\n            possibleTypes = [CArithmetic.S32, CArithmetic.U32, CArithmetic.S64, CArithmetic.U64];\n        } else if (unsigned && long) {\n            possibleTypes = [CArithmetic.U64];\n        } else if (long) {\n            possibleTypes = [CArithmetic.S64, CArithmetic.U64];\n        } else { // if (unsigned)\n            possibleTypes = [CArithmetic.U32, CArithmetic.U64];\n        }\n\n        // find smallest acceptable type which fits the value\n        for (const type of possibleTypes) {\n            if (num >= type.minValue && num <= type.maxValue) {\n                return new CConstant(e, type, num);\n            }\n        }\n        throw new ParseTreeValidationError(e, \"Integer constant too large for its type\");\n\n    } else if (e.valueType === \"float\") {\n        // floats default to double unless suffixed with \"f\"\n        if (value.endsWith(\"f\")) {\n            value = value.slice(0, -1);\n            type = CArithmetic.Fp32;\n        } else {\n            type = CArithmetic.Fp64;\n        }\n        return new CConstant(e, type, parseFloat(value));\n\n    } else if (e.valueType === \"char\") {\n        value = unescapeChar(value, e);\n        return new CConstant(e, CArithmetic.U8, BigInt(value.codePointAt(0)));\n    }\n\n    throw new ParseTreeValidationError(e, \"Invalid constant type?\");\n}\n\n/** Unescape strings as defined in the C standard */\nfunction unescapeChar(s: string, node?: ParseNode): string {\n    if (s.startsWith(\"\\\\\")) {\n        if (s === \"\\\\n\") return \"\\n\";\n        if (s === \"\\\\t\") return \"\\t\";\n        if (s === \"\\\\v\") return \"\\v\";\n        if (s === \"\\\\b\") return \"\\b\";\n        if (s === \"\\\\r\") return \"\\r\";\n        if (s === \"\\\\f\") return \"\\f\";\n        if (s === \"\\\\a\") return \"\\x07\";\n        if (s === \"\\\\\\\\\") return \"\\\\\";\n        if (s === \"\\\\?\") return \"?\";\n        if (s === \"\\\\'\") return \"'\";\n        if (s === '\\\\\"') return '\"';\n\n        let value: number;\n        if (s.startsWith(\"\\\\x\")) {\n            // hex constant\n            value = parseInt(s.slice(2), 16);\n        } else {\n            // octal constant\n            value = parseInt(s.slice(1), 8);\n        }\n\n        if (!isNaN(value) && value >= 0 && value <= 255) {\n            return String.fromCharCode(value);\n        }\n        throw new ParseTreeValidationError(node, \"Invalid character escape\");\n    }\n\n    const codePoint = s.codePointAt(0);\n    if (s.length !== 1 || codePoint === undefined || codePoint > 255) {\n        throw new ParseTreeValidationError(node, \"Invalid character\");\n    }\n    return s;\n}\n","import {ParseTreeValidationError, pt} from \"../../parsing\";\nimport {CFuncDefinition, CArgument, CFuncDeclaration, CVarDefinition, CVarDeclaration} from \"../declarations\";\nimport {CAssignment, CIdentifier, CExpression, CInitializer, CStringLiteral, CConstant, CArrayPointer} from \"../expressions\";\nimport {INTERNAL_SCOPE} from \"../internal_scope\";\nimport {Scope} from \"../scope\";\nimport {CStatement, CCompoundStatement, CExpressionStatement, CNop, CIf, CForLoop, CWhileLoop, CDoLoop, CSwitch, CBreak, CContinue, CReturn, CGoto, CLabelledStatement} from \"../statements\";\nimport {ExpressionTypeError} from \"../type_checking\";\nimport {CFuncType, CVoid, CArray, CArithmetic, CPointer} from \"../types\";\nimport {ptExpression, evalIntegerConstant} from \"./expr_transform\";\nimport {getDeclaratorName, getDeclaratorType, getType} from \"./type_transform\";\n\n/** Main function, transform a parse tree translation unit into a root scope */\nexport function ptTransform(translationUnit: pt.TranslationUnit): Scope {\n    const fileScope = new Scope(undefined, INTERNAL_SCOPE);\n    for (const decl of translationUnit) {\n        if (decl instanceof pt.FunctionDefinition) {\n            ptFunction(decl, fileScope);\n        } else {\n            ptDeclaration(decl, fileScope, false);\n        }\n    }\n    return fileScope;\n}\n\n/** Add the pt declarations to the scope, and either store their static initializer on the variables or return a\n * list of assignments to add to the body of the current function to set their initial values */\nfunction ptDeclaration(declaration: pt.Declaration, scope: Scope, inFunction: boolean): CAssignment[] {\n    if (declaration.typeInfo.storageList[0] === \"typedef\") {\n        ptTypedef(declaration, scope);\n        return [];\n    }\n\n    const declType = getType(declaration, scope);\n    const assignments = [];\n    for (let entry of declaration.list) {\n        const name = getDeclaratorName(entry);\n\n        let initialValue: CExpression | CInitializer | undefined;\n        if (entry instanceof pt.InitDeclarator) {\n            initialValue = ptInitializer(entry, entry.initializer, scope);\n            entry = entry.body;\n        }\n\n        const type = getDeclaratorType(declType, entry, scope);\n        if (!(type instanceof CPointer) && initialValue instanceof CArrayPointer && initialValue.arrayIdentifier instanceof CStringLiteral) {\n            initialValue = initialValue.arrayIdentifier;\n        }\n        if (initialValue?.type instanceof CArray && type instanceof CArray && type.incomplete) {\n            // initialize array length from initializer if incomplete\n            type.length = initialValue.type.length;\n        }\n\n        if (type.incomplete) {\n            throw new ExpressionTypeError(type.node ?? entry, \"complete type\", \"incomplete type\");\n        } else if (type instanceof CFuncType) {\n            // function declarations\n            const linkage = declaration.typeInfo.storageList[0] === \"static\" ? \"internal\" : \"external\";\n            const fnImport = declaration.typeInfo.fnSpecifierList[0] === \"import\";\n            scope.addIdentifier(new CFuncDeclaration(entry, name, type, linkage, fnImport));\n        } else {\n            if (declaration.typeInfo.fnSpecifierList.length > 0) {\n                throw new ExpressionTypeError(entry, \"variable declaration with function specifier\");\n            }\n\n            // work out storage, linkage and if definition or declaration\n            let storage: \"static\" | \"local\";\n            let linkage: \"none\" | \"internal\" | \"external\";\n            let declType: typeof CVarDefinition | typeof CVarDeclaration;\n            if (declaration.typeInfo.storageList[0] === \"static\") {\n                storage = \"static\";\n                linkage = inFunction ? \"none\" : \"internal\";\n                declType = inFunction ? CVarDefinition : (initialValue !== undefined ? CVarDefinition : CVarDeclaration);\n            } else if (declaration.typeInfo.storageList[0] === \"extern\") {\n                storage = \"static\";\n                linkage = \"external\";\n                declType = CVarDeclaration;\n            } else {\n                storage = inFunction ? \"local\" : \"static\";\n                linkage = inFunction ? \"none\" : \"external\";\n                declType = inFunction ? CVarDefinition : (initialValue !== undefined ? CVarDefinition : CVarDeclaration);\n            }\n            const cvar = new declType(entry, name, type, storage, linkage);\n            scope.addIdentifier(cvar);\n\n            // if definition with initializer\n            if (initialValue) {\n                if (cvar instanceof CVarDeclaration) {\n                    throw new ExpressionTypeError(entry, \"declaration\", \"declaration with initializer\");\n                }\n                if (initialValue instanceof CInitializer) {\n                    initialValue.type = type;\n                }\n                if (initialValue instanceof CConstant && type instanceof CArithmetic && type !== initialValue.type) {\n                    // force constants to take the correct type\n                    initialValue = initialValue.changeType(type);\n                }\n\n                if (inFunction && cvar.storage !== \"static\") {\n                    const id: CExpression = new CIdentifier(entry, cvar);\n                    assignments.push(new CAssignment(entry, id, initialValue, undefined, true));\n                } else {\n                    // static initialization, must be constant and evaluated at compile time\n                    cvar.staticValue = initialValue;\n                    CAssignment.checkAssignmentValid(entry, type, cvar.staticValue);\n\n                    // setup variable dependencies\n                    for (const identifier of initialValue.identifiers()) {\n                        cvar.dependencies.set(identifier.value, true);\n                    }\n                }\n            }\n        }\n    }\n    return assignments;\n}\n\nfunction ptTypedef(node: pt.Declaration, scope: Scope) {\n    if (node.list.length === 0) throw new ParseTreeValidationError(node, \"typedef must define at least one identifier\");\n    const baseType = getType(node, scope);\n\n    for (const decl of node.list) {\n        if (decl instanceof pt.InitDeclarator) throw new ParseTreeValidationError(node, \"cannot initialize a typedef\");\n        const type = getDeclaratorType(baseType, decl, scope);\n        const name = getDeclaratorName(decl);\n        scope.addTypedef(name, type, decl);\n    }\n}\n\n/** Transform an initializer to either a CInitializer (for arrays, structs & unions) or a CExpression */\nfunction ptInitializer(node: pt.ParseNode, initializer: pt.Initializer, scope: Scope): CExpression | CInitializer {\n    if (Array.isArray(initializer)) {\n        return new CInitializer(node, initializer.map(x => ptInitializer(node, x, scope)));\n    } else {\n        return ptExpression(initializer as pt.Expression, scope);\n    }\n}\n\n/** Transform a function */\nfunction ptFunction(fn: pt.FunctionDefinition, scope: Scope): void {\n    if (fn.typeInfo.fnSpecifierList[0] === \"import\") {\n        throw new ExpressionTypeError(fn, \"function definition to not be marked `import`\");\n    }\n\n    // get and check the function's type\n    const type = getType(fn, scope);\n    if (!(type instanceof CFuncType)) throw new ParseTreeValidationError(fn, \"Unexpected declarator\");\n    // get the function name\n    const name = getDeclaratorName(fn.declarator);\n\n    let linkage: \"internal\" | \"external\";\n    if (fn.typeInfo.storageList[0] === \"static\") linkage = \"internal\";\n    else if (fn.typeInfo.storageList[0] === \"typedef\") throw new ParseTreeValidationError(fn, \"Invalid typedef\");\n    else linkage = \"external\";\n\n    const cfn = new CFuncDefinition(fn, name, type, linkage, scope);\n    scope.addIdentifier(cfn);\n\n    // add arguments as parameters to function's scope\n    if (!type.parameterNames) throw new ParseTreeValidationError(fn, \"Expected parameter names\");\n    for (let i = 0; i < type.parameterTypes.length; i++) {\n        cfn.body.scope.addIdentifier(new CArgument(fn, type.parameterNames[i], type.parameterTypes[i], i));\n    }\n\n    // parse function body body\n    ptCompound(fn.body, cfn);\n\n    // check function always returns\n    if (!(type.returnType instanceof CVoid) && !checkReturns(cfn.body)) {\n        throw new ParseTreeValidationError(fn.body, \"Non-void function may not return\");\n    }\n}\n\n/** Checks every branch through a function will definitely return */\nfunction checkReturns(statement: CStatement | undefined): boolean {\n    if (statement instanceof CReturn) {\n        return true;\n    } else if (statement instanceof CCompoundStatement) {\n        for (let i = 0; i < statement.statements.length; i++) {\n            if (checkReturns(statement.statements[i])) {\n                if (i + 1 < statement.statements.length) {\n                    // statements after return\n\n                    if (statement.statements[i + 1] === statement.scope.labelledStatement?.body) {\n                        // this is okay as the following statement is labelled, so can jump there\n                        continue; // check code after jumping to the label returns\n                    }\n\n                    // not okay - no way to reach statements after return\n                    throw new ParseTreeValidationError(statement.statements[i + 1].node, \"Statement after return\");\n                }\n                return true;\n            }\n        }\n    } else if (statement instanceof CIf) {\n        return checkReturns(statement.ifBody) && checkReturns(statement.elseBody);\n    } else if (statement instanceof CDoLoop) {\n        return checkReturns(statement.body);\n    } else if (statement instanceof CSwitch) {\n        // if every child returns and there's a default statement then switch is safe\n        return statement.children.every(x => checkReturns(x.body)) &&\n            statement.children.find(x => x.default) !== undefined;\n    }\n    return false;\n}\n\n/** Transform statements from the parse tree */\nfunction ptStatement(node: pt.Statement, parent: CStatement): CStatement {\n    if (node instanceof pt.CompoundStatement) {\n        return ptCompound(node, parent);\n\n    } else if (node instanceof pt.ExpressionStatement) {\n        return new CExpressionStatement(node, ptExpression(node.expression, parent.scope), parent);\n\n    } else if (node instanceof pt.IfStatement) {\n        const s = new CIf(node, ptExpression(node.expression, parent.scope), parent);\n        s.ifBody = ptStatement(node.ifBody, s);\n        if (node.elseBody) s.elseBody = ptStatement(node.elseBody, s);\n        return s;\n\n    } else if (node instanceof pt.ForLoop) {\n        const s = new CForLoop(node, parent);\n        if (node.init instanceof pt.ExpressionStatement || node.init instanceof pt.NoOp) {\n            s.init = ptStatement(node.init, s) as CExpressionStatement | CNop;\n        } else {\n            s.init = ptDeclaration(node.init, s.scope, true)\n                .map(e => new CExpressionStatement(e.node, e, s));\n        }\n        s.test = ptStatement(node.test, s) as CExpressionStatement | CNop;\n        if (node.update) s.update = ptExpression(node.update, s.scope);\n        s.body = ptStatement(node.body, s);\n        return s;\n\n    } else if (node instanceof pt.WhileLoop) {\n        const s = new CWhileLoop(node, ptExpression(node.test, parent.scope), parent);\n        s.body = ptStatement(node.body, s);\n        return s;\n\n    } else if (node instanceof pt.DoWhileLoop) {\n        const s = new CDoLoop(node, ptExpression(node.test, parent.scope), parent);\n        s.body = ptStatement(node.body, s);\n        return s;\n\n    } else if (node instanceof pt.GotoStatement) {\n        let p: CStatement | CFuncDefinition = parent; // find which statement this goto is targeting\n        while (p.scope.labelledStatement?.label !== node.target) {\n            if (p.parent instanceof CFuncDefinition) {\n                throw new ParseTreeValidationError(node, \"No properly structured control flow target for goto statement\");\n            }\n            p = p.parent;\n        }\n        return new CGoto(node, p.scope.labelledStatement, parent);\n\n    } else if (node instanceof pt.ContinueStatement) {\n        let p: CStatement = parent; // find which statement this node is continuing\n        while (!(p instanceof CForLoop || p instanceof CWhileLoop || p instanceof CDoLoop)) {\n            if (p.parent instanceof CFuncDefinition) {\n                throw new ParseTreeValidationError(node, \"No target for continue statement\");\n            }\n            p = p.parent;\n        }\n        return new CContinue(node, p, parent);\n\n    } else if (node instanceof pt.BreakStatement) {\n        let p: CStatement = parent;\n        while (!(p instanceof CForLoop || p instanceof CWhileLoop || p instanceof CDoLoop || p instanceof CSwitch)) {\n            if (p.parent instanceof CFuncDefinition) {\n                throw new ParseTreeValidationError(node, \"No target for break statement\");\n            }\n            p = p.parent;\n        }\n        return new CBreak(node, p, parent);\n\n    } else if (node instanceof pt.SwitchStatement) {\n        const s = new CSwitch(node, ptExpression(node.expression, parent.scope), parent);\n        ptSwitchBody(s, node, parent.scope);\n        return s;\n\n    } else if (node instanceof pt.ReturnStatement) {\n        let p: CStatement | CFuncDefinition = parent;\n        while (!(p instanceof CFuncDefinition)) p = p.parent;\n\n        const value = node.value ? ptExpression(node.value, parent.scope) : undefined;\n        return new CReturn(node, p, value, parent);\n\n    } else if (node instanceof pt.NoOp) {\n        return new CNop(node, parent);\n\n    } else if (node instanceof pt.CaseStatement) {\n        // allowed case/default statements handled in ptSwitchBody\n        throw new ParseTreeValidationError(node, \"Unexpected case statement\");\n    } else if (node instanceof pt.DefaultStatement) {\n        throw new ParseTreeValidationError(node, \"Unexpected default statement\");\n    }\n\n    throw new ParseTreeValidationError(node, \"Unknown statement type\");\n}\n\n/** Transform compound statements */\nfunction ptCompound(node: pt.CompoundStatement, parent: CStatement | CFuncDefinition): CCompoundStatement {\n    const c = parent instanceof CFuncDefinition ? parent.body : new CCompoundStatement(node, parent);\n\n    // need to check for labelled statements first to allow jumping forward\n    const labelled = node.body.filter(x => x instanceof pt.Statement && x.label !== undefined) as pt.Statement[];\n    if (labelled.length > 1) {\n        throw new ParseTreeValidationError(labelled[0], \"Only one labelled statement is supported per block\", labelled[1]);\n    } else if (labelled.length === 1) {\n        c.scope.labelledStatement = new CLabelledStatement(labelled[0], labelled[0].label as string);\n    }\n\n    for (const child of node.body) {\n        _compoundBody(child, c);\n    }\n    return c;\n}\n\n/** Transform a declaration or statement inside a compound statement */\nfunction _compoundBody(child: pt.Declaration | pt.Statement, c: CCompoundStatement) {\n    if (child instanceof pt.Declaration) {\n        for (const assignment of ptDeclaration(child, c.scope, true)) {\n            // add initializers to body of the statement to ensure they happen in the correct order\n            c.statements.push(new CExpressionStatement(assignment.node, assignment, c));\n        }\n    } else {\n        const statement = ptStatement(child, c);\n        c.statements.push(statement);\n\n        if (child.label !== undefined && c.scope.labelledStatement?.node === child) {\n            // now store the statement\n            c.scope.labelledStatement.body = statement;\n        }\n    }\n}\n\n/** Transform the body of a switch statement.\n *\n * This is quite complicated as case & default statements both absorb the following statement.\n * Furthermore, these statements are limited to being used at the top level inside the switch statement, whereas in C\n * you can place them inside other statements inside the switch block, creating arbitrary goto which is out of scope.\n */\nfunction ptSwitchBody(s: CSwitch, node: pt.SwitchStatement, scope: Scope) {\n    if (!(node.body instanceof pt.CompoundStatement)) {\n        throw new ParseTreeValidationError(node, \"Expected switch statement to have a compound statement body\");\n    }\n    const children = node.body.body.slice();\n    while (children.length > 0) { // iterate over the body of the switch statement\n        const child = children.shift();\n        if (child instanceof pt.CaseStatement || child instanceof pt.DefaultStatement) {\n            let block;\n            if (s.children.length > 0 && s.children[s.children.length - 1].body.statements.length === 0) {\n                // multiple cases in a row, use the last defined block\n                block = s.children[s.children.length - 1];\n            } else {\n                // last block already has children, make a new block\n                block = {cases: [], default: false, body: new CCompoundStatement(node, s)};\n                s.children.push(block);\n            }\n\n            if (child instanceof pt.CaseStatement) { // add the case or mark this block as accepting default\n                block.cases.push(evalIntegerConstant(child.value, scope));\n            } else {\n                block.default = true;\n            }\n\n            // case and default statements eat a statement\n            children.unshift(child.body);\n        } else if (child) {\n            // handle other statements as if this was a compound statement\n            if (s.children.length === 0) {\n                throw new ParseTreeValidationError(child, \"Unexpected first statement inside a switch statement\");\n            }\n            const compound = s.children[s.children.length - 1].body;\n            _compoundBody(child, compound);\n        }\n    }\n}\n","import {CVarDefinition} from \"../declarations\";\nimport {CConstant} from \"../expressions\";\nimport {Scope} from \"../scope\";\nimport {CType, getArithmeticType, CPointer, addQualifier, CFuncType, CNotFuncType, CArray, CEnum, CStruct, CUnion, CCompoundMember, CVoid, CArithmetic} from \"../types\";\nimport {ParseTreeValidationError, pt} from \"../../parsing/\";\nimport {evalIntegerConstant} from \"./expr_transform\";\n\ntype GeneralTypeDecl = {\n    typeInfo: pt.SpecifierQualifiers | pt.DeclarationSpecifiers,\n    declarator?: pt.Declarator | pt.AbstractDeclarator\n};\n\n/** helper function for specifier & declarator type */\nexport function getType(o: GeneralTypeDecl, scope: Scope): CType {\n    let type = getSpecifierType(o.typeInfo, scope);\n    if (o.typeInfo.qualifierList.length) type = addQualifier(type, o.typeInfo.qualifierList[0]);\n    if (o.declarator) type = getDeclaratorType(type, o.declarator, scope);\n    return type;\n}\n\n/** transform the CType from a type specifier into the declarator type */\nexport function getDeclaratorType(type: CType, declarator: pt.Declarator | pt.AbstractDeclarator, scope: Scope): CType {\n    let d: pt.Declarator | pt.AbstractDeclarator | undefined = declarator;\n\n    while (d && !(d instanceof pt.IdentifierDeclarator)) {\n        if (d instanceof pt.PointerDeclarator || d instanceof pt.AbstractPointerDeclarator) {\n            let ptr: pt.Pointer | undefined = d.pointer;\n            while (ptr) {\n                type = new CPointer(ptr, type, ptr.qualifierList?.includes(\"const\"));\n                ptr = ptr.body;\n            }\n            d = d.body;\n\n        } else if (d instanceof pt.ArrayDeclarator || d instanceof pt.AbstractArrayDeclarator) {\n            type = new CArray(d, type);\n            if (d.length) {\n                type.length = Number(evalIntegerConstant(d.length, scope).value);\n                if (type.length <= 0) throw new ParseTreeValidationError(d.length, \"Invalid array length\");\n            }\n\n            d = d.body;\n        } else { // d instanceof pt.(Abstract)FunctionDeclarator\n            const parameterTypes = [];\n            let parameterNames = undefined;\n\n            for (const param of d.args ?? []) {\n                const type = getType(param, scope);\n                if (type instanceof CFuncType) {\n                    throw new ParseTreeValidationError(param, \"Functions cannot be parameters\");\n                }\n                parameterTypes.push(type);\n\n                if (param.declarator && !param.declarator.abstractDeclarator) {\n                    parameterNames ??= [];\n                    parameterNames.push(getDeclaratorName(param.declarator));\n                }\n\n                if (parameterNames && parameterNames.length !== parameterTypes.length) {\n                    throw new ParseTreeValidationError(param, \"Unexpected mix of abstract & non-abstract declarators\");\n                }\n            }\n\n            if (parameterTypes.length === 1 && parameterTypes[0] instanceof CVoid) parameterTypes.shift();\n\n            if (parameterTypes.length === 0) {\n                // ensure parameterNames are always non-null in function definitions\n                parameterNames = [];\n            }\n\n            type = new CFuncType(d, type as CNotFuncType, parameterTypes, parameterNames, d.variadic);\n            d = d.body;\n        }\n    }\n    return type;\n}\n\nexport function getDeclaratorName(declarator: pt.Declarator | pt.InitDeclarator): string {\n    while (!(declarator instanceof pt.IdentifierDeclarator)) {\n        declarator = declarator.body;\n    }\n    return declarator.id;\n}\n\n/** Get the base type from the list of specifiers */\nfunction getSpecifierType(d: pt.SpecifierQualifiers | pt.DeclarationSpecifiers, scope: Scope): CType {\n    const specifiers = d.specifierList;\n    const singleSpecifier = specifiers.length === 1 ? specifiers[0] : undefined;\n\n    if (singleSpecifier instanceof pt.StructUnionSpecifier) {\n        const type = singleSpecifier.structure === \"struct\" ? CStruct : CUnion;\n        let structure = new type(singleSpecifier, singleSpecifier.id);\n        if (singleSpecifier.id) {\n            // lookup tag and if it already exists use the existing instance\n            const existing: CStruct | CUnion = scope.lookupTag(singleSpecifier.id, type as any, singleSpecifier) as any;\n            if (existing) {\n                structure = existing;\n            } else {\n                scope.addTag(structure);\n            }\n        }\n        if (!singleSpecifier.declarations) return structure;\n\n        const values: CCompoundMember[] = []; // populate struct/union members if provided\n        for (const declaration of singleSpecifier.declarations) {\n            const baseType = getType(declaration, scope);\n\n            for (const declarator of declaration.list) {\n                const type = getDeclaratorType(baseType, declarator, scope);\n                const name = getDeclaratorName(declarator);\n                if (type.incomplete || type.bytes === 0 || type instanceof CFuncType) {\n                    throw new ParseTreeValidationError(declarator, \"Type must be complete\");\n                }\n\n                values.push(new CCompoundMember(declaration, name, type));\n            }\n        }\n        structure.members = values;\n        structure.node = singleSpecifier; // set the parse node to point to the node which actually defined the members\n        return structure;\n\n    } else if (singleSpecifier instanceof pt.EnumSpecifier) {\n        let cEnum = new CEnum(singleSpecifier, singleSpecifier.id);\n        if (singleSpecifier.id) {\n            // lookup tag and if it already exists use its instance\n            const existing = scope.lookupTag(singleSpecifier.id, CEnum, singleSpecifier);\n            if (existing) {\n                cEnum = existing;\n            } else {\n                scope.addTag(cEnum);\n            }\n        }\n        if (!singleSpecifier.body) return CArithmetic.S32;\n\n        // enum members either provide their own value or use the last value + 1, starting at 0\n        let nextValue = 0n;\n        const values = [];\n        for (const e of singleSpecifier.body) { // populate enum\n            if (e.value) nextValue = evalIntegerConstant(e.value, scope).value;\n\n            // enum constants are `int`s!!!\n            const enumConstant = new CVarDefinition(e, e.id, addQualifier(CArithmetic.S32, \"const\"), \"static\", \"internal\");\n            enumConstant.staticValue = new CConstant(e, CArithmetic.S32, nextValue);\n\n            scope.addIdentifier(enumConstant); // add the enum member as a constant to the scope\n            values.push({name: e.id, value: nextValue++});\n        }\n        cEnum.values = values;\n        cEnum.node = singleSpecifier;\n        return CArithmetic.S32;\n\n    } else if (specifiers.every(x => typeof x === 'string')) {\n        // arithmetic or void\n        const type = getArithmeticType(specifiers as ReadonlyArray<pt.TypeSpecifier & string>);\n        if (type) return type;\n\n    } else if (specifiers.length === 1 && specifiers[0] instanceof pt.CustomTypeSpecifier) {\n        // typedef\n        return scope.lookupTypedef(specifiers[0].name);\n    }\n\n    throw new ParseTreeValidationError(d, \"Invalid specifier\");\n}\n","import {CError} from \"../c_error\";\nimport type {ParseNode} from \"../parsing\";\nimport type {CExpression} from \"./expressions\";\nimport {CArithmetic, CPointer, CStruct, CUnion, CType, CFuncType, checkTypeComplete} from \"./types\";\n\nexport class ExpressionTypeError extends CError {\n    name = \"ExpressionTypeError\";\n\n    constructor(node: ParseNode, readonly wantedType: string, readonly actualType?: string) {\n        super(actualType ? `Expected ${wantedType} but got ${actualType} instead!` : `Expected ${wantedType}`, node);\n    }\n}\n\n// Basic type checking for expressions, throws an exception if the expression's type is not the expected type\n\nexport function asArithmetic(node: ParseNode, t: CType): CArithmetic {\n    if (t instanceof CArithmetic) return t;\n    throw new ExpressionTypeError(node, \"arithmetic\", t.typeName);\n}\n\nexport function asInteger(node: ParseNode, t: CType): CArithmetic {\n    const arithmetic = asArithmetic(node, t);\n    switch (arithmetic.type) {\n    case \"signed\":\n    case \"unsigned\":\n        return arithmetic;\n    default:\n        throw new ExpressionTypeError(node, \"integer\", t.typeName);\n    }\n}\n\nexport function asPointer(node: ParseNode, t: CType): CPointer {\n    if (t instanceof CPointer) return t;\n    throw new ExpressionTypeError(node, \"pointer\", t.typeName);\n}\n\nexport function asArithmeticOrPointer(node: ParseNode, t: CType): CArithmetic | CPointer {\n    if (t instanceof CArithmetic) return t;\n    if (t instanceof CPointer) return t;\n    throw new ExpressionTypeError(node, \"arithmetic or pointer\", t.typeName);\n}\n\nexport function asNonFunctionPointer<T extends CType>(node: ParseNode, t: T): T {\n    if (t instanceof CPointer && t.type instanceof CFuncType) {\n        throw new ExpressionTypeError(node, \"non-function pointer\", \"function pointer\");\n    }\n    return t;\n}\n\nexport function asFunction(node: ParseNode, t: CType): CFuncType {\n    if (t instanceof CFuncType) return t;\n    if (t instanceof CPointer && t.type instanceof CFuncType) return t.type;\n    throw new ExpressionTypeError(node, \"function\", t.typeName);\n}\n\nexport function asStructOrUnion(node: ParseNode, t: CType): CStruct | CUnion {\n    checkTypeComplete(t);\n    if (t instanceof CStruct) return t;\n    if (t instanceof CUnion) return t;\n    throw new ExpressionTypeError(node, \"struct or union\", t.typeName);\n}\n\nexport function checkLvalue(expression: CExpression, lvalue: boolean): CExpression {\n    if (expression.lvalue === lvalue) return expression;\n    throw new ExpressionTypeError(expression.node, `lvalue=${lvalue}`, `lvalue=${expression.lvalue}`);\n}\n","import {CError} from \"../c_error\";\nimport type {TypeSpecifier, TypeQualifier, ParseNode} from \"../parsing/parsetree\";\n\n// types for expressions and declarations in the IR\nexport type CType = CNotFuncType | CFuncType;\nexport type CNotFuncType = CArithmetic | CPointer | CArray | CStruct | CUnion | CVoid;\nexport type CQualifiedType<T extends CType> = T & {qualifier?: TypeQualifier};\n\nexport class CFuncType {\n    readonly typeName = \"function\";\n    readonly bytes = 0;\n    readonly alignment = 1;\n    readonly incomplete = false;\n\n    constructor(readonly node: ParseNode | undefined,\n                readonly returnType: CQualifiedType<CNotFuncType>,\n                readonly parameterTypes: CQualifiedType<CNotFuncType>[],\n                public parameterNames?: string[],\n                readonly variadic: boolean = false) {\n        // return type and parameter types must be complete\n        if (!(returnType instanceof CVoid)) checkTypeComplete(returnType);\n        parameterTypes.forEach(x => checkTypeComplete(x));\n    }\n\n    equals(t: Object): boolean {\n        return t instanceof CFuncType\n            && t.returnType.equals(this.returnType)\n            && t.parameterTypes.length === this.parameterTypes.length\n            && t.parameterTypes.every((other, i) => this.parameterTypes[i].equals(other))\n            && t.variadic === this.variadic;\n    }\n}\n\nexport class CPointer {\n    readonly typeName = \"pointer\";\n    readonly bytes = 4;\n    readonly alignment = 4;\n    readonly incomplete = false;\n    readonly qualifier?: TypeQualifier;\n\n    constructor(readonly node: ParseNode | undefined, readonly type: CType, constant: boolean = false) {\n        // allow pointers to incomplete types\n        if (constant) this.qualifier = \"const\";\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CPointer && t.qualifier === this.qualifier && this.type.equals(t.type);\n    }\n}\n\nexport class CArray {\n    readonly typeName = \"array\";\n    readonly alignment: number;\n\n    constructor(readonly node: ParseNode | undefined, readonly type: CType, public length?: number) {\n        checkTypeComplete(type);\n        this.alignment = type.alignment;\n    }\n\n    get bytes(): number {\n        if (this.length === undefined) throw new Error(\"Tried to get size of incomplete type\");\n        return this.type.bytes * this.length;\n    }\n\n    get incomplete(): boolean {\n        return this.length === undefined;\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CArray && t.length === this.length && this.type.equals(t.type);\n    }\n}\n\nexport type CCompound = CStruct | CUnion | CEnum;\n\nexport class CCompoundMember {\n    constructor(readonly node: ParseNode, readonly name: string, readonly type: CQualifiedType<CNotFuncType>) {}\n}\n\nexport class CStruct {\n    readonly typeName = \"struct\";\n    private _members: ReadonlyArray<CCompoundMember> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get members(): ReadonlyArray<CCompoundMember> {\n        if (this._members === undefined) throw new Error(\"Can't get members of an incomplete struct\");\n        return this._members;\n    }\n\n    set members(children: ReadonlyArray<CCompoundMember>) {\n        if (this._members !== undefined) throw new Error(\"Can't redefine a struct's members\");\n        if (children.length === 0) throw new Error(\"Struct must have one or more member\");\n        this._members = children;\n    }\n\n    get bytes(): number {\n        if (this.incomplete) throw new Error(\"Tried to get size of incomplete type\");\n        return this.members.reduce((total, x) => {\n            // align member type\n            total = Math.ceil(total / x.type.alignment) * x.type.alignment;\n            return total + x.type.bytes;\n        }, 0);\n    }\n\n    get alignment(): number {\n        return Math.max(...this.members.map(x => x.type.alignment));\n    }\n\n    get incomplete(): boolean {\n        return this._members === undefined;\n    }\n\n    equals(t: object): boolean {\n        /** \"Structures, unions and enumerations with different tags are distinct,\n         * and a tagless union, structure, or enumeration specifies a unique type\" */\n        if (this.name === undefined) return this === t;\n        return t instanceof CStruct && t.name === this.name;\n    }\n\n    memberType(m: string): CType {\n        const member = this.members.find(x => x.name === m);\n        if (member) return member.type;\n        throw new Error(`Struct does not contain member \"${m}\"`);\n    }\n\n    hasConstMember(): boolean { // if the struct contains one or more const members\n        return this.members.find(m =>\n            getQualifier(m.type) || ((m.type instanceof CUnion || m.type instanceof CStruct) && m.type.hasConstMember())\n        ) !== undefined;\n    }\n}\n\nexport class CUnion {\n    readonly typeName = \"union\";\n    private _members: ReadonlyArray<CCompoundMember> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get members(): ReadonlyArray<CCompoundMember> {\n        if (this._members === undefined) throw new Error(\"Can't get members of an incomplete union\");\n        return this._members;\n    }\n\n    set members(children: ReadonlyArray<CCompoundMember>) {\n        if (this._members !== undefined) throw new Error(\"Can't redefine a union's members\");\n        if (children.length === 0) throw new Error(\"Struct must have one or more member\");\n        this._members = children;\n    }\n\n    get bytes(): number {\n        if (this.incomplete) throw new Error(\"Tried to get size of incomplete type\");\n        return this.members.reduce((total, x) => Math.max(total, x.type.bytes), 0);\n    }\n\n    get alignment(): number {\n        return Math.max(...this.members.map(x => x.type.alignment));\n    }\n\n    get incomplete(): boolean {\n        return this._members === undefined;\n    }\n\n    equals(t: object): boolean {\n        if (this.name === undefined) return this === t;\n        return t instanceof CUnion && t.name === this.name;\n    }\n\n    memberType(m: string): CType {\n        const member = this.members.find(x => x.name === m);\n        if (member) return member.type;\n        throw new Error(`Union does not contain member \"${m}\"`);\n    }\n\n    hasConstMember(): boolean { // if the union has one or more const members\n        return this.members.find(m =>\n            getQualifier(m.type) || ((m.type instanceof CUnion || m.type instanceof CStruct) && m.type.hasConstMember())\n        ) !== undefined;\n    }\n}\n\nexport type CEnumValue = {name: string, value: bigint};\nexport class CEnum {\n    readonly typeName = \"enum\";\n    private _values: ReadonlyArray<CEnumValue> | undefined;\n\n    constructor(public node: ParseNode | undefined, readonly name: string | undefined) {\n    }\n\n    get values(): ReadonlyArray<CEnumValue> {\n        if (this._values === undefined) throw new Error(\"Can't get values of an incomplete enum\");\n        return this._values;\n    }\n\n    set values(children: ReadonlyArray<CEnumValue>) {\n        if (this._values !== undefined) throw new Error(\"Can't redefine an enum's values\");\n        if (children.length === 0) throw new Error(\"Enum must have one or more value\");\n        this._values = children;\n    }\n\n    get incomplete(): boolean {\n        return this._values === undefined;\n    }\n\n    equals(t: object): boolean {\n        if (this.name === undefined) return this === t;\n        return t instanceof CEnum && t.name === this.name;\n    }\n}\n\nexport class CVoid {\n    readonly typeName = \"void\";\n    readonly bytes = 0;\n    readonly alignment = 1;\n    readonly incomplete = true;\n    readonly node = undefined;\n\n    equals(t: object): boolean {\n        return t instanceof CVoid;\n    }\n}\n\nexport class CArithmetic {\n    readonly typeName = \"arithmetic\";\n    readonly incomplete = false;\n    readonly node = undefined;\n    readonly alignment: number;\n\n    private constructor(readonly name: string, readonly bytes: number, readonly type: \"float\" | \"signed\" | \"unsigned\") {\n        this.alignment = bytes;\n    }\n\n    equals(t: object): boolean {\n        return t instanceof CArithmetic && t.name === this.name && t.type === this.type && t.bytes === this.bytes;\n    }\n\n    get minValue(): bigint | number {\n        if (CArithmetic.BOOL.equals(this)) return 0;\n\n        switch (this.type) {\n        case \"float\":\n            return -Infinity;\n        case \"unsigned\":\n            return 0;\n        case \"signed\":\n            return -(2n ** (BigInt(this.bytes * 8) - 1n));\n        }\n    }\n\n    get maxValue(): bigint | number {\n        if (CArithmetic.BOOL.equals(this)) return 1;\n\n        switch (this.type) {\n        case \"float\":\n            return Infinity;\n        case \"unsigned\":\n            return 2n ** BigInt(this.bytes * 8) - 1n;\n        case \"signed\":\n            return 2n ** (BigInt(this.bytes * 8) - 1n) - 1n;\n        }\n    }\n\n    static readonly Fp32 = new CArithmetic(\"float\", 4, \"float\");\n    static readonly Fp64 = new CArithmetic(\"double\", 8, \"float\");\n\n    static readonly U8 = new CArithmetic(\"char\", 1, \"unsigned\");\n    static readonly S8 = new CArithmetic(\"signed char\", 1, \"signed\");\n    static readonly U16 = new CArithmetic(\"unsigned short\", 2, \"unsigned\");\n    static readonly S16 = new CArithmetic(\"short\", 2, \"signed\");\n    static readonly U32 = new CArithmetic(\"unsigned int\", 4, \"unsigned\");\n    static readonly S32 = new CArithmetic(\"int\", 4, \"signed\");\n    static readonly U64 = new CArithmetic(\"unsigned long\", 8, \"unsigned\");\n    static readonly S64 = new CArithmetic(\"long\", 8, \"signed\");\n\n    static readonly BOOL = new CArithmetic(\"bool\", 4, \"signed\");\n}\n\nexport const CSizeT = CArithmetic.U32;\n\n\nconst constType = Symbol(\"const\"); // hidden property key\n\n/**\n * Add a qualifier to a type.\n *\n * This creates a new object with the qualifier attached, using the existing type as its prototype, allowing it to be\n * treated as the existing type. This new object is also cached on the existing type using a field referenced by a\n * symbol, so it can't be accessed when enumerating the fields and doesn't affect existing code.\n */\nexport function addQualifier<T extends CType>(t: T, qualifier?: TypeQualifier): CQualifiedType<T> {\n    if (qualifier === undefined) return t;\n    if (Object.prototype.hasOwnProperty.call(t, \"qualifier\")) {\n        throw new Error(\"Type already has a qualifier\");\n    }\n\n    const baseType = t as Record<typeof constType, any>;\n    if (baseType[constType]) {\n        // const type already exists\n        return baseType[constType];\n    }\n\n    const type = Object.setPrototypeOf({qualifier, _base: t}, t);\n    baseType[constType] = type;\n    return type;\n}\n\nexport function getQualifier(t: CQualifiedType<CType>): TypeQualifier | undefined {\n    return t?.qualifier;\n}\n\n/** integer promotion from the C standard */\nexport function integerPromotion(t: CArithmetic): CArithmetic {\n    if (t.type === \"float\") return t;\n    if (t.bytes < CArithmetic.S32.bytes || t === CArithmetic.BOOL) return CArithmetic.S32;\n    return t;\n}\n\n/** \"The usual arithmetic conversions\" from the C standard */\nexport function usualArithmeticConversion(t1: CArithmetic, t2: CArithmetic): CArithmetic {\n    if (t1 === CArithmetic.Fp64 || t2 === CArithmetic.Fp64) return CArithmetic.Fp64;\n    if (t1 === CArithmetic.Fp32 || t2 === CArithmetic.Fp32) return CArithmetic.Fp32;\n\n    // integer promotion\n    t1 = integerPromotion(t1);\n    t2 = integerPromotion(t2);\n\n    if (t1 === CArithmetic.U64 || t2 === CArithmetic.U64) return CArithmetic.U64;\n    if (t1 === CArithmetic.S64 || t2 === CArithmetic.S64) return CArithmetic.S64;\n    if (t1 === CArithmetic.U32 || t2 === CArithmetic.U32) return CArithmetic.U32;\n    return CArithmetic.S32;\n}\n\n/** Convert a list of specifier strings (e.g. \"signed\", \"int\") into a CType instance. */\nexport function getArithmeticType(specifierList: ReadonlyArray<TypeSpecifier & string>): CArithmetic | CVoid | undefined {\n    const copy = specifierList.slice();\n\n    function remove(s: TypeSpecifier & string) { // remove an item from a list if present, and return whether it was\n        const idx = copy.indexOf(s);\n        if (idx > -1) {\n            copy.splice(idx, 1);\n            return true;\n        }\n        return false;\n    }\n\n    function check<T>(x: T): T | undefined { // check that there are no specifiers left to be processed\n        if (copy.length > 0) return undefined; // extra specifiers so this type is invalid (e.g. \"unsigned signed int\")\n        return x;\n    }\n\n    if (remove(\"void\")) { // if \"void\" in list\n        return check(new CVoid()); // then the type must be void, check no extra specifiers were provided\n    } else if (remove(\"double\")) {\n        remove(\"long\"); // remove \"long\" if present, as treating \"long double\" as normal doubles\n        return check(CArithmetic.Fp64);\n    } else if (remove(\"float\")) {\n        return check(CArithmetic.Fp32);\n    } else if (remove(\"char\")) {\n        if (remove(\"signed\")) return check(CArithmetic.S8);\n        remove(\"unsigned\");\n        return check(CArithmetic.U8);\n    } else if (remove(\"short\")) {\n        remove(\"int\"); // remove optional \"int\" (\"short int\" === \"int\")\n        if (remove(\"unsigned\")) return check(CArithmetic.U16);\n        remove(\"signed\");\n        return check(CArithmetic.S16);\n    } else if (remove(\"long\")) {\n        remove(\"long\"); // remove an 2nd \"long\" if present, as treating \"long long\" as \"long\"\n        remove(\"int\");\n        if (remove(\"unsigned\")) return check(CArithmetic.U64);\n        remove(\"signed\");\n        return check(CArithmetic.S64);\n    } else if (remove(\"int\")) {\n        if (remove(\"unsigned\")) return check(CArithmetic.U32);\n        remove(\"signed\");\n        return check(CArithmetic.S32);\n    } else if (remove(\"unsigned\")) { // support just `unsigned` and `signed`\n        return check(CArithmetic.U32);\n    } else if (remove(\"signed\")) {\n        return check(CArithmetic.S32);\n    } else if (remove(\"bool\")) {\n        return check(CArithmetic.BOOL);\n    }\n    return undefined;\n}\n\n/** Assert that type is complete */\nexport function checkTypeComplete<T extends CType>(type: T, node: ParseNode | undefined = type.node): T {\n    if (type.incomplete) {\n        throw new class extends CError {\n            name = \"IncompleteTypeError\";\n        }(\"Invalid use of an incomplete type\", node);\n    }\n    return type;\n}\n","\n/* parser generated by jison 0.6.1-215 */\n\n/*\n * Returns a Parser object of the following structure:\n *\n *  Parser: {\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\n *               the real \"shared state\" `yy` passed around to\n *               the rule actions, etc. is a derivative/copy of this one,\n *               not a direct reference!\n *  }\n *\n *  Parser.prototype: {\n *    yy: {},\n *    EOF: 1,\n *    TERROR: 2,\n *\n *    trace: function(errorMessage, ...),\n *\n *    JisonParserError: function(msg, hash),\n *\n *    quoteName: function(name),\n *               Helper function which can be overridden by user code later on: put suitable\n *               quotes around literal IDs in a description string.\n *\n *    originalQuoteName: function(name),\n *               The basic quoteName handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function\n *               at the end of the `parse()`.\n *\n *    describeSymbol: function(symbol),\n *               Return a more-or-less human-readable description of the given symbol, when\n *               available, or the symbol itself, serving as its own 'description' for lack\n *               of something better to serve up.\n *\n *               Return NULL when the symbol is unknown to the parser.\n *\n *    symbols_: {associative list: name ==> number},\n *    terminals_: {associative list: number ==> name},\n *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},\n *    terminal_descriptions_: (if there are any) {associative list: number ==> description},\n *    productions_: [...],\n *\n *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)\n *                             to store/reference the rule value `$$` and location info `@$`.\n *\n *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets\n *                 to see the same object via the `this` reference, i.e. if you wish to carry custom\n *                 data from one reduce action through to the next within a single parse run, then you\n *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.\n *\n *                 `this.yy` is a direct reference to the `yy` shared state object.\n *\n *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`\n *                 object at `parse()` start and are therefore available to the action code via the\n *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from\n *                 the %parse-param` list.\n *\n *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used\n *                             to match this rule. This is *not* the look-ahead token, but the last token\n *                             that's actually part of this rule.\n *\n *                 Formulated another way, `yytext` is the value of the token immediately preceeding\n *                 the current look-ahead token.\n *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.\n *\n *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.\n *\n *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.\n *\n *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.\n *\n *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead\n *                               of an empty object when no suitable location info can be provided.\n *\n *               - `yystate` : the current parser state number, used internally for dispatching and\n *                               executing the action code chunk matching the rule currently being reduced.\n *\n *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *                 Also note that you can access this and other stack index values using the new double-hash\n *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things\n *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.\n *                 This is made available to write very advanced grammar action rules, e.g. when you want\n *                 to investigate the parse state stack in your action code, which would, for example,\n *                 be relevant when you wish to implement error diagnostics and reporting schemes similar\n *                 to the work described here:\n *\n *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.\n *                   In Journées Francophones des Languages Applicatifs.\n *\n *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.\n *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.\n *\n *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.\n *                             constructs.\n *\n *               - `yylstack`: reference to the parser token location stack. Also accessed via\n *                             the `@1` etc. constructs.\n *\n *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are\n *                             UNDEFINED rather than an empty (location) object, when the lexer/parser\n *                             action code did not provide a suitable location info object when such a\n *                             slot was filled!\n *\n *               - `yystack` : reference to the parser token id stack. Also accessed via the\n *                             `#1` etc. constructs.\n *\n *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to\n *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might\n *                 want access this array for your own purposes, such as error analysis as mentioned above!\n *\n *                 Note that this stack stores the current stack of *tokens*, that is the sequence of\n *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*\n *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and\n *                 *reduced*.\n *\n *               - `yysstack`: reference to the parser state stack. This one carries the internal parser\n *                             *states* such as the one in `yystate`, which are used to represent\n *                             the parser state machine in the *parse table*. *Very* *internal* stuff,\n *                             what can I say? If you access this one, you're clearly doing wicked things\n *\n *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your\n *                             grammar definition file.\n *\n *    table: [...],\n *               State transition table\n *               ----------------------\n *\n *               index levels are:\n *               - `state`  --> hash table\n *               - `symbol` --> action (number or array)\n *\n *                 If the `action` is an array, these are the elements' meaning:\n *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept\n *                 - index [1]: GOTO `state`\n *\n *                 If the `action` is a number, it is the GOTO `state`\n *\n *    defaultActions: {...},\n *\n *    parseError: function(str, hash, ExceptionClass),\n *    yyError: function(str, ...),\n *    yyRecovering: function(),\n *    yyErrOk: function(),\n *    yyClearIn: function(),\n *\n *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\n *               See it's use in this parser kernel in many places; example usage:\n *\n *                   var infoObj = parser.constructParseErrorInfo('fail!', null,\n *                                     parser.collect_expected_token_set(state), true);\n *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);\n *\n *    originalParseError: function(str, hash, ExceptionClass),\n *               The basic `parseError` handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function\n *               at the end of the `parse()`.\n *\n *    options: { ... parser %options ... },\n *\n *    parse: function(input[, args...]),\n *               Parse the given `input` and return the parsed value (or `true` when none was provided by\n *               the root action, in which case the parser is acting as a *matcher*).\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the jison run-time;\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\n *               from silently accepting this confusing and potentially hazardous situation!\n *\n *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in\n *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state\n *               object and any collision with those will be reported by the lexer via a thrown exception.\n *\n *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown\n *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY\n *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and\n *               the internal parser gets properly garbage collected under these particular circumstances.\n *\n *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API can be invoked to calculate a spanning `yylloc` location info object.\n *\n *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case\n *               this function will attempt to obtain a suitable location marker by inspecting the location stack\n *               backwards.\n *\n *               For more info see the documentation comment further below, immediately above this function's\n *               implementation.\n *\n *    lexer: {\n *        yy: {...},           A reference to the so-called \"shared state\" `yy` once\n *                             received via a call to the `.setInput(input, yy)` lexer API.\n *        EOF: 1,\n *        ERROR: 2,\n *        JisonLexerError: function(msg, hash),\n *        parseError: function(str, hash, ExceptionClass),\n *        setInput: function(input, [yy]),\n *        input: function(),\n *        unput: function(str),\n *        more: function(),\n *        reject: function(),\n *        less: function(n),\n *        pastInput: function(n),\n *        upcomingInput: function(n),\n *        showPosition: function(),\n *        test_match: function(regex_match_array, rule_index, ...),\n *        next: function(...),\n *        lex: function(...),\n *        begin: function(condition),\n *        pushState: function(condition),\n *        popState: function(),\n *        topState: function(),\n *        _currentRules: function(),\n *        stateStackSize: function(),\n *        cleanupAfterLex: function()\n *\n *        options: { ... lexer %options ... },\n *\n *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),\n *        rules: [...],\n *        conditions: {associative list: name ==> set},\n *    }\n *  }\n *\n *\n *  token location info (@$, _$, etc.): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a 'hash' object with these members for lexer and\n * parser errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *  }\n *\n * parser (grammar) errors will also provide these additional members:\n *\n *  {\n *    expected:    (array describing the set of expected tokens;\n *                  may be UNDEFINED when we cannot easily produce such a set)\n *    state:       (integer (or array when the table includes grammar collisions);\n *                  represents the current internal state of the parser kernel.\n *                  can, for example, be used to pass to the `collect_expected_token_set()`\n *                  API to obtain the expected token set)\n *    action:      (integer; represents the current internal action which will be executed)\n *    new_state:   (integer; represents the next/planned internal state, once the current\n *                  action has executed)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    yy:          (object: the current parser internal \"shared state\" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *    parser:      (reference to the current parser instance)\n *  }\n *\n * while `this` will reference the current parser instance.\n *\n * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    lexer:       (reference to the current lexer instance which reported the error)\n *  }\n *\n * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired\n * from either the parser or lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    exception:   (reference to the exception thrown)\n *  }\n *\n * Please do note that in the latter situation, the `expected` field will be omitted as\n * this type of failure is assumed not to be due to *parse errors* but rather due to user\n * action code in either parser or lexer failing unexpectedly.\n *\n * ---\n *\n * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.\n * These options are available:\n *\n * ### options which are global for all parser instances\n *\n *  Parser.pre_parse: function(yy)\n *                 optional: you can specify a pre_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`.\n *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: you can specify a post_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`. When it does not return any value,\n *                 the parser will return the original `retval`.\n *\n * ### options which can be set up per parser instance\n *\n *  yy: {\n *      pre_parse:  function(yy)\n *                 optional: is invoked before the parse cycle starts (and before the first\n *                 invocation of `lex()`) but immediately after the invocation of\n *                 `parser.pre_parse()`).\n *      post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: is invoked when the parse terminates due to success ('accept')\n *                 or failure (even when exceptions are thrown).\n *                 `retval` contains the return value to be produced by `Parser.parse()`;\n *                 this function can override the return value by returning another.\n *                 When it does not return any value, the parser will return the original\n *                 `retval`.\n *                 This function is invoked immediately before `parser.post_parse()`.\n *\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *      quoteName: function(name),\n *                 optional: overrides the default `quoteName` function.\n *  }\n *\n *  parser.lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\n *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */\n\n        \n    \n            var c_grammar = (function () {\n\n\n// See also:\n// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n// with userland code which might access the derived class in a 'classic' way.\nfunction JisonParserError(msg, hash) {\n    Object.defineProperty(this, 'name', {\n        enumerable: false,\n        writable: false,\n        value: 'JisonParserError'\n    });\n\n    if (msg == null) msg = '???';\n\n    Object.defineProperty(this, 'message', {\n        enumerable: false,\n        writable: true,\n        value: msg\n    });\n\n    this.hash = hash;\n\n    var stacktrace;\n    if (hash && hash.exception instanceof Error) {\n        var ex2 = hash.exception;\n        this.message = ex2.message || msg;\n        stacktrace = ex2.stack;\n    }\n    if (!stacktrace) {\n        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            stacktrace = (new Error(msg)).stack;\n        }\n    }\n    if (stacktrace) {\n        Object.defineProperty(this, 'stack', {\n            enumerable: false,\n            writable: false,\n            value: stacktrace\n        });\n    }\n}\n\nif (typeof Object.setPrototypeOf === 'function') {\n    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);\n} else {\n    JisonParserError.prototype = Object.create(Error.prototype);\n}\nJisonParserError.prototype.constructor = JisonParserError;\nJisonParserError.prototype.name = 'JisonParserError';\n\n\n\n\n        // helper: reconstruct the productions[] table\n        function bp(s) {\n            var rv = [];\n            var p = s.pop;\n            var r = s.rule;\n            for (var i = 0, l = p.length; i < l; i++) {\n                rv.push([\n                    p[i],\n                    r[i]\n                ]);\n            }\n            return rv;\n        }\n    \n\n\n        // helper: reconstruct the defaultActions[] table\n        function bda(s) {\n            var rv = {};\n            var d = s.idx;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var j = d[i];\n                rv[j] = g[i];\n            }\n            return rv;\n        }\n    \n\n\n        // helper: reconstruct the 'goto' table\n        function bt(s) {\n            var rv = [];\n            var d = s.len;\n            var y = s.symbol;\n            var t = s.type;\n            var a = s.state;\n            var m = s.mode;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var n = d[i];\n                var q = {};\n                for (var j = 0; j < n; j++) {\n                    var z = y.shift();\n                    switch (t.shift()) {\n                    case 2:\n                        q[z] = [\n                            m.shift(),\n                            g.shift()\n                        ];\n                        break;\n\n                    case 0:\n                        q[z] = a.shift();\n                        break;\n\n                    default:\n                        // type === 1: accept\n                        q[z] = [\n                            3\n                        ];\n                    }\n                }\n                rv.push(q);\n            }\n            return rv;\n        }\n    \n\n\n        // helper: runlength encoding with increment step: code, length: step (default step = 0)\n        // `this` references an array\n        function s(c, l, a) {\n            a = a || 0;\n            for (var i = 0; i < l; i++) {\n                this.push(c);\n                c += a;\n            }\n        }\n\n        // helper: duplicate sequence from *relative* offset and length.\n        // `this` references an array\n        function c(i, l) {\n            i = this.length - i;\n            for (l += i; i < l; i++) {\n                this.push(this[i]);\n            }\n        }\n\n        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.\n        function u(a) {\n            var rv = [];\n            for (var i = 0, l = a.length; i < l; i++) {\n                var e = a[i];\n                // Is this entry a helper function?\n                if (typeof e === 'function') {\n                    i++;\n                    e.apply(rv, a[i]);\n                } else {\n                    rv.push(e);\n                }\n            }\n            return rv;\n        }\n    \n\nvar parser = {\n    // Code Generator Information Report\n    // ---------------------------------\n    //\n    // Options:\n    //\n    //   default action mode: ............. [\"none\",\"merge\"]\n    //   test-compile action mode: ........ \"parser:*,lexer:*\"\n    //   try..catch: ...................... true\n    //   default resolve on conflict: ..... true\n    //   on-demand look-ahead: ............ false\n    //   error recovery token skip maximum: 3\n    //   yyerror in parse actions is: ..... NOT recoverable,\n    //   yyerror in lexer actions and other non-fatal lexer are:\n    //   .................................. NOT recoverable,\n    //   debug grammar/output: ............ false\n    //   has partial LR conflict upgrade:   true\n    //   rudimentary token-stack support:   false\n    //   parser table compression mode: ... 2\n    //   export debug tables: ............. false\n    //   export *all* tables: ............. false\n    //   module type: ..................... commonjs\n    //   parser engine type: .............. lalr\n    //   output main() in the module: ..... true\n    //   has user-specified main(): ....... false\n    //   has user-specified require()/import modules for main():\n    //   .................................. false\n    //   number of expected conflicts: .... 0\n    //\n    //\n    // Parser Analysis flags:\n    //\n    //   no significant actions (parser is a language matcher only):\n    //   .................................. false\n    //   uses yyleng: ..................... false\n    //   uses yylineno: ................... false\n    //   uses yytext: ..................... true\n    //   uses yylloc: ..................... false\n    //   uses ParseError API: ............. false\n    //   uses YYERROR: .................... false\n    //   uses YYRECOVERING: ............... false\n    //   uses YYERROK: .................... false\n    //   uses YYCLEARIN: .................. false\n    //   tracks rule values: .............. true\n    //   assigns rule values: ............. true\n    //   uses location tracking: .......... true\n    //   assigns location: ................ true\n    //   uses yystack: .................... false\n    //   uses yysstack: ................... false\n    //   uses yysp: ....................... true\n    //   uses yyrulelength: ............... false\n    //   uses yyMergeLocationInfo API: .... true\n    //   has error recovery: .............. false\n    //   has error reporting: ............. false\n    //\n    // --------- END OF REPORT -----------\n\ntrace: function no_op_trace() { },\nJisonParserError: JisonParserError,\nyy: {},\noptions: {\n  type: \"lalr\",\n  hasPartialLrUpgradeOnConflict: true,\n  errorRecoveryTokenDiscardCount: 3\n},\nsymbols_: {\n  \"!\": 14,\n  \"$accept\": 0,\n  \"$end\": 1,\n  \"%\": 16,\n  \"&\": 9,\n  \"(\": 3,\n  \")\": 4,\n  \"*\": 10,\n  \"+\": 11,\n  \",\": 8,\n  \"-\": 12,\n  \".\": 7,\n  \"/\": 15,\n  \":\": 22,\n  \";\": 24,\n  \"<\": 17,\n  \"=\": 23,\n  \">\": 18,\n  \"?\": 21,\n  \"ADD_ASSIGN\": 49,\n  \"AND_ASSIGN\": 53,\n  \"AND_OP\": 44,\n  \"BREAK\": 87,\n  \"CASE\": 77,\n  \"CHAR\": 60,\n  \"CONST\": 73,\n  \"CONSTANT_CHAR\": 32,\n  \"CONSTANT_FLOAT\": 28,\n  \"CONSTANT_HEX\": 29,\n  \"CONSTANT_INT\": 31,\n  \"CONSTANT_OCTAL\": 30,\n  \"CONTINUE\": 86,\n  \"DEC_OP\": 36,\n  \"DEFAULT\": 78,\n  \"DIV_ASSIGN\": 47,\n  \"DO\": 83,\n  \"DOUBLE\": 65,\n  \"ELLIPSIS\": 76,\n  \"ELSE\": 80,\n  \"ENUM\": 72,\n  \"EOF\": 1,\n  \"EQ_OP\": 42,\n  \"EXTERN\": 57,\n  \"FLOAT\": 64,\n  \"FOR\": 84,\n  \"GE_OP\": 41,\n  \"GOTO\": 85,\n  \"IDENTIFIER\": 27,\n  \"IF\": 79,\n  \"IMPORT\": 75,\n  \"INC_OP\": 35,\n  \"INLINE\": 74,\n  \"INT\": 62,\n  \"LEFT_ASSIGN\": 51,\n  \"LEFT_OP\": 38,\n  \"LE_OP\": 40,\n  \"LONG\": 63,\n  \"MOD_ASSIGN\": 48,\n  \"MUL_ASSIGN\": 46,\n  \"NE_OP\": 43,\n  \"OR_ASSIGN\": 55,\n  \"OR_OP\": 45,\n  \"PTR_OP\": 34,\n  \"RETURN\": 88,\n  \"RIGHT_ASSIGN\": 52,\n  \"RIGHT_OP\": 39,\n  \"SHORT\": 61,\n  \"SIGNED\": 66,\n  \"SIZEOF\": 37,\n  \"STATIC\": 58,\n  \"STRING_LITERAL\": 33,\n  \"STRUCT\": 70,\n  \"SUB_ASSIGN\": 50,\n  \"SWITCH\": 81,\n  \"TYPEDEF\": 56,\n  \"TYPE_NAME\": 69,\n  \"UNION\": 71,\n  \"UNSIGNED\": 67,\n  \"VOID\": 59,\n  \"WHILE\": 82,\n  \"XOR_ASSIGN\": 54,\n  \"[\": 5,\n  \"]\": 6,\n  \"^\": 19,\n  \"_BOOL\": 68,\n  \"abstract_declarator\": 141,\n  \"additive_expression\": 101,\n  \"and_expression\": 105,\n  \"argument_expression_list\": 96,\n  \"assignment_expression\": 111,\n  \"assignment_operator\": 112,\n  \"ast_tree\": 89,\n  \"block_item\": 149,\n  \"block_item_list\": 148,\n  \"cast_expression\": 99,\n  \"compound_statement\": 147,\n  \"concat_string_literals\": 93,\n  \"conditional_expression\": 110,\n  \"constant\": 91,\n  \"constant_expression\": 114,\n  \"declaration\": 115,\n  \"declaration_specifiers\": 116,\n  \"declarator\": 133,\n  \"direct_abstract_declarator\": 142,\n  \"direct_declarator\": 134,\n  \"enum_specifier\": 128,\n  \"enumerator\": 130,\n  \"enumerator_list\": 129,\n  \"equality_expression\": 104,\n  \"error\": 2,\n  \"exclusive_or_expression\": 106,\n  \"expression\": 113,\n  \"expression_statement\": 150,\n  \"external_declaration\": 155,\n  \"function_definition\": 156,\n  \"function_specifier\": 132,\n  \"identifier\": 90,\n  \"inclusive_or_expression\": 107,\n  \"init_declarator\": 118,\n  \"init_declarator_list\": 117,\n  \"initializer\": 143,\n  \"initializer_list\": 144,\n  \"iteration_statement\": 152,\n  \"jump_statement\": 153,\n  \"labeled_statement\": 146,\n  \"logical_and_expression\": 108,\n  \"logical_or_expression\": 109,\n  \"multiplicative_expression\": 100,\n  \"parameter_declaration\": 139,\n  \"parameter_list\": 138,\n  \"parameter_type_list\": 137,\n  \"pointer\": 135,\n  \"postfix_expression\": 95,\n  \"primary_expression\": 94,\n  \"relational_expression\": 103,\n  \"selection_statement\": 151,\n  \"shift_expression\": 102,\n  \"specifier_qualifier_list\": 125,\n  \"statement\": 145,\n  \"storage_class_specifier\": 119,\n  \"string_literal\": 92,\n  \"struct_declaration\": 124,\n  \"struct_declaration_list\": 123,\n  \"struct_declarator\": 127,\n  \"struct_declarator_list\": 126,\n  \"struct_or_union\": 122,\n  \"struct_or_union_specifier\": 121,\n  \"translation_unit\": 154,\n  \"type_name\": 140,\n  \"type_qualifier\": 131,\n  \"type_qualifier_list\": 136,\n  \"type_specifier\": 120,\n  \"unary_expression\": 97,\n  \"unary_operator\": 98,\n  \"{\": 25,\n  \"|\": 20,\n  \"}\": 26,\n  \"~\": 13\n},\nterminals_: {\n  1: \"EOF\",\n  2: \"error\",\n  3: \"(\",\n  4: \")\",\n  5: \"[\",\n  6: \"]\",\n  7: \".\",\n  8: \",\",\n  9: \"&\",\n  10: \"*\",\n  11: \"+\",\n  12: \"-\",\n  13: \"~\",\n  14: \"!\",\n  15: \"/\",\n  16: \"%\",\n  17: \"<\",\n  18: \">\",\n  19: \"^\",\n  20: \"|\",\n  21: \"?\",\n  22: \":\",\n  23: \"=\",\n  24: \";\",\n  25: \"{\",\n  26: \"}\",\n  27: \"IDENTIFIER\",\n  28: \"CONSTANT_FLOAT\",\n  29: \"CONSTANT_HEX\",\n  30: \"CONSTANT_OCTAL\",\n  31: \"CONSTANT_INT\",\n  32: \"CONSTANT_CHAR\",\n  33: \"STRING_LITERAL\",\n  34: \"PTR_OP\",\n  35: \"INC_OP\",\n  36: \"DEC_OP\",\n  37: \"SIZEOF\",\n  38: \"LEFT_OP\",\n  39: \"RIGHT_OP\",\n  40: \"LE_OP\",\n  41: \"GE_OP\",\n  42: \"EQ_OP\",\n  43: \"NE_OP\",\n  44: \"AND_OP\",\n  45: \"OR_OP\",\n  46: \"MUL_ASSIGN\",\n  47: \"DIV_ASSIGN\",\n  48: \"MOD_ASSIGN\",\n  49: \"ADD_ASSIGN\",\n  50: \"SUB_ASSIGN\",\n  51: \"LEFT_ASSIGN\",\n  52: \"RIGHT_ASSIGN\",\n  53: \"AND_ASSIGN\",\n  54: \"XOR_ASSIGN\",\n  55: \"OR_ASSIGN\",\n  56: \"TYPEDEF\",\n  57: \"EXTERN\",\n  58: \"STATIC\",\n  59: \"VOID\",\n  60: \"CHAR\",\n  61: \"SHORT\",\n  62: \"INT\",\n  63: \"LONG\",\n  64: \"FLOAT\",\n  65: \"DOUBLE\",\n  66: \"SIGNED\",\n  67: \"UNSIGNED\",\n  68: \"_BOOL\",\n  69: \"TYPE_NAME\",\n  70: \"STRUCT\",\n  71: \"UNION\",\n  72: \"ENUM\",\n  73: \"CONST\",\n  74: \"INLINE\",\n  75: \"IMPORT\",\n  76: \"ELLIPSIS\",\n  77: \"CASE\",\n  78: \"DEFAULT\",\n  79: \"IF\",\n  80: \"ELSE\",\n  81: \"SWITCH\",\n  82: \"WHILE\",\n  83: \"DO\",\n  84: \"FOR\",\n  85: \"GOTO\",\n  86: \"CONTINUE\",\n  87: \"BREAK\",\n  88: \"RETURN\"\n},\nTERROR: 2,\n    EOF: 1,\n\n    // internals: defined here so the object *structure* doesn't get modified by parse() et al,\n    // thus helping JIT compilers like Chrome V8.\n    originalQuoteName: null,\n    originalParseError: null,\n    cleanupAfterParse: null,\n    constructParseErrorInfo: null,\n    yyMergeLocationInfo: null,\n\n    __reentrant_call_depth: 0,      // INTERNAL USE ONLY\n    __error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n    __error_recovery_infos: [],     // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n\n    // APIs which will be set up depending on user action code analysis:\n    //yyRecovering: 0,\n    //yyErrOk: 0,\n    //yyClearIn: 0,\n\n    // Helper APIs\n    // -----------\n\n    // Helper function which can be overridden by user code later on: put suitable quotes around\n    // literal IDs in a description string.\n    quoteName: function parser_quoteName(id_str) {\n        return '\"' + id_str + '\"';\n    },\n\n    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    getSymbolName: function parser_getSymbolName(symbol) {\n        if (this.terminals_[symbol]) {\n            return this.terminals_[symbol];\n        }\n\n        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.\n        //\n        // An example of this may be where a rule's action code contains a call like this:\n        //\n        //      parser.getSymbolName(#$)\n        //\n        // to obtain a human-readable name of the current grammar rule.\n        var s = this.symbols_;\n        for (var key in s) {\n            if (s[key] === symbol) {\n                return key;\n            }\n        }\n        return null;\n    },\n\n    // Return a more-or-less human-readable description of the given symbol, when available,\n    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    describeSymbol: function parser_describeSymbol(symbol) {\n        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {\n            return this.terminal_descriptions_[symbol];\n        }\n        else if (symbol === this.EOF) {\n            return 'end of input';\n        }\n        var id = this.getSymbolName(symbol);\n        if (id) {\n            return this.quoteName(id);\n        }\n        return null;\n    },\n\n    // Produce a (more or less) human-readable list of expected tokens at the point of failure.\n    //\n    // The produced list may contain token or token set descriptions instead of the tokens\n    // themselves to help turning this output into something that easier to read by humans\n    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,\n    // expected terminals and nonterminals is produced.\n    //\n    // The returned list (array) will not contain any duplicate entries.\n    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {\n        var TERROR = this.TERROR;\n        var tokenset = [];\n        var check = {};\n        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?\n        // If so, use that one instead of the less palatable token set.\n        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {\n            return [\n                this.state_descriptions_[state]\n            ];\n        }\n        for (var p in this.table[state]) {\n            p = +p;\n            if (p !== TERROR) {\n                var d = do_not_describe ? p : this.describeSymbol(p);\n                if (d && !check[d]) {\n                    tokenset.push(d);\n                    check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.\n                }\n            }\n        }\n        return tokenset;\n    },\nproductions_: bp({\n  pop: u([\n  89,\n  89,\n  90,\n  s,\n  [91, 5],\n  92,\n  93,\n  93,\n  s,\n  [94, 4],\n  s,\n  [95, 8],\n  96,\n  96,\n  s,\n  [97, 6],\n  s,\n  [98, 6],\n  99,\n  99,\n  s,\n  [100, 4],\n  s,\n  [101, 3],\n  s,\n  [102, 3],\n  s,\n  [103, 5],\n  s,\n  [104, 3],\n  105,\n  105,\n  106,\n  106,\n  107,\n  107,\n  108,\n  108,\n  109,\n  109,\n  110,\n  110,\n  111,\n  111,\n  s,\n  [112, 11],\n  113,\n  113,\n  114,\n  115,\n  115,\n  s,\n  [116, 8],\n  117,\n  117,\n  118,\n  118,\n  s,\n  [119, 3],\n  s,\n  [120, 13],\n  s,\n  [121, 3],\n  122,\n  122,\n  123,\n  123,\n  124,\n  s,\n  [125, 4],\n  126,\n  126,\n  127,\n  s,\n  [128, 5],\n  129,\n  129,\n  130,\n  130,\n  131,\n  132,\n  132,\n  133,\n  133,\n  s,\n  [134, 6],\n  s,\n  [135, 4],\n  136,\n  136,\n  137,\n  137,\n  138,\n  138,\n  s,\n  [139, 3],\n  140,\n  140,\n  s,\n  [141, 3],\n  s,\n  [142, 9],\n  s,\n  [143, 3],\n  144,\n  144,\n  s,\n  [145, 6],\n  s,\n  [146, 3],\n  147,\n  147,\n  148,\n  148,\n  149,\n  149,\n  150,\n  150,\n  s,\n  [151, 3],\n  s,\n  [152, 6],\n  s,\n  [153, 5],\n  154,\n  154,\n  155,\n  155,\n  156\n]),\n  rule: u([\n  2,\n  s,\n  [1, 9],\n  c,\n  [10, 4],\n  3,\n  1,\n  4,\n  3,\n  4,\n  3,\n  3,\n  2,\n  2,\n  c,\n  [10, 3],\n  s,\n  [2, 4],\n  4,\n  s,\n  [1, 7],\n  4,\n  1,\n  s,\n  [3, 3],\n  c,\n  [4, 3],\n  c,\n  [3, 6],\n  c,\n  [8, 7],\n  c,\n  [36, 3],\n  c,\n  [4, 6],\n  5,\n  c,\n  [4, 3],\n  s,\n  [1, 11],\n  c,\n  [59, 3],\n  c,\n  [3, 3],\n  c,\n  [80, 3],\n  c,\n  [4, 4],\n  c,\n  [32, 4],\n  s,\n  [1, 15],\n  5,\n  4,\n  c,\n  [107, 4],\n  2,\n  3,\n  c,\n  [31, 4],\n  c,\n  [114, 4],\n  5,\n  5,\n  6,\n  c,\n  [40, 8],\n  c,\n  [17, 4],\n  c,\n  [130, 4],\n  c,\n  [125, 3],\n  c,\n  [67, 4],\n  c,\n  [21, 3],\n  c,\n  [139, 3],\n  c,\n  [22, 4],\n  c,\n  [46, 3],\n  3,\n  3,\n  4,\n  c,\n  [4, 4],\n  c,\n  [33, 3],\n  c,\n  [83, 8],\n  c,\n  [41, 3],\n  c,\n  [39, 5],\n  c,\n  [31, 3],\n  5,\n  7,\n  5,\n  5,\n  7,\n  6,\n  7,\n  6,\n  7,\n  c,\n  [49, 3],\n  c,\n  [20, 6],\n  3\n])\n}),\nperformAction: function parser__PerformAction(yytext, yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack) {\n\n          /* this == yyval */\n\n          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!\n          var yy = this.yy;\n          var yyparser = yy.parser;\n          var yylexer = yy.lexer;\n\n          \n\n          switch (yystate) {\ncase 0:\n    /*! Production::    $accept : ast_tree $end */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yylstack[yysp - 1];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-)\n    break;\n\ncase 1:\n    /*! Production::    ast_tree : translation_unit EOF */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,-,-,LT,LA,-,-)\n    \n    \n    return yyvstack[yysp - 1];\n    break;\n\ncase 2:\n    /*! Production::    ast_tree : EOF */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-):\n    this.$ = undefined;\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-)\n    \n    \n    return [];\n    break;\n\ncase 3:\n    /*! Production::    identifier : IDENTIFIER */\ncase 9:\n    /*! Production::    string_literal : STRING_LITERAL */\ncase 100:\n    /*! Production::    storage_class_specifier : TYPEDEF */\ncase 101:\n    /*! Production::    storage_class_specifier : EXTERN */\ncase 102:\n    /*! Production::    storage_class_specifier : STATIC */\ncase 103:\n    /*! Production::    type_specifier : VOID */\ncase 104:\n    /*! Production::    type_specifier : CHAR */\ncase 105:\n    /*! Production::    type_specifier : SHORT */\ncase 106:\n    /*! Production::    type_specifier : INT */\ncase 107:\n    /*! Production::    type_specifier : LONG */\ncase 108:\n    /*! Production::    type_specifier : FLOAT */\ncase 109:\n    /*! Production::    type_specifier : DOUBLE */\ncase 110:\n    /*! Production::    type_specifier : SIGNED */\ncase 111:\n    /*! Production::    type_specifier : UNSIGNED */\ncase 142:\n    /*! Production::    function_specifier : IMPORT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yytext);\n    break;\n\ncase 4:\n    /*! Production::    constant : CONSTANT_FLOAT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"float\"));\n    break;\n\ncase 5:\n    /*! Production::    constant : CONSTANT_HEX */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"hex\"));\n    break;\n\ncase 6:\n    /*! Production::    constant : CONSTANT_OCTAL */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"oct\"));\n    break;\n\ncase 7:\n    /*! Production::    constant : CONSTANT_INT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"int\"));\n    break;\n\ncase 8:\n    /*! Production::    constant : CONSTANT_CHAR */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Constant(this._$, yytext, \"char\"));\n    break;\n\ncase 10:\n    /*! Production::    concat_string_literals : string_literal */\ncase 13:\n    /*! Production::    primary_expression : constant */\ncase 16:\n    /*! Production::    postfix_expression : primary_expression */\ncase 26:\n    /*! Production::    unary_expression : postfix_expression */\ncase 38:\n    /*! Production::    cast_expression : unary_expression */\ncase 40:\n    /*! Production::    multiplicative_expression : cast_expression */\ncase 44:\n    /*! Production::    additive_expression : multiplicative_expression */\ncase 47:\n    /*! Production::    shift_expression : additive_expression */\ncase 50:\n    /*! Production::    relational_expression : shift_expression */\ncase 55:\n    /*! Production::    equality_expression : relational_expression */\ncase 58:\n    /*! Production::    and_expression : equality_expression */\ncase 60:\n    /*! Production::    exclusive_or_expression : and_expression */\ncase 62:\n    /*! Production::    inclusive_or_expression : exclusive_or_expression */\ncase 64:\n    /*! Production::    logical_and_expression : inclusive_or_expression */\ncase 66:\n    /*! Production::    logical_or_expression : logical_and_expression */\ncase 68:\n    /*! Production::    conditional_expression : logical_or_expression */\ncase 70:\n    /*! Production::    assignment_expression : conditional_expression */\ncase 83:\n    /*! Production::    expression : assignment_expression */\ncase 98:\n    /*! Production::    init_declarator : declarator */\ncase 113:\n    /*! Production::    type_specifier : struct_or_union_specifier */\ncase 114:\n    /*! Production::    type_specifier : enum_specifier */\ncase 130:\n    /*! Production::    struct_declarator : declarator */\ncase 144:\n    /*! Production::    declarator : direct_declarator */\ncase 167:\n    /*! Production::    abstract_declarator : direct_abstract_declarator */\ncase 178:\n    /*! Production::    initializer : assignment_expression */\ncase 183:\n    /*! Production::    statement : labeled_statement */\ncase 184:\n    /*! Production::    statement : compound_statement */\ncase 185:\n    /*! Production::    statement : expression_statement */\ncase 186:\n    /*! Production::    statement : selection_statement */\ncase 187:\n    /*! Production::    statement : iteration_statement */\ncase 188:\n    /*! Production::    statement : jump_statement */\ncase 196:\n    /*! Production::    block_item : declaration */\ncase 197:\n    /*! Production::    block_item : statement */\ncase 216:\n    /*! Production::    external_declaration : function_definition */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp]);\n    break;\n\ncase 11:\n    /*! Production::    concat_string_literals : concat_string_literals string_literal */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 1] + yyvstack[yysp]);\n    break;\n\ncase 12:\n    /*! Production::    primary_expression : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Identifier(this._$, yytext));\n    break;\n\ncase 14:\n    /*! Production::    primary_expression : concat_string_literals */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StringLiteral(this._$, yyvstack[yysp]));\n    break;\n\ncase 15:\n    /*! Production::    primary_expression : \"(\" expression \")\" */\ncase 146:\n    /*! Production::    direct_declarator : \"(\" declarator \")\" */\ncase 169:\n    /*! Production::    direct_abstract_declarator : \"(\" abstract_declarator \")\" */\ncase 179:\n    /*! Production::    initializer : \"{\" initializer_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 1]);\n    break;\n\ncase 17:\n    /*! Production::    postfix_expression : postfix_expression \"[\" expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"arraySubscript\", yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 18:\n    /*! Production::    postfix_expression : postfix_expression \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionCallExpression(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 19:\n    /*! Production::    postfix_expression : postfix_expression \"(\" argument_expression_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionCallExpression(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 20:\n    /*! Production::    postfix_expression : postfix_expression \".\" identifier */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.MemberAccessExpression(this._$, false, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 21:\n    /*! Production::    postfix_expression : postfix_expression PTR_OP identifier */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.MemberAccessExpression(this._$, true, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 22:\n    /*! Production::    postfix_expression : postfix_expression INC_OP */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"postfixIncrement\", yyvstack[yysp - 1]));\n    break;\n\ncase 23:\n    /*! Production::    postfix_expression : postfix_expression DEC_OP */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"postfixDecrement\", yyvstack[yysp - 1]));\n    break;\n\ncase 24:\n    /*! Production::    argument_expression_list : assignment_expression */\ncase 96:\n    /*! Production::    init_declarator_list : init_declarator */\ncase 121:\n    /*! Production::    struct_declaration_list : struct_declaration */\ncase 128:\n    /*! Production::    struct_declarator_list : struct_declarator */\ncase 136:\n    /*! Production::    enumerator_list : enumerator */\ncase 155:\n    /*! Production::    type_qualifier_list : type_qualifier */\ncase 159:\n    /*! Production::    parameter_list : parameter_declaration */\ncase 181:\n    /*! Production::    initializer_list : initializer */\ncase 194:\n    /*! Production::    block_item_list : block_item */\ncase 214:\n    /*! Production::    translation_unit : external_declaration */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ([yyvstack[yysp]]);\n    break;\n\ncase 25:\n    /*! Production::    argument_expression_list : argument_expression_list \",\" assignment_expression */\ncase 97:\n    /*! Production::    init_declarator_list : init_declarator_list \",\" init_declarator */\ncase 129:\n    /*! Production::    struct_declarator_list : struct_declarator_list \",\" struct_declarator */\ncase 137:\n    /*! Production::    enumerator_list : enumerator_list \",\" enumerator */\ncase 160:\n    /*! Production::    parameter_list : parameter_list \",\" parameter_declaration */\ncase 182:\n    /*! Production::    initializer_list : initializer_list \",\" initializer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 2].push(yyvstack[yysp]), yyvstack[yysp - 2]));\n    break;\n\ncase 27:\n    /*! Production::    unary_expression : INC_OP unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"prefixIncrement\", yyvstack[yysp]));\n    break;\n\ncase 28:\n    /*! Production::    unary_expression : DEC_OP unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, \"prefixDecrement\", yyvstack[yysp]));\n    break;\n\ncase 29:\n    /*! Production::    unary_expression : unary_operator cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.UnaryExpression(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 30:\n    /*! Production::    unary_expression : SIZEOF unary_expression */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SizeofExpression(this._$, yyvstack[yysp]));\n    break;\n\ncase 31:\n    /*! Production::    unary_expression : SIZEOF \"(\" type_name \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SizeofExpression(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 32:\n    /*! Production::    unary_operator : \"&\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"addressOf\");\n    break;\n\ncase 33:\n    /*! Production::    unary_operator : \"*\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"dereference\");\n    break;\n\ncase 34:\n    /*! Production::    unary_operator : \"+\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"unaryPlus\");\n    break;\n\ncase 35:\n    /*! Production::    unary_operator : \"-\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"unaryMinus\");\n    break;\n\ncase 36:\n    /*! Production::    unary_operator : \"~\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseNot\");\n    break;\n\ncase 37:\n    /*! Production::    unary_operator : \"!\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"logicalNot\");\n    break;\n\ncase 39:\n    /*! Production::    cast_expression : \"(\" type_name \")\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CastExpression(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 41:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"*\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"mul\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 42:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"/\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"div\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 43:\n    /*! Production::    multiplicative_expression : multiplicative_expression \"%\" cast_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"mod\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 45:\n    /*! Production::    additive_expression : additive_expression \"+\" multiplicative_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"add\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 46:\n    /*! Production::    additive_expression : additive_expression \"-\" multiplicative_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"sub\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 48:\n    /*! Production::    shift_expression : shift_expression LEFT_OP additive_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseShiftLeft\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 49:\n    /*! Production::    shift_expression : shift_expression RIGHT_OP additive_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseShiftRight\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 51:\n    /*! Production::    relational_expression : relational_expression \"<\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalLT\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 52:\n    /*! Production::    relational_expression : relational_expression \">\" shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalGT\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 53:\n    /*! Production::    relational_expression : relational_expression LE_OP shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalLEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 54:\n    /*! Production::    relational_expression : relational_expression GE_OP shift_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalGEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 56:\n    /*! Production::    equality_expression : equality_expression EQ_OP relational_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 57:\n    /*! Production::    equality_expression : equality_expression NE_OP relational_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"relationalNEq\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 59:\n    /*! Production::    and_expression : and_expression \"&\" equality_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseAnd\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 61:\n    /*! Production::    exclusive_or_expression : exclusive_or_expression \"^\" and_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseXor\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 63:\n    /*! Production::    inclusive_or_expression : inclusive_or_expression \"|\" exclusive_or_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"bitwiseOr\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 65:\n    /*! Production::    logical_and_expression : logical_and_expression AND_OP inclusive_or_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"logicalAnd\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 67:\n    /*! Production::    logical_or_expression : logical_or_expression OR_OP logical_and_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"logicalOr\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 69:\n    /*! Production::    conditional_expression : logical_or_expression \"?\" expression \":\" conditional_expression */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ConditionalExpression(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 71:\n    /*! Production::    assignment_expression : unary_expression assignment_operator assignment_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AssignmentExpression(this._$, yyvstack[yysp - 1], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 72:\n    /*! Production::    assignment_operator : \"=\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (undefined);\n    break;\n\ncase 73:\n    /*! Production::    assignment_operator : MUL_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"mul\");\n    break;\n\ncase 74:\n    /*! Production::    assignment_operator : DIV_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"div\");\n    break;\n\ncase 75:\n    /*! Production::    assignment_operator : MOD_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"mod\");\n    break;\n\ncase 76:\n    /*! Production::    assignment_operator : ADD_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"add\");\n    break;\n\ncase 77:\n    /*! Production::    assignment_operator : SUB_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"sub\");\n    break;\n\ncase 78:\n    /*! Production::    assignment_operator : LEFT_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"leftShift\");\n    break;\n\ncase 79:\n    /*! Production::    assignment_operator : RIGHT_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"rightShift\");\n    break;\n\ncase 80:\n    /*! Production::    assignment_operator : AND_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseAnd\");\n    break;\n\ncase 81:\n    /*! Production::    assignment_operator : XOR_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseXor\");\n    break;\n\ncase 82:\n    /*! Production::    assignment_operator : OR_ASSIGN */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bitwiseOr\");\n    break;\n\ncase 84:\n    /*! Production::    expression : expression \",\" assignment_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BinaryExpression(this._$, \"comma\", yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 85:\n    /*! Production::    constant_expression : conditional_expression */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ConstantExpression(this._$, yyvstack[yysp]));\n    break;\n\ncase 86:\n    /*! Production::    declaration : declaration_specifiers \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Declaration(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 87:\n    /*! Production::    declaration : declaration_specifiers init_declarator_list \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Declaration(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1]));\n    break;\n\ncase 88:\n    /*! Production::    declaration_specifiers : storage_class_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [], [yyvstack[yysp]], []));\n    break;\n\ncase 89:\n    /*! Production::    declaration_specifiers : storage_class_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, yyvstack[yysp].qualifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].storageList], yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 90:\n    /*! Production::    declaration_specifiers : type_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [yyvstack[yysp]], [], [], []));\n    break;\n\ncase 91:\n    /*! Production::    declaration_specifiers : type_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [yyvstack[yysp - 1], ...yyvstack[yysp].specifierList], yyvstack[yysp].qualifierList, yyvstack[yysp].storageList, yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 92:\n    /*! Production::    declaration_specifiers : type_qualifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [yyvstack[yysp]], [], []));\n    break;\n\ncase 93:\n    /*! Production::    declaration_specifiers : type_qualifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].qualifierList], yyvstack[yysp].storageList, yyvstack[yysp].fnSpecifierList));\n    break;\n\ncase 94:\n    /*! Production::    declaration_specifiers : function_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, [], [], [], [yyvstack[yysp]]));\n    break;\n\ncase 95:\n    /*! Production::    declaration_specifiers : function_specifier declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DeclarationSpecifiers(this._$, yyvstack[yysp].specifierList, yyvstack[yysp].qualifierList, yyvstack[yysp].storageList, [yyvstack[yysp - 1], ...yyvstack[yysp].fnSpecifierList]));\n    break;\n\ncase 99:\n    /*! Production::    init_declarator : declarator \"=\" initializer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.InitDeclarator(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 112:\n    /*! Production::    type_specifier : _BOOL */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"bool\");\n    break;\n\ncase 115:\n    /*! Production::    type_specifier : TYPE_NAME */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CustomTypeSpecifier(this._$, yyvstack[yysp]));\n    break;\n\ncase 116:\n    /*! Production::    struct_or_union_specifier : struct_or_union identifier \"{\" struct_declaration_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 117:\n    /*! Production::    struct_or_union_specifier : struct_or_union \"{\" struct_declaration_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 3], undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 118:\n    /*! Production::    struct_or_union_specifier : struct_or_union identifier */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructUnionSpecifier(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 119:\n    /*! Production::    struct_or_union : STRUCT */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"struct\");\n    break;\n\ncase 120:\n    /*! Production::    struct_or_union : UNION */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"union\");\n    break;\n\ncase 122:\n    /*! Production::    struct_declaration_list : struct_declaration_list struct_declaration */\ncase 156:\n    /*! Production::    type_qualifier_list : type_qualifier_list type_qualifier */\ncase 195:\n    /*! Production::    block_item_list : block_item_list block_item */\ncase 215:\n    /*! Production::    translation_unit : translation_unit external_declaration */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 1].push(yyvstack[yysp]), yyvstack[yysp - 1]));\n    break;\n\ncase 123:\n    /*! Production::    struct_declaration : specifier_qualifier_list struct_declarator_list \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.StructDeclaration(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1]));\n    break;\n\ncase 124:\n    /*! Production::    specifier_qualifier_list : type_specifier specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [yyvstack[yysp - 1], ...yyvstack[yysp].specifierList], yyvstack[yysp].qualifierList));\n    break;\n\ncase 125:\n    /*! Production::    specifier_qualifier_list : type_specifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [yyvstack[yysp]], []));\n    break;\n\ncase 126:\n    /*! Production::    specifier_qualifier_list : type_qualifier specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, yyvstack[yysp].specifierList, [yyvstack[yysp - 1], ...yyvstack[yysp].qualifierList]));\n    break;\n\ncase 127:\n    /*! Production::    specifier_qualifier_list : type_qualifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SpecifierQualifiers(this._$, [], [yyvstack[yysp]]));\n    break;\n\ncase 131:\n    /*! Production::    enum_specifier : ENUM \"{\" enumerator_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 132:\n    /*! Production::    enum_specifier : ENUM identifier \"{\" enumerator_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 133:\n    /*! Production::    enum_specifier : ENUM \"{\" enumerator_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, undefined, yyvstack[yysp - 2]));\n    break;\n\ncase 134:\n    /*! Production::    enum_specifier : ENUM identifier \"{\" enumerator_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);\n    // END of default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2]));\n    break;\n\ncase 135:\n    /*! Production::    enum_specifier : ENUM identifier */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.EnumSpecifier(this._$, yyvstack[yysp]));\n    break;\n\ncase 138:\n    /*! Production::    enumerator : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Enumerator(this._$, yyvstack[yysp]));\n    break;\n\ncase 139:\n    /*! Production::    enumerator : identifier \"=\" constant_expression */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Enumerator(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 140:\n    /*! Production::    type_qualifier : CONST */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"const\");\n    break;\n\ncase 141:\n    /*! Production::    function_specifier : INLINE */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (\"inline\");\n    break;\n\ncase 143:\n    /*! Production::    declarator : pointer direct_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.PointerDeclarator(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 145:\n    /*! Production::    direct_declarator : identifier */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IdentifierDeclarator(this._$, yyvstack[yysp]));\n    break;\n\ncase 147:\n    /*! Production::    direct_declarator : direct_declarator \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ArrayDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 148:\n    /*! Production::    direct_declarator : direct_declarator \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ArrayDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 149:\n    /*! Production::    direct_declarator : direct_declarator \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 150:\n    /*! Production::    direct_declarator : direct_declarator \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 151:\n    /*! Production::    pointer : \"*\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$));\n    break;\n\ncase 152:\n    /*! Production::    pointer : \"*\" type_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, yyvstack[yysp]));\n    break;\n\ncase 153:\n    /*! Production::    pointer : \"*\" pointer */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, undefined, yyvstack[yysp]));\n    break;\n\ncase 154:\n    /*! Production::    pointer : \"*\" type_qualifier_list pointer */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.Pointer(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 157:\n    /*! Production::    parameter_type_list : parameter_list */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp].variadic = false, yyvstack[yysp]));\n    break;\n\ncase 158:\n    /*! Production::    parameter_type_list : parameter_list \",\" ELLIPSIS */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yyvstack[yysp - 2].variadic = true, yyvstack[yysp - 2]));\n    break;\n\ncase 161:\n    /*! Production::    parameter_declaration : declaration_specifiers declarator */\ncase 162:\n    /*! Production::    parameter_declaration : declaration_specifiers abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ParameterDeclaration(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 163:\n    /*! Production::    parameter_declaration : declaration_specifiers */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ParameterDeclaration(this._$, yyvstack[yysp]));\n    break;\n\ncase 164:\n    /*! Production::    type_name : specifier_qualifier_list */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.TypeName(this._$, yyvstack[yysp]));\n    break;\n\ncase 165:\n    /*! Production::    type_name : specifier_qualifier_list abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.TypeName(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 166:\n    /*! Production::    abstract_declarator : pointer */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractPointerDeclarator(this._$, yyvstack[yysp]));\n    break;\n\ncase 168:\n    /*! Production::    abstract_declarator : pointer direct_abstract_declarator */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractPointerDeclarator(this._$, yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\ncase 170:\n    /*! Production::    direct_abstract_declarator : \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$));\n    break;\n\ncase 171:\n    /*! Production::    direct_abstract_declarator : \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, undefined, yyvstack[yysp - 1]));\n    break;\n\ncase 172:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"[\" \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 173:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"[\" constant_expression \"]\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractArrayDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1]));\n    break;\n\ncase 174:\n    /*! Production::    direct_abstract_declarator : \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$));\n    break;\n\ncase 175:\n    /*! Production::    direct_abstract_declarator : \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, undefined, yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 176:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"(\" \")\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, yyvstack[yysp - 2]));\n    break;\n\ncase 177:\n    /*! Production::    direct_abstract_declarator : direct_abstract_declarator \"(\" parameter_type_list \")\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.AbstractFunctionDeclarator(this._$, yyvstack[yysp - 3], yyvstack[yysp - 1], yyvstack[yysp - 1].variadic));\n    break;\n\ncase 180:\n    /*! Production::    initializer : \"{\" initializer_list \",\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp - 2]);\n    break;\n\ncase 189:\n    /*! Production::    labeled_statement : identifier \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = (yyvstack[yysp].setLabel(yyvstack[yysp - 2]));\n    break;\n\ncase 190:\n    /*! Production::    labeled_statement : CASE constant_expression \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);\n    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CaseStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 191:\n    /*! Production::    labeled_statement : DEFAULT \":\" statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DefaultStatement(this._$, yyvstack[yysp]));\n    break;\n\ncase 192:\n    /*! Production::    compound_statement : \"{\" \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CompoundStatement(this._$, []));\n    break;\n\ncase 193:\n    /*! Production::    compound_statement : \"{\" block_item_list \"}\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.CompoundStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 198:\n    /*! Production::    expression_statement : \";\" */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.NoOp(this._$));\n    break;\n\ncase 199:\n    /*! Production::    expression_statement : expression \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ExpressionStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 200:\n    /*! Production::    selection_statement : IF \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IfStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 201:\n    /*! Production::    selection_statement : IF \"(\" expression \")\" statement ELSE statement */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.IfStatement(this._$, yyvstack[yysp - 4], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 202:\n    /*! Production::    selection_statement : SWITCH \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.SwitchStatement(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 203:\n    /*! Production::    iteration_statement : WHILE \"(\" expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);\n    // END of default action (generated by JISON mode none/merge :: 5,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.WhileLoop(this._$, yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 204:\n    /*! Production::    iteration_statement : DO statement WHILE \"(\" expression \")\" \";\" */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.DoWhileLoop(this._$, yyvstack[yysp - 5], yyvstack[yysp - 2]));\n    break;\n\ncase 205:\n    /*! Production::    iteration_statement : FOR \"(\" expression_statement expression_statement \")\" statement */\ncase 207:\n    /*! Production::    iteration_statement : FOR \"(\" declaration expression_statement \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 5, yysp);\n    // END of default action (generated by JISON mode none/merge :: 6,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ForLoop(this._$, yyvstack[yysp - 3], yyvstack[yysp - 2], undefined, yyvstack[yysp]));\n    break;\n\ncase 206:\n    /*! Production::    iteration_statement : FOR \"(\" expression_statement expression_statement expression \")\" statement */\ncase 208:\n    /*! Production::    iteration_statement : FOR \"(\" declaration expression_statement expression \")\" statement */\n\n    // default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 6, yysp);\n    // END of default action (generated by JISON mode none/merge :: 7,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ForLoop(this._$, yyvstack[yysp - 4], yyvstack[yysp - 3], yyvstack[yysp - 2], yyvstack[yysp]));\n    break;\n\ncase 209:\n    /*! Production::    jump_statement : GOTO identifier \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.GotoStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 210:\n    /*! Production::    jump_statement : CONTINUE \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ContinueStatement(this._$));\n    break;\n\ncase 211:\n    /*! Production::    jump_statement : BREAK \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.BreakStatement(this._$));\n    break;\n\ncase 212:\n    /*! Production::    jump_statement : RETURN \";\" */\n\n    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);\n    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ReturnStatement(this._$));\n    break;\n\ncase 213:\n    /*! Production::    jump_statement : RETURN expression \";\" */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.ReturnStatement(this._$, yyvstack[yysp - 1]));\n    break;\n\ncase 217:\n    /*! Production::    external_declaration : declaration */\n\n    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):\n    this._$ = yylstack[yysp];\n    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)\n    \n    \n    this.$ = ((yylexer.externalDeclaration(yyvstack[yysp]), yyvstack[yysp]));\n    break;\n\ncase 218:\n    /*! Production::    function_definition : declaration_specifiers declarator compound_statement */\n\n    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA):\n    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);\n    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,LU,LUbA)\n    \n    \n    this.$ = (new t.FunctionDefinition(this._$, yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp]));\n    break;\n\n}\n},\ntable: bt({\n  len: u([\n  34,\n  1,\n  32,\n  s,\n  [0, 4],\n  10,\n  s,\n  [35, 4],\n  s,\n  [0, 19],\n  3,\n  3,\n  s,\n  [0, 4],\n  5,\n  0,\n  2,\n  4,\n  7,\n  0,\n  10,\n  0,\n  7,\n  s,\n  [0, 5],\n  28,\n  23,\n  4,\n  28,\n  0,\n  40,\n  91,\n  0,\n  8,\n  7,\n  39,\n  32,\n  9,\n  0,\n  0,\n  1,\n  23,\n  23,\n  0,\n  9,\n  26,\n  26,\n  2,\n  0,\n  3,\n  4,\n  0,\n  0,\n  41,\n  0,\n  37,\n  8,\n  42,\n  25,\n  25,\n  26,\n  25,\n  c,\n  [25, 3],\n  s,\n  [0, 5],\n  10,\n  0,\n  0,\n  44,\n  61,\n  11,\n  s,\n  [0, 6],\n  12,\n  0,\n  14,\n  18,\n  20,\n  22,\n  25,\n  0,\n  0,\n  90,\n  c,\n  [25, 6],\n  s,\n  [0, 4],\n  39,\n  38,\n  1,\n  0,\n  2,\n  s,\n  [1, 3],\n  59,\n  1,\n  c,\n  [6, 3],\n  40,\n  c,\n  [113, 3],\n  1,\n  s,\n  [0, 3],\n  c,\n  [19, 3],\n  c,\n  [45, 3],\n  0,\n  0,\n  23,\n  0,\n  c,\n  [9, 3],\n  s,\n  [0, 4],\n  4,\n  38,\n  2,\n  2,\n  0,\n  38,\n  s,\n  [0, 11],\n  39,\n  35,\n  39,\n  40,\n  c,\n  [19, 3],\n  c,\n  [9, 3],\n  s,\n  [0, 3],\n  61,\n  34,\n  33,\n  c,\n  [68, 3],\n  7,\n  32,\n  31,\n  30,\n  30,\n  s,\n  [29, 4],\n  28,\n  28,\n  27,\n  27,\n  s,\n  [26, 3],\n  0,\n  0,\n  59,\n  1,\n  59,\n  0,\n  38,\n  s,\n  [39, 3],\n  1,\n  70,\n  c,\n  [85, 4],\n  c,\n  [46, 3],\n  30,\n  0,\n  0,\n  8,\n  4,\n  42,\n  c,\n  [51, 3],\n  8,\n  c,\n  [85, 5],\n  c,\n  [174, 3],\n  2,\n  9,\n  2,\n  c,\n  [99, 5],\n  1,\n  10,\n  11,\n  0,\n  26,\n  c,\n  [103, 3],\n  12,\n  14,\n  18,\n  18,\n  s,\n  [20, 4],\n  22,\n  22,\n  25,\n  c,\n  [168, 3],\n  c,\n  [67, 3],\n  c,\n  [56, 3],\n  2,\n  2,\n  1,\n  41,\n  41,\n  c,\n  [49, 5],\n  39,\n  32,\n  1,\n  c,\n  [156, 3],\n  c,\n  [77, 4],\n  0,\n  37,\n  0,\n  c,\n  [144, 5],\n  s,\n  [59, 3],\n  39,\n  40,\n  40,\n  c,\n  [21, 8],\n  0,\n  52,\n  c,\n  [47, 3],\n  59,\n  2,\n  59,\n  c,\n  [82, 3],\n  59,\n  1,\n  c,\n  [60, 3],\n  c,\n  [62, 3],\n  0,\n  0\n]),\n  symbol: u([\n  1,\n  s,\n  [56, 20, 1],\n  89,\n  115,\n  116,\n  s,\n  [119, 4, 1],\n  128,\n  131,\n  132,\n  154,\n  155,\n  156,\n  1,\n  c,\n  [35, 21],\n  c,\n  [34, 9],\n  155,\n  156,\n  3,\n  10,\n  24,\n  27,\n  90,\n  117,\n  118,\n  133,\n  134,\n  135,\n  3,\n  4,\n  5,\n  8,\n  c,\n  [13, 3],\n  c,\n  [48, 20],\n  c,\n  [47, 8],\n  c,\n  [35, 105],\n  25,\n  27,\n  90,\n  c,\n  [3, 3],\n  8,\n  23,\n  24,\n  25,\n  147,\n  8,\n  24,\n  3,\n  27,\n  90,\n  134,\n  c,\n  [52, 4],\n  c,\n  [14, 3],\n  c,\n  [59, 5],\n  27,\n  73,\n  131,\n  135,\n  136,\n  3,\n  10,\n  27,\n  90,\n  c,\n  [181, 9],\n  25,\n  c,\n  [77, 21],\n  c,\n  [17, 15],\n  s,\n  [120, 6, 1],\n  128,\n  131,\n  27,\n  90,\n  129,\n  130,\n  c,\n  [55, 28],\n  3,\n  s,\n  [9, 6, 1],\n  25,\n  s,\n  [27, 7, 1],\n  35,\n  36,\n  37,\n  s,\n  [90, 6, 1],\n  s,\n  [97, 15, 1],\n  143,\n  c,\n  [40, 7],\n  s,\n  [24, 10, 1],\n  c,\n  [42, 3],\n  c,\n  [80, 20],\n  77,\n  78,\n  79,\n  s,\n  [81, 8, 1],\n  c,\n  [73, 21],\n  113,\n  c,\n  [398, 9],\n  s,\n  [145, 9, 1],\n  c,\n  [221, 4],\n  c,\n  [403, 8],\n  c,\n  [246, 4],\n  6,\n  c,\n  [107, 6],\n  c,\n  [146, 30],\n  114,\n  4,\n  c,\n  [338, 28],\n  137,\n  138,\n  139,\n  c,\n  [317, 9],\n  4,\n  c,\n  [282, 23],\n  26,\n  c,\n  [24, 18],\n  c,\n  [23, 4],\n  c,\n  [142, 4],\n  126,\n  127,\n  c,\n  [143, 6],\n  10,\n  27,\n  c,\n  [36, 18],\n  c,\n  [35, 4],\n  c,\n  [26, 25],\n  8,\n  26,\n  8,\n  23,\n  26,\n  c,\n  [371, 5],\n  c,\n  [343, 39],\n  144,\n  4,\n  6,\n  s,\n  [8, 5, 1],\n  s,\n  [15, 10, 1],\n  26,\n  s,\n  [38, 18, 1],\n  112,\n  c,\n  [37, 3],\n  21,\n  22,\n  24,\n  26,\n  45,\n  s,\n  [3, 10, 1],\n  c,\n  [48, 11],\n  34,\n  35,\n  36,\n  c,\n  [51, 18],\n  c,\n  [128, 7],\n  c,\n  [127, 18],\n  c,\n  [25, 50],\n  99,\n  c,\n  [26, 25],\n  c,\n  [151, 7],\n  44,\n  45,\n  c,\n  [9, 3],\n  c,\n  [140, 3],\n  c,\n  [10, 4],\n  c,\n  [162, 21],\n  s,\n  [33, 4, 1],\n  c,\n  [163, 18],\n  92,\n  c,\n  [88, 17],\n  c,\n  [339, 15],\n  c,\n  [576, 22],\n  c,\n  [361, 6],\n  140,\n  c,\n  [115, 3],\n  c,\n  [94, 4],\n  c,\n  [126, 7],\n  9,\n  c,\n  [12, 18],\n  c,\n  [109, 4],\n  c,\n  [14, 4],\n  c,\n  [134, 6],\n  24,\n  26,\n  c,\n  [127, 6],\n  c,\n  [18, 12],\n  c,\n  [147, 8],\n  c,\n  [20, 4],\n  11,\n  12,\n  c,\n  [22, 20],\n  c,\n  [199, 11],\n  c,\n  [25, 10],\n  c,\n  [778, 85],\n  c,\n  [777, 7],\n  c,\n  [1182, 9],\n  5,\n  c,\n  [325, 16],\n  c,\n  [486, 46],\n  c,\n  [810, 13],\n  22,\n  c,\n  [1109, 3],\n  s,\n  [3, 3],\n  c,\n  [183, 8],\n  c,\n  [46, 10],\n  c,\n  [162, 33],\n  c,\n  [153, 3],\n  c,\n  [152, 5],\n  27,\n  90,\n  24,\n  24,\n  c,\n  [64, 8],\n  c,\n  [722, 31],\n  113,\n  c,\n  [963, 3],\n  6,\n  4,\n  4,\n  8,\n  c,\n  [895, 6],\n  c,\n  [1205, 4],\n  141,\n  142,\n  c,\n  [874, 23],\n  8,\n  24,\n  c,\n  [811, 3],\n  c,\n  [810, 8],\n  c,\n  [196, 31],\n  c,\n  [857, 3],\n  26,\n  c,\n  [42, 37],\n  111,\n  c,\n  [38, 38],\n  113,\n  c,\n  [39, 35],\n  c,\n  [74, 40],\n  4,\n  c,\n  [40, 22],\n  s,\n  [96, 16, 1],\n  27,\n  90,\n  27,\n  90,\n  c,\n  [157, 56],\n  c,\n  [794, 44],\n  c,\n  [100, 34],\n  c,\n  [34, 33],\n  4,\n  8,\n  4,\n  c,\n  [1252, 4],\n  c,\n  [443, 3],\n  c,\n  [43, 32],\n  c,\n  [32, 31],\n  c,\n  [31, 30],\n  c,\n  [30, 59],\n  c,\n  [29, 115],\n  c,\n  [28, 55],\n  c,\n  [27, 53],\n  c,\n  [26, 59],\n  c,\n  [993, 52],\n  22,\n  c,\n  [1053, 60],\n  c,\n  [918, 111],\n  c,\n  [39, 43],\n  82,\n  c,\n  [1204, 18],\n  c,\n  [1449, 20],\n  c,\n  [1438, 31],\n  150,\n  24,\n  8,\n  24,\n  s,\n  [56, 21, 1],\n  c,\n  [33, 8],\n  c,\n  [2155, 5],\n  c,\n  [2486, 3],\n  142,\n  c,\n  [8, 4],\n  c,\n  [2076, 5],\n  c,\n  [102, 21],\n  c,\n  [47, 8],\n  c,\n  [1299, 3],\n  c,\n  [2207, 3],\n  c,\n  [859, 3],\n  c,\n  [2280, 38],\n  c,\n  [2192, 4],\n  c,\n  [2191, 4],\n  c,\n  [1324, 11],\n  c,\n  [1658, 12],\n  c,\n  [2135, 22],\n  8,\n  22,\n  c,\n  [1948, 9],\n  6,\n  8,\n  c,\n  [974, 3],\n  c,\n  [1953, 10],\n  c,\n  [1848, 11],\n  c,\n  [587, 27],\n  4,\n  5,\n  c,\n  [205, 4],\n  10,\n  c,\n  [2403, 28],\n  c,\n  [197, 6],\n  c,\n  [1916, 56],\n  c,\n  [1934, 30],\n  c,\n  [20, 60],\n  c,\n  [1994, 22],\n  c,\n  [2016, 43],\n  c,\n  [2041, 34],\n  c,\n  [805, 50],\n  c,\n  [387, 3],\n  c,\n  [391, 3],\n  c,\n  [1924, 9],\n  c,\n  [697, 32],\n  150,\n  c,\n  [41, 42],\n  c,\n  [627, 4],\n  c,\n  [2865, 70],\n  c,\n  [549, 3],\n  c,\n  [856, 37],\n  c,\n  [1009, 45],\n  c,\n  [1106, 59],\n  c,\n  [59, 118],\n  c,\n  [2030, 56],\n  c,\n  [40, 56],\n  6,\n  4,\n  c,\n  [2640, 43],\n  s,\n  [80, 9, 1],\n  c,\n  [588, 3],\n  c,\n  [653, 60],\n  c,\n  [61, 120],\n  c,\n  [2629, 9],\n  c,\n  [475, 110]\n]),\n  type: u([\n  s,\n  [2, 21],\n  s,\n  [0, 13],\n  1,\n  c,\n  [35, 32],\n  c,\n  [15, 10],\n  s,\n  [2, 27],\n  c,\n  [45, 12],\n  c,\n  [35, 103],\n  c,\n  [3, 6],\n  c,\n  [5, 8],\n  c,\n  [52, 15],\n  c,\n  [69, 6],\n  c,\n  [76, 31],\n  c,\n  [92, 25],\n  c,\n  [55, 46],\n  c,\n  [338, 16],\n  c,\n  [314, 13],\n  s,\n  [2, 47],\n  s,\n  [0, 40],\n  c,\n  [43, 8],\n  c,\n  [73, 46],\n  c,\n  [491, 36],\n  c,\n  [333, 19],\n  c,\n  [409, 26],\n  c,\n  [142, 15],\n  c,\n  [97, 21],\n  c,\n  [26, 38],\n  c,\n  [35, 21],\n  c,\n  [253, 26],\n  c,\n  [329, 34],\n  s,\n  [2, 67],\n  c,\n  [112, 25],\n  c,\n  [25, 33],\n  c,\n  [51, 43],\n  c,\n  [146, 46],\n  c,\n  [576, 61],\n  s,\n  [2, 173],\n  c,\n  [777, 42],\n  c,\n  [1182, 34],\n  c,\n  [105, 50],\n  c,\n  [162, 65],\n  c,\n  [428, 23],\n  c,\n  [409, 35],\n  c,\n  [874, 32],\n  c,\n  [927, 19],\n  c,\n  [1006, 54],\n  c,\n  [42, 27],\n  c,\n  [576, 39],\n  c,\n  [74, 74],\n  c,\n  [40, 24],\n  c,\n  [1420, 3],\n  c,\n  [1389, 71],\n  c,\n  [794, 46],\n  c,\n  [34, 50],\n  c,\n  [1657, 13],\n  c,\n  [43, 29],\n  c,\n  [32, 31],\n  c,\n  [31, 30],\n  c,\n  [30, 59],\n  c,\n  [29, 115],\n  c,\n  [28, 55],\n  c,\n  [27, 53],\n  c,\n  [26, 69],\n  c,\n  [1357, 73],\n  c,\n  [623, 63],\n  c,\n  [918, 78],\n  c,\n  [922, 61],\n  c,\n  [1438, 53],\n  c,\n  [56, 33],\n  c,\n  [2037, 26],\n  c,\n  [902, 45],\n  c,\n  [314, 25],\n  c,\n  [1413, 8],\n  c,\n  [97, 20],\n  c,\n  [1822, 76],\n  c,\n  [116, 13],\n  c,\n  [200, 38],\n  s,\n  [2, 266],\n  c,\n  [865, 54],\n  c,\n  [48, 41],\n  c,\n  [89, 45],\n  c,\n  [2865, 60],\n  c,\n  [73, 33],\n  c,\n  [2165, 68],\n  c,\n  [1166, 59],\n  c,\n  [59, 105],\n  c,\n  [2030, 63],\n  c,\n  [938, 93],\n  c,\n  [2875, 93],\n  c,\n  [61, 121],\n  c,\n  [475, 88]\n]),\n  state: u([\n  1,\n  s,\n  [6, 4, 1],\n  25,\n  31,\n  26,\n  10,\n  11,\n  2,\n  s,\n  [4, 6, 1],\n  c,\n  [12, 5],\n  36,\n  5,\n  44,\n  39,\n  42,\n  37,\n  41,\n  40,\n  47,\n  c,\n  [16, 7],\n  48,\n  c,\n  [8, 7],\n  49,\n  c,\n  [8, 7],\n  50,\n  c,\n  [8, 7],\n  51,\n  54,\n  55,\n  44,\n  60,\n  65,\n  64,\n  63,\n  44,\n  66,\n  41,\n  40,\n  71,\n  25,\n  31,\n  68,\n  69,\n  70,\n  26,\n  72,\n  75,\n  73,\n  74,\n  97,\n  98,\n  107,\n  99,\n  89,\n  83,\n  81,\n  86,\n  s,\n  [115, 6, -1],\n  108,\n  101,\n  96,\n  88,\n  82,\n  80,\n  78,\n  77,\n  128,\n  c,\n  [22, 19],\n  142,\n  132,\n  119,\n  121,\n  c,\n  [76, 7],\n  120,\n  122,\n  123,\n  117,\n  118,\n  s,\n  [124, 4, 1],\n  44,\n  143,\n  144,\n  41,\n  40,\n  c,\n  [67, 6],\n  148,\n  c,\n  [45, 12],\n  147,\n  145,\n  153,\n  c,\n  [43, 7],\n  149,\n  151,\n  152,\n  155,\n  154,\n  c,\n  [112, 3],\n  157,\n  c,\n  [112, 4],\n  c,\n  [8, 3],\n  159,\n  c,\n  [7, 3],\n  44,\n  160,\n  161,\n  162,\n  c,\n  [133, 5],\n  163,\n  c,\n  [19, 5],\n  164,\n  c,\n  [137, 3],\n  168,\n  c,\n  [137, 22],\n  170,\n  169,\n  171,\n  c,\n  [24, 6],\n  191,\n  86,\n  c,\n  [8, 6],\n  193,\n  c,\n  [8, 7],\n  148,\n  86,\n  194,\n  c,\n  [9, 6],\n  195,\n  86,\n  199,\n  c,\n  [58, 20],\n  142,\n  200,\n  c,\n  [89, 3],\n  202,\n  26,\n  72,\n  201,\n  c,\n  [202, 34],\n  219,\n  c,\n  [201, 5],\n  39,\n  42,\n  c,\n  [202, 23],\n  221,\n  c,\n  [66, 22],\n  228,\n  s,\n  [122, 6, 1],\n  230,\n  c,\n  [125, 21],\n  234,\n  44,\n  238,\n  41,\n  240,\n  239,\n  241,\n  c,\n  [239, 7],\n  75,\n  248,\n  c,\n  [88, 20],\n  249,\n  c,\n  [58, 20],\n  254,\n  c,\n  [79, 21],\n  255,\n  c,\n  [64, 17],\n  256,\n  c,\n  [40, 21],\n  257,\n  c,\n  [22, 6],\n  259,\n  c,\n  [23, 14],\n  260,\n  261,\n  262,\n  c,\n  [290, 22],\n  c,\n  [312, 28],\n  263,\n  c,\n  [115, 16],\n  264,\n  c,\n  [17, 15],\n  265,\n  269,\n  268,\n  241,\n  c,\n  [19, 14],\n  271,\n  c,\n  [15, 13],\n  272,\n  c,\n  [14, 12],\n  273,\n  c,\n  [13, 12],\n  274,\n  c,\n  [13, 11],\n  275,\n  c,\n  [12, 11],\n  276,\n  c,\n  [12, 11],\n  277,\n  c,\n  [12, 11],\n  278,\n  c,\n  [12, 10],\n  279,\n  c,\n  [11, 10],\n  280,\n  c,\n  [11, 9],\n  281,\n  c,\n  [10, 9],\n  282,\n  c,\n  [10, 8],\n  283,\n  c,\n  [9, 8],\n  284,\n  c,\n  [9, 8],\n  285,\n  c,\n  [454, 22],\n  286,\n  s,\n  [122, 7, 1],\n  c,\n  [29, 21],\n  288,\n  c,\n  [29, 6],\n  c,\n  [295, 20],\n  289,\n  c,\n  [316, 21],\n  290,\n  c,\n  [22, 21],\n  291,\n  c,\n  [22, 21],\n  292,\n  c,\n  [22, 21],\n  132,\n  295,\n  c,\n  [665, 8],\n  294,\n  c,\n  [833, 8],\n  299,\n  44,\n  60,\n  300,\n  44,\n  c,\n  [13, 8],\n  66,\n  41,\n  240,\n  305,\n  151,\n  152,\n  303,\n  c,\n  [378, 15],\n  c,\n  [593, 6],\n  307,\n  44,\n  308,\n  c,\n  [854, 3],\n  c,\n  [621, 8],\n  c,\n  [841, 15],\n  311,\n  c,\n  [50, 8],\n  317,\n  300,\n  c,\n  [76, 8],\n  269,\n  c,\n  [74, 5],\n  c,\n  [251, 22],\n  318,\n  c,\n  [251, 26],\n  142,\n  132,\n  323,\n  c,\n  [23, 22],\n  324,\n  c,\n  [149, 20],\n  326,\n  c,\n  [110, 8],\n  328,\n  151,\n  152,\n  c,\n  [32, 19],\n  332,\n  c,\n  [75, 20],\n  333,\n  c,\n  [148, 22],\n  334,\n  c,\n  [428, 28],\n  335,\n  c,\n  [29, 28],\n  336,\n  c,\n  [206, 27],\n  337,\n  c,\n  [22, 21],\n  339,\n  c,\n  [22, 21],\n  341,\n  c,\n  [95, 22],\n  346,\n  c,\n  [124, 28],\n  348,\n  c,\n  [29, 28],\n  350,\n  c,\n  [29, 28],\n  352,\n  c,\n  [29, 28],\n  353,\n  c,\n  [29, 6]\n]),\n  mode: u([\n  s,\n  [1, 46],\n  s,\n  [2, 7],\n  c,\n  [27, 101],\n  c,\n  [31, 5],\n  1,\n  c,\n  [27, 7],\n  c,\n  [9, 3],\n  c,\n  [43, 8],\n  c,\n  [18, 5],\n  c,\n  [12, 8],\n  s,\n  [2, 20],\n  c,\n  [100, 22],\n  c,\n  [44, 38],\n  s,\n  [1, 57],\n  c,\n  [96, 6],\n  c,\n  [327, 43],\n  c,\n  [218, 8],\n  c,\n  [369, 35],\n  c,\n  [20, 35],\n  c,\n  [299, 11],\n  c,\n  [352, 20],\n  c,\n  [317, 10],\n  c,\n  [250, 19],\n  c,\n  [24, 7],\n  c,\n  [67, 6],\n  c,\n  [289, 19],\n  c,\n  [310, 86],\n  c,\n  [146, 12],\n  c,\n  [412, 22],\n  c,\n  [440, 60],\n  c,\n  [236, 15],\n  c,\n  [65, 20],\n  c,\n  [8, 22],\n  c,\n  [34, 18],\n  c,\n  [30, 22],\n  c,\n  [87, 7],\n  c,\n  [55, 20],\n  c,\n  [271, 60],\n  c,\n  [246, 30],\n  c,\n  [688, 75],\n  c,\n  [561, 7],\n  c,\n  [502, 7],\n  s,\n  [1, 217],\n  c,\n  [219, 219],\n  s,\n  [1, 232],\n  c,\n  [680, 7],\n  c,\n  [458, 70],\n  c,\n  [1605, 13],\n  c,\n  [1062, 14],\n  c,\n  [1676, 26],\n  c,\n  [123, 26],\n  c,\n  [1116, 48],\n  c,\n  [1134, 38],\n  c,\n  [20, 60],\n  c,\n  [1194, 23],\n  c,\n  [1216, 42],\n  c,\n  [1241, 80],\n  c,\n  [2006, 28],\n  c,\n  [690, 216],\n  s,\n  [2, 42],\n  c,\n  [538, 11],\n  s,\n  [1, 155]\n]),\n  goto: u([\n  3,\n  s,\n  [12, 13, 1],\n  27,\n  33,\n  34,\n  32,\n  28,\n  29,\n  30,\n  35,\n  c,\n  [21, 20],\n  45,\n  43,\n  38,\n  46,\n  s,\n  [88, 7],\n  c,\n  [31, 20],\n  s,\n  [90, 7],\n  c,\n  [27, 20],\n  s,\n  [92, 7],\n  c,\n  [27, 20],\n  s,\n  [94, 7],\n  c,\n  [27, 20],\n  52,\n  46,\n  53,\n  46,\n  98,\n  56,\n  98,\n  57,\n  59,\n  58,\n  45,\n  46,\n  62,\n  144,\n  61,\n  s,\n  [144, 4],\n  s,\n  [151, 4],\n  43,\n  151,\n  28,\n  45,\n  43,\n  46,\n  s,\n  [118, 6],\n  67,\n  s,\n  [118, 21],\n  c,\n  [74, 15],\n  46,\n  s,\n  [135, 6],\n  76,\n  s,\n  [135, 21],\n  100,\n  s,\n  [90, 6, 1],\n  79,\n  46,\n  s,\n  [102, 5, 1],\n  109,\n  84,\n  85,\n  87,\n  c,\n  [18, 7],\n  131,\n  57,\n  116,\n  c,\n  [20, 10],\n  c,\n  [159, 20],\n  129,\n  130,\n  s,\n  [133, 9, 1],\n  c,\n  [144, 3],\n  62,\n  143,\n  61,\n  s,\n  [143, 4],\n  100,\n  146,\n  c,\n  [62, 6],\n  c,\n  [59, 10],\n  150,\n  c,\n  [60, 20],\n  s,\n  [152, 4],\n  43,\n  152,\n  28,\n  156,\n  c,\n  [25, 15],\n  158,\n  c,\n  [16, 15],\n  c,\n  [88, 3],\n  s,\n  [125, 5],\n  c,\n  [23, 15],\n  s,\n  [127, 5],\n  c,\n  [20, 15],\n  166,\n  165,\n  138,\n  167,\n  138,\n  46,\n  c,\n  [206, 18],\n  s,\n  [38, 15],\n  172,\n  s,\n  [38, 10],\n  s,\n  [173, 10, 1],\n  s,\n  [68, 3],\n  183,\n  s,\n  [68, 3],\n  184,\n  186,\n  26,\n  185,\n  26,\n  187,\n  s,\n  [26, 16],\n  188,\n  189,\n  190,\n  s,\n  [26, 18],\n  192,\n  c,\n  [230, 16],\n  c,\n  [17, 17],\n  c,\n  [138, 7],\n  c,\n  [17, 10],\n  196,\n  c,\n  [17, 16],\n  s,\n  [66, 7],\n  197,\n  66,\n  s,\n  [64, 3],\n  198,\n  s,\n  [64, 6],\n  s,\n  [14, 21],\n  109,\n  s,\n  [14, 21],\n  c,\n  [96, 17],\n  c,\n  [272, 15],\n  s,\n  [62, 3],\n  203,\n  s,\n  [62, 7],\n  s,\n  [60, 3],\n  204,\n  s,\n  [60, 8],\n  s,\n  [58, 10],\n  205,\n  206,\n  58,\n  58,\n  s,\n  [55, 4],\n  207,\n  208,\n  s,\n  [55, 6],\n  209,\n  210,\n  s,\n  [55, 4],\n  s,\n  [50, 12],\n  211,\n  212,\n  s,\n  [50, 6],\n  s,\n  [47, 4],\n  213,\n  214,\n  s,\n  [47, 16],\n  s,\n  [44, 4],\n  215,\n  44,\n  44,\n  216,\n  217,\n  s,\n  [44, 16],\n  c,\n  [576, 9],\n  218,\n  c,\n  [576, 43],\n  38,\n  46,\n  s,\n  [12, 15],\n  220,\n  s,\n  [12, 23],\n  c,\n  [248, 17],\n  222,\n  224,\n  223,\n  225,\n  226,\n  227,\n  c,\n  [117, 9],\n  c,\n  [25, 10],\n  c,\n  [96, 11],\n  229,\n  46,\n  231,\n  232,\n  c,\n  [34, 7],\n  233,\n  c,\n  [33, 10],\n  c,\n  [860, 3],\n  235,\n  236,\n  157,\n  237,\n  242,\n  163,\n  243,\n  163,\n  43,\n  46,\n  244,\n  c,\n  [160, 15],\n  246,\n  245,\n  247,\n  c,\n  [590, 8],\n  c,\n  [50, 10],\n  251,\n  250,\n  253,\n  252,\n  c,\n  [21, 17],\n  c,\n  [17, 52],\n  258,\n  c,\n  [18, 16],\n  46,\n  c,\n  [109, 18],\n  c,\n  [482, 32],\n  c,\n  [49, 34],\n  266,\n  224,\n  267,\n  270,\n  164,\n  243,\n  43,\n  c,\n  [178, 69],\n  c,\n  [17, 193],\n  c,\n  [539, 23],\n  287,\n  c,\n  [31, 30],\n  c,\n  [129, 68],\n  293,\n  c,\n  [99, 8],\n  c,\n  [784, 30],\n  296,\n  224,\n  297,\n  c,\n  [23, 20],\n  298,\n  242,\n  166,\n  243,\n  166,\n  46,\n  302,\n  167,\n  301,\n  167,\n  242,\n  304,\n  243,\n  43,\n  46,\n  c,\n  [35, 20],\n  100,\n  306,\n  c,\n  [115, 16],\n  c,\n  [1337, 3],\n  309,\n  c,\n  [1293, 9],\n  310,\n  c,\n  [24, 10],\n  224,\n  312,\n  s,\n  [67, 7],\n  197,\n  67,\n  313,\n  224,\n  314,\n  315,\n  316,\n  s,\n  [65, 3],\n  198,\n  s,\n  [65, 6],\n  s,\n  [63, 3],\n  203,\n  s,\n  [63, 7],\n  c,\n  [193, 17],\n  270,\n  166,\n  243,\n  270,\n  c,\n  [124, 3],\n  c,\n  [123, 20],\n  s,\n  [61, 3],\n  204,\n  s,\n  [61, 8],\n  s,\n  [59, 10],\n  205,\n  206,\n  59,\n  59,\n  s,\n  [56, 4],\n  207,\n  208,\n  s,\n  [56, 6],\n  209,\n  210,\n  s,\n  [56, 4],\n  s,\n  [57, 4],\n  207,\n  208,\n  s,\n  [57, 6],\n  209,\n  210,\n  s,\n  [57, 4],\n  s,\n  [51, 12],\n  211,\n  212,\n  s,\n  [51, 6],\n  s,\n  [52, 12],\n  211,\n  212,\n  s,\n  [52, 6],\n  s,\n  [53, 12],\n  211,\n  212,\n  s,\n  [53, 6],\n  s,\n  [54, 12],\n  211,\n  212,\n  s,\n  [54, 6],\n  s,\n  [48, 4],\n  213,\n  214,\n  s,\n  [48, 16],\n  s,\n  [49, 4],\n  213,\n  214,\n  s,\n  [49, 16],\n  s,\n  [45, 4],\n  215,\n  45,\n  45,\n  216,\n  217,\n  s,\n  [45, 16],\n  s,\n  [46, 4],\n  215,\n  46,\n  46,\n  216,\n  217,\n  s,\n  [46, 16],\n  c,\n  [554, 30],\n  319,\n  224,\n  320,\n  224,\n  321,\n  224,\n  322,\n  c,\n  [492, 18],\n  c,\n  [18, 18],\n  302,\n  168,\n  301,\n  168,\n  100,\n  325,\n  c,\n  [358, 16],\n  327,\n  c,\n  [352, 20],\n  329,\n  330,\n  331,\n  c,\n  [738, 64],\n  c,\n  [30, 67],\n  c,\n  [107, 11],\n  338,\n  c,\n  [18, 17],\n  340,\n  c,\n  [18, 16],\n  342,\n  343,\n  s,\n  [200, 43],\n  344,\n  s,\n  [200, 8],\n  345,\n  224,\n  c,\n  [139, 30],\n  347,\n  c,\n  [32, 31],\n  349,\n  c,\n  [32, 31],\n  351,\n  c,\n  [264, 60]\n])\n}),\ndefaultActions: bda({\n  idx: u([\n  s,\n  [3, 4, 1],\n  s,\n  [12, 19, 1],\n  s,\n  [33, 4, 1],\n  38,\n  42,\n  44,\n  s,\n  [46, 5, 1],\n  55,\n  58,\n  64,\n  65,\n  69,\n  74,\n  77,\n  78,\n  80,\n  s,\n  [89, 7, 1],\n  97,\n  98,\n  s,\n  [102, 6, 1],\n  109,\n  115,\n  116,\n  118,\n  119,\n  120,\n  s,\n  [122, 6, 1],\n  131,\n  142,\n  143,\n  146,\n  147,\n  s,\n  [148, 4, 2],\n  155,\n  156,\n  158,\n  159,\n  s,\n  [161, 5, 1],\n  170,\n  s,\n  [172, 11, 1],\n  189,\n  190,\n  191,\n  193,\n  194,\n  195,\n  199,\n  218,\n  219,\n  223,\n  231,\n  232,\n  233,\n  235,\n  236,\n  238,\n  239,\n  244,\n  245,\n  s,\n  [247, 4, 1],\n  252,\n  254,\n  258,\n  260,\n  261,\n  262,\n  266,\n  268,\n  s,\n  [283, 4, 1],\n  288,\n  289,\n  s,\n  [296, 4, 1],\n  304,\n  306,\n  s,\n  [308, 4, 1],\n  313,\n  314,\n  316,\n  317,\n  318,\n  325,\n  327,\n  s,\n  [329, 5, 1],\n  335,\n  336,\n  342,\n  343,\n  346,\n  348,\n  s,\n  [350, 4, 1]\n]),\n  goto: u([\n  2,\n  214,\n  216,\n  217,\n  s,\n  [100, 16, 1],\n  140,\n  141,\n  142,\n  119,\n  120,\n  1,\n  215,\n  86,\n  96,\n  145,\n  3,\n  s,\n  [89, 4, 2],\n  218,\n  87,\n  153,\n  155,\n  121,\n  136,\n  99,\n  178,\n  70,\n  16,\n  s,\n  [32, 6, 1],\n  12,\n  13,\n  s,\n  [4, 5, 1],\n  10,\n  9,\n  40,\n  192,\n  194,\n  196,\n  197,\n  s,\n  [183, 6, 1],\n  198,\n  83,\n  97,\n  148,\n  85,\n  38,\n  150,\n  159,\n  154,\n  156,\n  146,\n  117,\n  122,\n  128,\n  130,\n  124,\n  126,\n  131,\n  181,\n  s,\n  [72, 11, 1],\n  22,\n  23,\n  s,\n  [27, 4, 1],\n  11,\n  193,\n  195,\n  199,\n  210,\n  211,\n  212,\n  147,\n  149,\n  161,\n  162,\n  116,\n  123,\n  133,\n  137,\n  139,\n  132,\n  179,\n  71,\n  18,\n  24,\n  20,\n  21,\n  15,\n  165,\n  41,\n  42,\n  43,\n  189,\n  191,\n  84,\n  209,\n  213,\n  158,\n  160,\n  174,\n  170,\n  129,\n  134,\n  180,\n  182,\n  17,\n  19,\n  31,\n  39,\n  190,\n  172,\n  176,\n  169,\n  175,\n  171,\n  69,\n  25,\n  202,\n  203,\n  173,\n  177,\n  205,\n  207,\n  201,\n  204,\n  206,\n  208\n])\n}),\nparseError: function parseError(str, hash, ExceptionClass) {\n    if (hash.recoverable) {\n        if (typeof this.trace === 'function') {\n            this.trace(str);\n        }\n        hash.destroy();             // destroy... well, *almost*!\n    } else {\n        if (typeof this.trace === 'function') {\n            this.trace(str);\n        }\n        if (!ExceptionClass) {\n            ExceptionClass = this.JisonParserError;\n        }\n        throw new ExceptionClass(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this;\n    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)\n    var sstack = new Array(128);        // state stack: stores states (column storage)\n\n    var vstack = new Array(128);        // semantic value stack\n    var lstack = new Array(128);        // location stack\n    var table = this.table;\n    var sp = 0;                         // 'stack pointer': index into the stacks\n    var yyloc;\n    var yytext;\n    \n\n\n    var symbol = 0;\n\n\n\n    var TERROR = this.TERROR;\n    var EOF = this.EOF;\n    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;\n    var NO_ACTION = [0, 354 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];\n\n    var lexer;\n    if (this.__lexer__) {\n        lexer = this.__lexer__;\n    } else {\n        lexer = this.__lexer__ = Object.create(this.lexer);\n    }\n\n    var sharedState_yy = {\n        parseError: undefined,\n        quoteName: undefined,\n        lexer: undefined,\n        parser: undefined,\n        pre_parse: undefined,\n        post_parse: undefined,\n        pre_lex: undefined,\n        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!\n    };\n\n    var ASSERT;\n    if (typeof assert !== 'function') {\n        ASSERT = function JisonAssert(cond, msg) {\n            if (!cond) {\n                throw new Error('assertion failed: ' + (msg || '***'));\n            }\n        };\n    } else {\n        ASSERT = assert;\n    }\n\n    this.yyGetSharedState = function yyGetSharedState() {\n        return sharedState_yy;\n    };\n\n\n    // shallow clone objects, straight copy of simple `src` values\n    // e.g. `lexer.yytext` MAY be a complex value object,\n    // rather than a simple string/value.\n    function shallow_copy(src) {\n        if (typeof src === 'object') {\n            var dst = {};\n            for (var k in src) {\n                if (Object.prototype.hasOwnProperty.call(src, k)) {\n                    dst[k] = src[k];\n                }\n            }\n            return dst;\n        }\n        return src;\n    }\n    function shallow_copy_noclobber(dst, src) {\n        for (var k in src) {\n            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {\n                dst[k] = src[k];\n            }\n        }\n    }\n    function copy_yylloc(loc) {\n        var rv = shallow_copy(loc);\n        if (rv && rv.range) {\n            rv.range = rv.range.slice(0);\n        }\n        return rv;\n    }\n\n    // copy state\n    shallow_copy_noclobber(sharedState_yy, this.yy);\n\n    sharedState_yy.lexer = lexer;\n    sharedState_yy.parser = this;\n\n\n\n\n\n\n    // Does the shared state override the default `parseError` that already comes with this instance?\n    if (typeof sharedState_yy.parseError === 'function') {\n        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {\n            if (!ExceptionClass) {\n                ExceptionClass = this.JisonParserError;\n            }\n            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);\n        };\n    } else {\n        this.parseError = this.originalParseError;\n    }\n\n    // Does the shared state override the default `quoteName` that already comes with this instance?\n    if (typeof sharedState_yy.quoteName === 'function') {\n        this.quoteName = function quoteNameAlt(id_str) {\n            return sharedState_yy.quoteName.call(this, id_str);\n        };\n    } else {\n        this.quoteName = this.originalQuoteName;\n    }\n\n    // set up the cleanup function; make it an API so that external code can re-use this one in case of\n    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which\n    // case this parse() API method doesn't come with a `finally { ... }` block any more!\n    //\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `sharedState`, etc. references will be *wrong*!\n    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {\n        var rv;\n\n        if (invoke_post_methods) {\n            var hash;\n\n            if (sharedState_yy.post_parse || this.post_parse) {\n                // create an error hash info instance: we re-use this API in a **non-error situation**\n                // as this one delivers all parser internals ready for access by userland code.\n                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);\n            }\n\n            if (sharedState_yy.post_parse) {\n                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== 'undefined') resultValue = rv;\n            }\n            if (this.post_parse) {\n                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== 'undefined') resultValue = rv;\n            }\n\n            // cleanup:\n            if (hash && hash.destroy) {\n                hash.destroy();\n            }\n        }\n\n        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.\n\n        // clean up the lingering lexer structures as well:\n        if (lexer.cleanupAfterLex) {\n            lexer.cleanupAfterLex(do_not_nuke_errorinfos);\n        }\n\n        // prevent lingering circular references from causing memory leaks:\n        if (sharedState_yy) {\n            sharedState_yy.lexer = undefined;\n            sharedState_yy.parser = undefined;\n            if (lexer.yy === sharedState_yy) {\n                lexer.yy = undefined;\n            }\n        }\n        sharedState_yy = undefined;\n        this.parseError = this.originalParseError;\n        this.quoteName = this.originalQuoteName;\n\n        // nuke the vstack[] array at least as that one will still reference obsoleted user values.\n        // To be safe, we nuke the other internal stack columns as well...\n        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC\n        sstack.length = 0;\n        lstack.length = 0;\n        vstack.length = 0;\n        sp = 0;\n\n        // nuke the error hash info instances created during this run.\n        // Userland code must COPY any data/references\n        // in the error hash instance(s) it is more permanently interested in.\n        if (!do_not_nuke_errorinfos) {\n            for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n                var el = this.__error_infos[i];\n                if (el && typeof el.destroy === 'function') {\n                    el.destroy();\n                }\n            }\n            this.__error_infos.length = 0;\n\n\n        }\n\n        return resultValue;\n    };\n\n    // merge yylloc info into a new yylloc instance.\n    //\n    // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.\n    //\n    // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which\n    // case these override the corresponding first/last indexes.\n    //\n    // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search\n    // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)\n    // yylloc info.\n    //\n    // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.\n    this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {\n        var i1 = first_index | 0,\n            i2 = last_index | 0;\n        var l1 = first_yylloc,\n            l2 = last_yylloc;\n        var rv;\n\n        // rules:\n        // - first/last yylloc entries override first/last indexes\n\n        if (!l1) {\n            if (first_index != null) {\n                for (var i = i1; i <= i2; i++) {\n                    l1 = lstack[i];\n                    if (l1) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (!l2) {\n            if (last_index != null) {\n                for (var i = i2; i >= i1; i--) {\n                    l2 = lstack[i];\n                    if (l2) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        // - detect if an epsilon rule is being processed and act accordingly:\n        if (!l1 && first_index == null) {\n            // epsilon rule span merger. With optional look-ahead in l2.\n            if (!dont_look_back) {\n                for (var i = (i1 || sp) - 1; i >= 0; i--) {\n                    l1 = lstack[i];\n                    if (l1) {\n                        break;\n                    }\n                }\n            }\n            if (!l1) {\n                if (!l2) {\n                    // when we still don't have any valid yylloc info, we're looking at an epsilon rule\n                    // without look-ahead and no preceding terms and/or `dont_look_back` set:\n                    // in that case we ca do nothing but return NULL/UNDEFINED:\n                    return undefined;\n                } else {\n                    // shallow-copy L2: after all, we MAY be looking\n                    // at unconventional yylloc info objects...\n                    rv = shallow_copy(l2);\n                    if (rv.range) {\n                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n                        rv.range = rv.range.slice(0);\n                    }\n                    return rv;\n                }\n            } else {\n                // shallow-copy L1, then adjust first col/row 1 column past the end.\n                rv = shallow_copy(l1);\n                rv.first_line = rv.last_line;\n                rv.first_column = rv.last_column;\n                if (rv.range) {\n                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n                    rv.range = rv.range.slice(0);\n                    rv.range[0] = rv.range[1];\n                }\n\n                if (l2) {\n                    // shallow-mixin L2, then adjust last col/row accordingly.\n                    shallow_copy_noclobber(rv, l2);\n                    rv.last_line = l2.last_line;\n                    rv.last_column = l2.last_column;\n                    if (rv.range && l2.range) {\n                        rv.range[1] = l2.range[1];\n                    }\n                }\n                return rv;\n            }\n        }\n\n        if (!l1) {\n            l1 = l2;\n            l2 = null;\n        }\n        if (!l1) {\n            return undefined;\n        }\n\n        // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking\n        // at unconventional yylloc info objects...\n        rv = shallow_copy(l1);\n\n        // first_line: ...,\n        // first_column: ...,\n        // last_line: ...,\n        // last_column: ...,\n        if (rv.range) {\n            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:\n            rv.range = rv.range.slice(0);\n        }\n\n        if (l2) {\n            shallow_copy_noclobber(rv, l2);\n            rv.last_line = l2.last_line;\n            rv.last_column = l2.last_column;\n            if (rv.range && l2.range) {\n                rv.range[1] = l2.range[1];\n            }\n        }\n\n        return rv;\n    };\n\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!\n    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {\n        var pei = {\n            errStr: msg,\n            exception: ex,\n            text: lexer.match,\n            value: lexer.yytext,\n            token: this.describeSymbol(symbol) || symbol,\n            token_id: symbol,\n            line: lexer.yylineno,\n            loc: copy_yylloc(lexer.yylloc),\n            expected: expected,\n            recoverable: recoverable,\n            state: state,\n            action: action,\n            new_state: newState,\n            symbol_stack: stack,\n            state_stack: sstack,\n            value_stack: vstack,\n            location_stack: lstack,\n            stack_pointer: sp,\n            yy: sharedState_yy,\n            lexer: lexer,\n            parser: this,\n\n            // and make sure the error info doesn't stay due to potential\n            // ref cycle via userland code manipulations.\n            // These would otherwise all be memory leak opportunities!\n            //\n            // Note that only array and object references are nuked as those\n            // constitute the set of elements which can produce a cyclic ref.\n            // The rest of the members is kept intact as they are harmless.\n            destroy: function destructParseErrorInfo() {\n                // remove cyclic references added to error info:\n                // info.yy = null;\n                // info.lexer = null;\n                // info.value = null;\n                // info.value_stack = null;\n                // ...\n                var rec = !!this.recoverable;\n                for (var key in this) {\n                    if (this.hasOwnProperty(key) && typeof key === 'object') {\n                        this[key] = undefined;\n                    }\n                }\n                this.recoverable = rec;\n            }\n        };\n        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n        this.__error_infos.push(pei);\n        return pei;\n    };\n\n\n\n\n\n\n\n\n\n\n\n\n\n    function getNonTerminalFromCode(symbol) {\n        var tokenName = self.getSymbolName(symbol);\n        if (!tokenName) {\n            tokenName = symbol;\n        }\n        return tokenName;\n    }\n\n\n    function stdLex() {\n        var token = lexer.lex();\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    function fastLex() {\n        var token = lexer.fastLex();\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    var lex = stdLex;\n\n\n    var state, action, r, t;\n    var yyval = {\n        $: true,\n        _$: undefined,\n        yy: sharedState_yy\n    };\n    var p;\n    var yyrulelen;\n    var this_production;\n    var newState;\n    var retval = false;\n\n\n    try {\n        this.__reentrant_call_depth++;\n\n        lexer.setInput(input, sharedState_yy);\n\n        // NOTE: we *assume* no lexer pre/post handlers are set up *after* \n        // this initial `setInput()` call: hence we can now check and decide\n        // whether we'll go with the standard, slower, lex() API or the\n        // `fast_lex()` one:\n        if (typeof lexer.canIUse === 'function') {\n            var lexerInfo = lexer.canIUse();\n            if (lexerInfo.fastLex && typeof fastLex === 'function') {\n                lex = fastLex;\n            }\n        } \n\n        yyloc = lexer.yylloc;\n        lstack[sp] = yyloc;\n        vstack[sp] = null;\n        sstack[sp] = 0;\n        stack[sp] = 0;\n        ++sp;\n\n        yytext = lexer.yytext;\n\n\n\n        if (this.pre_parse) {\n            this.pre_parse.call(this, sharedState_yy);\n        }\n        if (sharedState_yy.pre_parse) {\n            sharedState_yy.pre_parse.call(this, sharedState_yy);\n        }\n\n        newState = sstack[sp - 1];\n        for (;;) {\n            // retrieve state number from top of stack\n            state = newState;               // sstack[sp - 1];\n\n            // use default actions if available\n            if (this.defaultActions[state]) {\n                action = 2;\n                newState = this.defaultActions[state];\n            } else {\n                // The single `==` condition below covers both these `===` comparisons in a single\n                // operation:\n                //\n                //     if (symbol === null || typeof symbol === 'undefined') ...\n                if (!symbol) {\n                    symbol = lex();\n                }\n                // read action for current state and first input\n                t = (table[state] && table[state][symbol]) || NO_ACTION;\n                newState = t[1];\n                action = t[0];\n\n\n\n\n\n\n\n\n\n\n\n                // handle parse error\n                if (!action) {\n                    var errStr;\n                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);\n                    var expected = this.collect_expected_token_set(state);\n\n                    // Report error\n                    if (typeof lexer.yylineno === 'number') {\n                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';\n                    } else {\n                        errStr = 'Parse error: ';\n                    }\n                    if (typeof lexer.showPosition === 'function') {\n                        errStr += '\\n' + lexer.showPosition(79 - 10, 10) + '\\n';\n                    }\n                    if (expected.length) {\n                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;\n                    } else {\n                        errStr += 'Unexpected ' + errSymbolDescr;\n                    }\n                    // we cannot recover from the error!\n                    p = this.constructParseErrorInfo(errStr, null, expected, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== 'undefined') {\n                        retval = r;\n                    }\n                    break;\n                }\n\n\n            }\n\n\n\n\n\n\n\n\n\n\n            switch (action) {\n            // catch misc. parse failures:\n            default:\n                // this shouldn't happen, unless resolve defaults are off\n                if (action instanceof Array) {\n                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== 'undefined') {\n                        retval = r;\n                    }\n                    break;\n                }\n                // Another case of better safe than sorry: in case state transitions come out of another error recovery process\n                // or a buggy LUT (LookUp Table):\n                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);\n                r = this.parseError(p.errStr, p, this.JisonParserError);\n                if (typeof r !== 'undefined') {\n                    retval = r;\n                }\n                break;\n\n            // shift:\n            case 1:\n                stack[sp] = symbol;\n                vstack[sp] = lexer.yytext;\n                lstack[sp] = copy_yylloc(lexer.yylloc);\n                sstack[sp] = newState; // push state\n\n                ++sp;\n                symbol = 0;\n\n\n\n\n                // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:\n\n                yytext = lexer.yytext;\n\n                yyloc = lexer.yylloc;\n                continue;\n\n            // reduce:\n            case 2:\n\n\n\n                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\n                yyrulelen = this_production[1];\n\n\n\n\n\n\n\n\n\n\n                r = this.performAction.call(yyval, yytext, yyloc, newState, sp - 1, vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    retval = r;\n                    break;\n                }\n\n                // pop off stack\n                sp -= yyrulelen;\n\n                // don't overwrite the `symbol` variable: use a local var to speed things up:\n                var ntsymbol = this_production[0];    // push nonterminal (reduce)\n                stack[sp] = ntsymbol;\n                vstack[sp] = yyval.$;\n                lstack[sp] = yyval._$;\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[sstack[sp - 1]][ntsymbol];\n                sstack[sp] = newState;\n                ++sp;\n\n\n\n\n\n\n\n\n\n                continue;\n\n            // accept:\n            case 3:\n                if (sp !== -2) {\n                    retval = true;\n                    // Return the `$accept` rule's `$$` result, if available.\n                    //\n                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,\n                    // default, action):\n                    //\n                    //     $accept: <startSymbol> $end\n                    //                  %{ $$ = $1; @$ = @1; %}\n                    //\n                    // which, combined with the parse kernel's `$accept` state behaviour coded below,\n                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,\n                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)\n                    //\n                    // In code:\n                    //\n                    //                  %{\n                    //                      @$ = @1;            // if location tracking support is included\n                    //                      if (typeof $1 !== 'undefined')\n                    //                          return $1;\n                    //                      else\n                    //                          return true;           // the default parse result if the rule actions don't produce anything\n                    //                  %}\n                    sp--;\n                    if (typeof vstack[sp] !== 'undefined') {\n                        retval = vstack[sp];\n                    }\n                }\n                break;\n            }\n\n            // break out of loop: we accept or fail with error\n            break;\n        }\n    } catch (ex) {\n        // report exceptions through the parseError callback too, but keep the exception intact\n        // if it is a known parser or lexer error which has been thrown by parseError() already:\n        if (ex instanceof this.JisonParserError) {\n            throw ex;\n        }\n        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {\n            throw ex;\n        }\n\n        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);\n        retval = false;\n        r = this.parseError(p.errStr, p, this.JisonParserError);\n        if (typeof r !== 'undefined') {\n            retval = r;\n        }\n    } finally {\n        retval = this.cleanupAfterParse(retval, true, true);\n        this.__reentrant_call_depth--;\n    }   // /finally\n\n    return retval;\n}\n};\nparser.originalParseError = parser.parseError;\nparser.originalQuoteName = parser.quoteName;\n\nconst t = require(\"../parsetree\");\n\nfunction Parser() {\n  this.yy = {};\n}\nParser.prototype = parser;\nparser.Parser = Parser;\n\nreturn new Parser();\n})();\n\n        \n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\n  exports.parser = c_grammar;\n  exports.Parser = c_grammar.Parser;\n  exports.parse = function () {\n    return c_grammar.parse.apply(c_grammar, arguments);\n  };\n  \n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module\n__webpack_require__(3762);\n// This entry module used 'exports' so it can't be inlined\n"],"sourceRoot":""}