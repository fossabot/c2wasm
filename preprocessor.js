(()=>{var e={9271:function(e,t){var n,i,r;i=[],void 0===(r="function"==typeof(n=function(){"use strict";var e=Object.prototype.hasOwnProperty,t=Object.prototype.toString,n="boolean"==typeof(new RegExp).sticky;function i(e){return e&&"[object RegExp]"===t.call(e)}function r(e){return e&&"object"==typeof e&&!i(e)&&!Array.isArray(e)}function s(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function a(e){return new RegExp("|"+e).exec("").length-1}function o(e){return"("+e+")"}function c(e){return e.length?"(?:"+e.map((function(e){return"(?:"+e+")"})).join("|")+")":"(?!)"}function l(e){if("string"==typeof e)return"(?:"+s(e)+")";if(i(e)){if(e.ignoreCase)throw new Error("RegExp /i flag not allowed");if(e.global)throw new Error("RegExp /g flag is implied");if(e.sticky)throw new Error("RegExp /y flag is implied");if(e.multiline)throw new Error("RegExp /m flag is implied");return e.source}throw new Error("Not a pattern: "+e)}function h(e){for(var t=Object.getOwnPropertyNames(e),n=[],i=0;i<t.length;i++){var s=t[i],a=e[s],o=[].concat(a);if("include"!==s){var c=[];o.forEach((function(e){r(e)?(c.length&&n.push(u(s,c)),n.push(u(s,e)),c=[]):c.push(e)})),c.length&&n.push(u(s,c))}else for(var l=0;l<o.length;l++)n.push({include:o[l]})}return n}function f(e){for(var t=[],n=0;n<e.length;n++){var i=e[n];if(i.include)for(var r=[].concat(i.include),s=0;s<r.length;s++)t.push({include:r[s]});else{if(!i.type)throw new Error("Rule has no type: "+JSON.stringify(i));t.push(u(i.type,i))}}return t}function u(t,n){if(r(n)||(n={match:n}),n.include)throw new Error("Matching rules cannot also include states");var s={defaultType:t,lineBreaks:!!n.error||!!n.fallback,pop:!1,next:null,push:null,error:!1,fallback:!1,value:null,type:null,shouldThrow:!1};for(var a in n)e.call(n,a)&&(s[a]=n[a]);if("string"==typeof s.type&&t!==s.type)throw new Error("Type transform cannot be a string (type '"+s.type+"' for token '"+t+"')");var o=s.match;return s.match=Array.isArray(o)?o:o?[o]:[],s.match.sort((function(e,t){return i(e)&&i(t)?0:i(t)?-1:i(e)?1:t.length-e.length})),s}function d(e){return Array.isArray(e)?f(e):h(e)}var p=u("error",{lineBreaks:!0,shouldThrow:!0});function _(e,t){for(var r=null,s=Object.create(null),h=!0,f=null,u=[],d=[],_=0;_<e.length;_++)e[_].fallback&&(h=!1);for(_=0;_<e.length;_++){var y=e[_];if(y.include)throw new Error("Inheritance is not allowed in stateless lexers");if(y.error||y.fallback){if(r)throw!y.fallback==!r.fallback?new Error("Multiple "+(y.fallback?"fallback":"error")+" rules not allowed (for token '"+y.defaultType+"')"):new Error("fallback and error are mutually exclusive (for token '"+y.defaultType+"')");r=y}var m=y.match.slice();if(h)for(;m.length&&"string"==typeof m[0]&&1===m[0].length;)s[m.shift().charCodeAt(0)]=y;if(y.pop||y.push||y.next){if(!t)throw new Error("State-switching options are not allowed in stateless lexers (for token '"+y.defaultType+"')");if(y.fallback)throw new Error("State-switching options are not allowed on fallback tokens (for token '"+y.defaultType+"')")}if(0!==m.length){h=!1,u.push(y);for(var g=0;g<m.length;g++){var b=m[g];if(i(b))if(null===f)f=b.unicode;else if(f!==b.unicode&&!1===y.fallback)throw new Error("If one rule is /u then all must be")}var v=c(m.map(l)),w=new RegExp(v);if(w.test(""))throw new Error("RegExp matches empty string: "+w);if(a(v)>0)throw new Error("RegExp has capture groups: "+w+"\nUse (?: â€¦ ) instead");if(!y.lineBreaks&&w.test("\n"))throw new Error("Rule should declare lineBreaks: "+w);d.push(o(v))}}var C=r&&r.fallback,A=n&&!C?"ym":"gm",x=n||C?"":"|";return!0===f&&(A+="u"),{regexp:new RegExp(c(d)+x,A),groups:u,fast:s,error:r||p}}function y(e){var t=_(d(e));return new v({start:t},"start")}function m(e,t,n){var i=e&&(e.push||e.next);if(i&&!n[i])throw new Error("Missing state '"+i+"' (in token '"+e.defaultType+"' of state '"+t+"')");if(e&&e.pop&&1!=+e.pop)throw new Error("pop must be 1 (in token '"+e.defaultType+"' of state '"+t+"')")}function g(e,t){var n=e.$all?d(e.$all):[];delete e.$all;var i=Object.getOwnPropertyNames(e);t||(t=i[0]);for(var r=Object.create(null),s=0;s<i.length;s++)r[g=i[s]]=d(e[g]).concat(n);for(s=0;s<i.length;s++)for(var a=r[g=i[s]],o=Object.create(null),c=0;c<a.length;c++){var l=a[c];if(l.include){var h=[c,1];if(l.include!==g&&!o[l.include]){o[l.include]=!0;var f=r[l.include];if(!f)throw new Error("Cannot include nonexistent state '"+l.include+"' (in state '"+g+"')");for(var u=0;u<f.length;u++){var p=f[u];-1===a.indexOf(p)&&h.push(p)}}a.splice.apply(a,h),c--}}var y=Object.create(null);for(s=0;s<i.length;s++){var g;y[g=i[s]]=_(r[g],!0)}for(s=0;s<i.length;s++){var b=i[s],w=y[b],C=w.groups;for(c=0;c<C.length;c++)m(C[c],b,y);var A=Object.getOwnPropertyNames(w.fast);for(c=0;c<A.length;c++)m(w.fast[A[c]],b,y)}return new v(y,t)}function b(e){for(var t=Object.create(null),n=Object.create(null),i=Object.getOwnPropertyNames(e),r=0;r<i.length;r++){var s=i[r],a=e[s];(Array.isArray(a)?a:[a]).forEach((function(e){if((n[e.length]=n[e.length]||[]).push(e),"string"!=typeof e)throw new Error("keyword must be string (in keyword '"+s+"')");t[e]=s}))}function o(e){return JSON.stringify(e)}var c="";for(var l in c+="switch (value.length) {\n",n){var h=n[l];c+="case "+l+":\n",c+="switch (value) {\n",h.forEach((function(e){var n=t[e];c+="case "+o(e)+": return "+o(n)+"\n"})),c+="}\n"}return c+="}\n",Function("value",c)}var v=function(e,t){this.startState=t,this.states=e,this.buffer="",this.stack=[],this.reset()};v.prototype.reset=function(e,t){return this.buffer=e||"",this.index=0,this.line=t?t.line:1,this.col=t?t.col:1,this.queuedToken=t?t.queuedToken:null,this.queuedThrow=t?t.queuedThrow:null,this.setState(t?t.state:this.startState),this.stack=t&&t.stack?t.stack.slice():[],this},v.prototype.save=function(){return{line:this.line,col:this.col,state:this.state,stack:this.stack.slice(),queuedToken:this.queuedToken,queuedThrow:this.queuedThrow}},v.prototype.setState=function(e){if(e&&this.state!==e){this.state=e;var t=this.states[e];this.groups=t.groups,this.error=t.error,this.re=t.regexp,this.fast=t.fast}},v.prototype.popState=function(){this.setState(this.stack.pop())},v.prototype.pushState=function(e){this.stack.push(this.state),this.setState(e)};var w=n?function(e,t){return e.exec(t)}:function(e,t){var n=e.exec(t);return 0===n[0].length?null:n};function C(){return this.value}if(v.prototype._getGroup=function(e){for(var t=this.groups.length,n=0;n<t;n++)if(void 0!==e[n+1])return this.groups[n];throw new Error("Cannot find token type for matched text")},v.prototype.next=function(){var e=this.index;if(this.queuedGroup){var t=this._token(this.queuedGroup,this.queuedText,e);return this.queuedGroup=null,this.queuedText="",t}var n=this.buffer;if(e!==n.length){if(a=this.fast[n.charCodeAt(e)])return this._token(a,n.charAt(e),e);var i=this.re;i.lastIndex=e;var r=w(i,n),s=this.error;if(null==r)return this._token(s,n.slice(e,n.length),e);var a=this._getGroup(r),o=r[0];return s.fallback&&r.index!==e?(this.queuedGroup=a,this.queuedText=o,this._token(s,n.slice(e,r.index),e)):this._token(a,o,e)}},v.prototype._token=function(e,t,n){var i=0;if(e.lineBreaks){var r=/\n/g,s=1;if("\n"===t)i=1;else for(;r.exec(t);)i++,s=r.lastIndex}var a={type:"function"==typeof e.type&&e.type(t)||e.defaultType,value:"function"==typeof e.value?e.value(t):t,text:t,toString:C,offset:n,lineBreaks:i,line:this.line,col:this.col},o=t.length;if(this.index+=o,this.line+=i,0!==i?this.col=o-s+1:this.col+=o,e.shouldThrow)throw new Error(this.formatError(a,"invalid syntax"));return e.pop?this.popState():e.push?this.pushState(e.push):e.next&&this.setState(e.next),a},"undefined"!=typeof Symbol&&Symbol.iterator){var A=function(e){this.lexer=e};A.prototype.next=function(){var e=this.lexer.next();return{value:e,done:!e}},A.prototype[Symbol.iterator]=function(){return this},v.prototype[Symbol.iterator]=function(){return new A(this)}}return v.prototype.formatError=function(e,t){if(null==e){var n=this.buffer.slice(this.index);e={text:n,offset:this.index,lineBreaks:-1===n.indexOf("\n")?0:1,line:this.line,col:this.col}}var i=Math.max(0,e.offset-e.col+1),r=e.lineBreaks?e.text.indexOf("\n"):e.text.length,s=this.buffer.substring(i,e.offset+r);return t+=" at line "+e.line+" col "+e.col+":\n\n",t+="  "+s+"\n",t+="  "+Array(e.col).join(" ")+"^"},v.prototype.clone=function(){return new v(this.states,this.state)},v.prototype.has=function(e){return!0},{compile:y,states:g,error:Object.freeze({error:!0}),fallback:Object.freeze({fallback:!0}),keywords:b}})?n.apply(t,i):n)||(e.exports=r)},4156:(e,t,n)=>{"use strict";const i=n(4551),r="\nint factorial(int v) {\n  return v < 2 ? 1 : v * factorial(v - 1);\n}\n".trimStart();function s(e){try{const t=new i.Preprocessor("main.c");for(let e=0;e<5;e++)t.libraryFiles.set(`library${e}.h`,`void library${e}() {}`),t.userFiles.set(`user${e}.h`,`void user${e}() {}`);return t.process(e)}catch(e){return console.debug(e),e.stack}}if("undefined"!=typeof window&&window.document){window.document.write(`\n        <h1>c2wasm preprocessor</h1>\n        <div>\n            <textarea id="textInput" rows="20" style="width: 100%; resize: vertical">${r}</textarea>\n            <pre id="output">${s(r)}</pre>\n        </div>\n    `);const e=window.document.getElementById("textInput"),t=window.document.getElementById("output");e.addEventListener("input",(()=>{t.textContent=s(e.value)}))}else console.log(s(r))},7745:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.locationString=t.CError=void 0;class CError extends Error{constructor(e,t,i){super(e),this.node=t,this.node2=i,this.name="CError",t?.loc&&(this.message+="\n\n"+n(t.loc),i?.loc&&(this.message+="\n\n"+n(i.loc,"Secondary location")))}}function n(e,t="Location"){const n=e._source.split("\n");if(e.first_line>=n.length)return t+": [UNKNOWN]";let i=t+":\n";const r=Math.ceil(Math.log10(e.last_line+4));function s(e){i+=`L${(e+1).toString().padStart(r,"0")}: ${n[e]}\n`}return e.first_line>1&&s(e.first_line-2),e.first_line>0&&s(e.first_line-1),s(e.first_line),i+=new Array(3+r+e.first_column).join(" "),e.first_line===e.last_line?i+=new Array(1+e.last_column-e.first_column).join("^"):i+="^",i+="\n",e.first_line+1<n.length&&s(e.first_line+1),e.first_line+2<n.length&&s(e.first_line+2),i}t.CError=CError,t.locationString=n},7601:function(e,t,n){"use strict";var i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.LIBRARY_HEADERS=t.STANDARD_LIBRARY=void 0;const r=i(n(2993)),s="//_standard_library.json",a="//impl/";let o;if(Object.prototype.hasOwnProperty.call(r.default,"readdirSync")&&r.default.existsSync(a)){o=function e(t,n,i=new Map){for(const s of r.default.readdirSync(n+t)){const a=t.length>0?t+"/"+s:s;if(r.default.statSync(n+a).isDirectory())e(a,n,i);else{if(!s.endsWith(".h")&&!s.endsWith(".c"))continue;const e=r.default.readFileSync(n+a,"utf8").replace(/\r\n/g,"\n").replace(/(?:\/\*[^]*?\*\/)|(?:\/\/.*?$)/gm," ").replace(/^(?:[ \t]*\n+|[ \t]+)/gm,"");i.set(a,e)}}return i}("",a);try{(function(e){if(r.default.existsSync(s)){const t=r.default.readFileSync(s,"utf-8"),n=JSON.parse(t);if(Object.values(n).length!==e.size)return!0;for(const[t,i]of e.entries())if(n[t]!==i)return!0;return!1}return!0})(o)&&function(e){console.trace("[standard library]: cache out of date\n");const t={};for(const[n,i]of e.entries())t[n]=i;r.default.writeFileSync(s,JSON.stringify(t))}(o)}catch(e){console.warn(e)}}else{o=new Map;const e=n(4118);Object.entries(e).forEach((([e,t])=>o.set(e,t)))}t.STANDARD_LIBRARY=o,t.LIBRARY_HEADERS=(()=>{const e=new Map;for(const[t,n]of o.entries())t.endsWith(".h")&&e.set(t,n);return e})()},1225:function(e,t,n){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,t,n,i){void 0===i&&(i=n),Object.defineProperty(e,i,{enumerable:!0,get:function(){return t[n]}})}:function(e,t,n,i){void 0===i&&(i=n),e[i]=t[n]}),r=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),s=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&i(t,e,n);return r(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.parse=t.ParseTreeValidationError=t.ParseNode=t.pt=void 0,t.pt=s(n(3377));var a=n(3377);Object.defineProperty(t,"ParseNode",{enumerable:!0,get:function(){return a.ParseNode}});var o=n(9595);Object.defineProperty(t,"ParseTreeValidationError",{enumerable:!0,get:function(){return o.ParseTreeValidationError}});var c=n(5234);Object.defineProperty(t,"parse",{enumerable:!0,get:function(){return c.parse}})},8927:function(e,t,n){"use strict";var i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.lexer=void 0;const r=i(n(9271));var s;t.lexer=r.default.compile({$comment:{match:/(?:\/\*[^]*?\*\/)|(?:\/\/.*?$)/,multiline:!0},IDENTIFIER:{match:/[a-zA-Z_][a-zA-Z0-9_]*/,type:r.default.keywords(Object.fromEntries(["if","break","case","char","const","continue","default","do","double","else","enum","extern","float","for","inline","int","long","return","short","signed","sizeof","static","struct","switch","typedef","union","unsigned","void","while","_Bool","auto","goto","register","volatile","import"].map((e=>[e.toUpperCase(),e]))))},CONSTANT_FLOAT:/(?:[0-9]+[Ee][+-]?[0-9]+|(?:[0-9]*\.[0-9]+|[0-9]+\.[0-9]*)(?:[Ee][+-]?[0-9]+)?)[fFlL]?|(?:[1-9][0-9]*|0)[fF]/,CONSTANT_HEX:/0[xX][a-fA-F0-9]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,CONSTANT_OCTAL:/0[0-7]+(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,CONSTANT_INT:/(?:[1-9][0-9]*|0)(?:[uU][lL]{0,2}|[lL]{1,2}[uU]?|)/,CONSTANT_CHAR:{match:/'(?:[^\\\n']|\\(?:.|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))'/,value:e=>e.slice(1,-1)},STRING_LITERAL:{match:/"(?:[^\\\n"]|\\(?:[^x0-7\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3}))*"/,value:e=>e.slice(1,-1)},ELLIPSIS:"...",RIGHT_ASSIGN:">>=",LEFT_ASSIGN:"<<=",ADD_ASSIGN:"+=",SUB_ASSIGN:"-=",MUL_ASSIGN:"*=",DIV_ASSIGN:"/=",MOD_ASSIGN:"%=",AND_ASSIGN:"&=",XOR_ASSIGN:"^=",OR_ASSIGN:"|=",RIGHT_OP:">>",LEFT_OP:"<<",INC_OP:"++",DEC_OP:"--",PTR_OP:"->",AND_OP:"&&",OR_OP:"||",LE_OP:"<=",GE_OP:">=",EQ_OP:"==",NE_OP:"!=",...Object.fromEntries([";","{","}",",",":","=","(",")","[","]",".","&","!","~","-","+","*","/","%","<",">","^","|","?"].map((e=>[e,e]))),$whitespace:[{match:/[ \t\v\f]+/},{match:/\n/,lineBreaks:!0}]}),t.lexer.next=(s=t.lexer.next,()=>{let e=s.call(t.lexer);for(;"$"===e?.type?.charAt(0);)e=s.call(t.lexer);return e})},5234:function(e,t,n){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,t,n,i){void 0===i&&(i=n),Object.defineProperty(e,i,{enumerable:!0,get:function(){return t[n]}})}:function(e,t,n,i){void 0===i&&(i=n),e[i]=t[n]}),r=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),s=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&i(t,e,n);return r(t,e),t},a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.parse=void 0;const o=n(7745),c=n(8927),l=a(n(6347)),h=s(n(3377)),f=n(9595);let u=1;const d=l.default;d.parser.lexer=new class WrappedLexer{constructor(){this.yylloc={first_line:0,first_column:0,last_line:0,last_column:0,_source:"",_sourceId:0},this.yylineno=0,this.types=new Map}lex(){const e=c.lexer.next();return this.yytext=e?.value,e&&e.type?(this.yylloc={first_line:e.line-1,first_column:e.col,last_line:e.line+e.lineBreaks-1,last_column:e.lineBreaks?0:e.col+e.text.length,_sourceId:this.yylloc._sourceId,_source:this.yylloc._source},this.yylineno=this.yylloc.first_line,"IDENTIFIER"===e.type&&this.types.get(e.text)?"TYPE_NAME":e.type):"EOF"}setInput(e){this.yylloc={first_line:0,first_column:0,last_line:0,last_column:0,_source:"",_sourceId:0},this.yylineno=0,this.yytext=void 0,this.types.clear(),c.lexer.reset(e),this.yylloc._source=e,this.yylloc._sourceId=u++}externalDeclaration(e){if("typedef"===e.typeInfo.storageList[0])for(let t of e.list){for(;!(t instanceof h.IdentifierDeclarator);)t=t.body;this.types.set(t.id,!0)}}},t.parse=function(e){try{const t=d.parse(e);return f.validate(t)}catch(e){throw e?.hash?.loc&&(e.message+="\n\n"+o.locationString(e.hash?.loc)),e}}},3377:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FunctionDefinition=t.ReturnStatement=t.BreakStatement=t.ContinueStatement=t.GotoStatement=t.DoWhileLoop=t.WhileLoop=t.ForLoop=t.NoOp=t.ExpressionStatement=t.CompoundStatement=t.DefaultStatement=t.CaseStatement=t.SwitchStatement=t.IfStatement=t.Statement=t.AbstractFunctionDeclarator=t.AbstractArrayDeclarator=t.AbstractPointerDeclarator=t.TypeName=t.Pointer=t.ParameterDeclaration=t.FunctionDeclarator=t.ArrayDeclarator=t.IdentifierDeclarator=t.PointerDeclarator=t.StructDeclaration=t.StructUnionSpecifier=t.InitDeclarator=t.Declaration=t.Enumerator=t.EnumSpecifier=t.DeclarationSpecifiers=t.SpecifierQualifiers=t.CustomTypeSpecifier=t.ConstantExpression=t.AssignmentExpression=t.ConditionalExpression=t.MemberAccessExpression=t.FunctionCallExpression=t.CastExpression=t.SizeofExpression=t.BinaryExpression=t.BinaryOperations=t.UnaryExpression=t.UnaryOperations=t.StringLiteral=t.Constant=t.Identifier=t.Expression=t.ParseNode=void 0;class ParseNode{constructor(e){this.loc=e}*children(){}}t.ParseNode=ParseNode;class Expression extends ParseNode{constructor(){super(...arguments),this._expression=!0}}t.Expression=Expression;t.Identifier=class Identifier extends Expression{constructor(e,t){super(e),this.name=t,this.type="identifier"}};t.Constant=class Constant extends Expression{constructor(e,t,n){super(e),this.value=t,this.valueType=n,this.type="constant"}};t.StringLiteral=class StringLiteral extends Expression{constructor(e,t){super(e),this.value=t,this.type="stringLiteral"}},t.UnaryOperations=["postfixIncrement","postfixDecrement","prefixIncrement","prefixDecrement","addressOf","dereference","unaryPlus","unaryMinus","bitwiseNot","logicalNot"];t.UnaryExpression=class UnaryExpression extends Expression{constructor(e,t,n){super(e),this.type=t,this.body=n,this._unaryExpr=!0}*children(){yield this.body}},t.BinaryOperations=["arraySubscript","comma","mul","div","mod","add","sub","bitwiseShiftLeft","bitwiseShiftRight","relationalLT","relationalGT","relationalLEq","relationalGEq","relationalEq","relationalNEq","bitwiseAnd","bitwiseXor","bitwiseOr","logicalAnd","logicalOr"];t.BinaryExpression=class BinaryExpression extends Expression{constructor(e,t,n,i){super(e),this.type=t,this.lhs=n,this.rhs=i,this._binaryExpr=!0}*children(){yield this.lhs,yield this.rhs}};t.SizeofExpression=class SizeofExpression extends Expression{constructor(e,t){super(e),this.body=t,this.type="sizeof"}*children(){yield this.body}};t.CastExpression=class CastExpression extends Expression{constructor(e,t,n){super(e),this.targetType=t,this.body=n,this.type="cast"}*children(){yield this.targetType,yield this.body}};t.FunctionCallExpression=class FunctionCallExpression extends Expression{constructor(e,t,n=[]){super(e),this.fn=t,this.args=n,this.type="functionCall"}*children(){yield this.fn,yield*this.args}};t.MemberAccessExpression=class MemberAccessExpression extends Expression{constructor(e,t,n,i){super(e),this.pointer=t,this.lhs=n,this.rhs=i,this.type="access"}*children(){yield this.lhs}};t.ConditionalExpression=class ConditionalExpression extends Expression{constructor(e,t,n,i){super(e),this.condition=t,this.trueValue=n,this.falseValue=i,this.type="conditional"}*children(){yield this.condition,yield this.trueValue,yield this.falseValue}};class AssignmentExpression extends Expression{constructor(e,t,n,i){super(e),this.assignType=t,this.lhs=n,this.rhs=i,this.type="assign"}*children(){yield this.lhs,yield this.rhs}}t.AssignmentExpression=AssignmentExpression;t.ConstantExpression=class ConstantExpression extends Expression{constructor(e,t){super(e),this.expr=t,this.type="constantExpr"}*children(){yield this.expr}};t.CustomTypeSpecifier=class CustomTypeSpecifier extends ParseNode{constructor(e,t){super(e),this.name=t,this.type="customType"}};t.SpecifierQualifiers=class SpecifierQualifiers extends ParseNode{constructor(e,t,n){super(e),this.specifierList=t,this.qualifierList=n,this.type="specifiersAndQualifiers"}*children(){for(const e of this.specifierList)e instanceof ParseNode&&(yield e)}};t.DeclarationSpecifiers=class DeclarationSpecifiers extends ParseNode{constructor(e,t,n,i,r){super(e),this.specifierList=t,this.qualifierList=n,this.storageList=i,this.fnSpecifierList=r,this.type="declarationSpecifiers"}*children(){for(const e of this.specifierList)e instanceof ParseNode&&(yield e)}};t.EnumSpecifier=class EnumSpecifier extends ParseNode{constructor(e,t,n){super(e),this.id=t,this.body=n,this.type="enum"}*children(){this.body&&(yield*this.body)}};t.Enumerator=class Enumerator extends ParseNode{constructor(e,t,n){super(e),this.id=t,this.value=n,this.type="enumerator"}*children(){this.value&&(yield this.value)}};t.Declaration=class Declaration extends ParseNode{constructor(e,t,n=[]){super(e),this.typeInfo=t,this.list=n,this.type="declaration"}*children(){yield this.typeInfo,yield*this.list}};t.InitDeclarator=class InitDeclarator extends ParseNode{constructor(e,t,n){super(e),this.body=t,this.initializer=n,this.type="initDeclarator"}*children(){yield this.body,yield*this.exploreInitializer()}*exploreInitializer(e=this.initializer){if(e instanceof AssignmentExpression)yield e;else if(Array.isArray(e))for(const t of e)yield*this.exploreInitializer(t)}};t.StructUnionSpecifier=class StructUnionSpecifier extends ParseNode{constructor(e,t,n,i){super(e),this.structure=t,this.id=n,this.declarations=i,this.type="structUnionSpecifier"}*children(){this.declarations&&(yield*this.declarations)}};t.StructDeclaration=class StructDeclaration extends ParseNode{constructor(e,t,n=[]){super(e),this.typeInfo=t,this.list=n,this.type="structDeclaration"}*children(){yield this.typeInfo,yield*this.list}};t.PointerDeclarator=class PointerDeclarator extends ParseNode{constructor(e,t,n){super(e),this.pointer=t,this.body=n,this.type="pointerDeclarator",this.abstractDeclarator=!1}*children(){yield this.pointer,yield this.body}};t.IdentifierDeclarator=class IdentifierDeclarator extends ParseNode{constructor(e,t){super(e),this.id=t,this.type="identifierDeclarator",this.abstractDeclarator=!1}};t.ArrayDeclarator=class ArrayDeclarator extends ParseNode{constructor(e,t,n){super(e),this.body=t,this.length=n,this.type="arrayDeclarator",this.abstractDeclarator=!1}*children(){yield this.body,this.length&&(yield this.length)}};t.FunctionDeclarator=class FunctionDeclarator extends ParseNode{constructor(e,t,n,i=!1){super(e),this.body=t,this.args=n,this.variadic=i,this.type="functionDeclarator",this.abstractDeclarator=!1}*children(){yield this.body;for(const e of this.args??[])e instanceof ParseNode&&(yield e)}};t.ParameterDeclaration=class ParameterDeclaration extends ParseNode{constructor(e,t,n){super(e),this.typeInfo=t,this.declarator=n,this.type="parameterDeclaration"}*children(){yield this.typeInfo,this.declarator&&(yield this.declarator)}};t.Pointer=class Pointer extends ParseNode{constructor(e,t,n){super(e),this.qualifierList=t,this.body=n,this.type="pointer"}*children(){this.body&&(yield this.body)}};t.TypeName=class TypeName extends ParseNode{constructor(e,t,n){super(e),this.typeInfo=t,this.declarator=n,this.type="typeName"}*children(){yield this.typeInfo,this.declarator&&(yield this.declarator)}};t.AbstractPointerDeclarator=class AbstractPointerDeclarator extends ParseNode{constructor(e,t,n){super(e),this.pointer=t,this.body=n,this.type="abstractPointerDeclarator",this.abstractDeclarator=!0}*children(){yield this.pointer,this.body&&(yield this.body)}};t.AbstractArrayDeclarator=class AbstractArrayDeclarator extends ParseNode{constructor(e,t,n){super(e),this.body=t,this.length=n,this.type="abstractArrayDeclarator",this.abstractDeclarator=!0}*children(){this.body&&(yield this.body),this.length&&(yield this.length)}};t.AbstractFunctionDeclarator=class AbstractFunctionDeclarator extends ParseNode{constructor(e,t,n,i=!1){super(e),this.body=t,this.args=n,this.variadic=i,this.type="abstractFunctionDeclarator",this.abstractDeclarator=!0}*children(){this.body&&(yield this.body),this.args&&(yield*this.args)}};class Statement extends ParseNode{constructor(){super(...arguments),this._statement=!0}setLabel(e){return this.label=e,this}}t.Statement=Statement;t.IfStatement=class IfStatement extends Statement{constructor(e,t,n,i){super(e),this.expression=t,this.ifBody=n,this.elseBody=i,this.type="ifStatement"}*children(){yield this.expression,yield this.ifBody,this.elseBody&&(yield this.elseBody)}};t.SwitchStatement=class SwitchStatement extends Statement{constructor(e,t,n){super(e),this.expression=t,this.body=n,this.type="switchStatement"}*children(){yield this.expression,yield this.body}};t.CaseStatement=class CaseStatement extends Statement{constructor(e,t,n){super(e),this.value=t,this.body=n,this.type="caseStatement"}*children(){yield this.value,yield this.body}};t.DefaultStatement=class DefaultStatement extends Statement{constructor(e,t){super(e),this.body=t,this.type="defaultStatement"}*children(){yield this.body}};t.CompoundStatement=class CompoundStatement extends Statement{constructor(e,t){super(e),this.body=t,this.type="compoundStatement"}*children(){yield*this.body}};t.ExpressionStatement=class ExpressionStatement extends Statement{constructor(e,t){super(e),this.expression=t,this.type="expressionStatement"}*children(){yield this.expression}};t.NoOp=class NoOp extends Statement{constructor(e){super(e),this.type="nopStatement"}};t.ForLoop=class ForLoop extends Statement{constructor(e,t,n,i,r){super(e),this.init=t,this.test=n,this.update=i,this.body=r,this.type="forStatement"}*children(){yield this.init,yield this.test,this.update&&(yield this.update),yield this.body}};t.WhileLoop=class WhileLoop extends Statement{constructor(e,t,n){super(e),this.test=t,this.body=n,this.type="whileStatement"}*children(){yield this.test,yield this.body}};t.DoWhileLoop=class DoWhileLoop extends Statement{constructor(e,t,n){super(e),this.body=t,this.test=n,this.type="doWhileStatement"}*children(){yield this.body,yield this.test}};t.GotoStatement=class GotoStatement extends Statement{constructor(e,t){super(e),this.target=t,this.type="gotoStatement"}};t.ContinueStatement=class ContinueStatement extends Statement{constructor(){super(...arguments),this.type="continueStatement"}};t.BreakStatement=class BreakStatement extends Statement{constructor(){super(...arguments),this.type="breakStatement"}};t.ReturnStatement=class ReturnStatement extends Statement{constructor(e,t){super(e),this.value=t,this.type="returnStatement"}*children(){this.value&&(yield this.value)}};t.FunctionDefinition=class FunctionDefinition extends ParseNode{constructor(e,t,n,i){super(e),this.typeInfo=t,this.declarator=n,this.body=i,this.type="functionDefinition"}*children(){yield this.typeInfo,yield this.declarator,yield this.body}}},9595:function(e,t,n){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,t,n,i){void 0===i&&(i=n),Object.defineProperty(e,i,{enumerable:!0,get:function(){return t[n]}})}:function(e,t,n,i){void 0===i&&(i=n),e[i]=t[n]}),r=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),s=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&i(t,e,n);return r(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.ParseTreeValidationError=t.validate=void 0;const a=n(7745),o=n(4902),c=s(n(3377)),l=new Map;t.validate=function e(t,n=[]){for(const i of t){n.push(i),e(i.children(),n),n.pop();for(const e of l.get(Object.getPrototypeOf(i).constructor)??[])e(i,n)}return t};class ParseTreeValidationError extends a.CError{constructor(e,t,n){super(e&&e.loc?`Line ${e.loc.first_line+1}: ${t}`:t,e,n),this.name="TreeValidationError"}}function h(e,t){const n=l.get(e);n?n.push(t):l.set(e,[t])}t.ParseTreeValidationError=ParseTreeValidationError;const f=e=>{if(e.qualifierList.length>1)throw new ParseTreeValidationError(e,"Invalid qualifiers.");!function(e,t){if(e.every((e=>"string"==typeof e))&&!o.getArithmeticType(e))throw new ParseTreeValidationError(t,"Invalid specifiers - "+e.join(", "))}(e.specifierList,e)};function u(e,t){for(let n=t.length-1;n>=0;n--){if(!(t[n]instanceof c.Expression)||"sizeof"===t[n].type)return;if("constantExpr"===t[n].type)throw new ParseTreeValidationError(e,"Invalid constant expr.")}}h(c.SpecifierQualifiers,f),h(c.DeclarationSpecifiers,f),h(c.DeclarationSpecifiers,((e,t)=>{if(e.storageList.length>1)throw new ParseTreeValidationError(e,"Invalid storage class list.");if(e.fnSpecifierList.length>1)throw new ParseTreeValidationError(e,"Invalid fn specifier list.");if("typedef"===e.storageList[0]&&1!==t.length)throw new ParseTreeValidationError(e,"Nested typedefs are not allowed")})),h(c.UnaryExpression,((e,t)=>{switch(e.type){case"postfixIncrement":case"postfixDecrement":case"prefixIncrement":case"prefixDecrement":case"addressOf":case"dereference":u(e,t)}})),h(c.BinaryExpression,((e,t)=>{switch(e.type){case"comma":case"arraySubscript":u(e,t)}})),h(c.FunctionCallExpression,u),h(c.MemberAccessExpression,u)},4168:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ppEvaluate=void 0;const i=n(1225),r=n(3377),s=n(5963);function a(e,t){if(e instanceof r.Constant&&"float"!==e.valueType)return BigInt(s.ptConstant(e).value);if(e instanceof r.BinaryExpression)switch(e.type){case"add":return a(e.lhs,t)+a(e.rhs,t);case"sub":return a(e.lhs,t)-a(e.rhs,t);case"mul":return a(e.lhs,t)*a(e.rhs,t);case"div":return a(e.lhs,t)/a(e.rhs,t);case"bitwiseAnd":return a(e.lhs,t)&a(e.rhs,t);case"bitwiseOr":return a(e.lhs,t)|a(e.rhs,t);case"bitwiseXor":return a(e.lhs,t)^a(e.rhs,t);case"bitwiseShiftLeft":return a(e.lhs,t)<<a(e.rhs,t);case"bitwiseShiftRight":return a(e.lhs,t)>>a(e.rhs,t);case"relationalEq":return a(e.lhs,t)===a(e.rhs,t)?1n:0n;case"relationalNEq":return a(e.lhs,t)!==a(e.rhs,t)?1n:0n;case"relationalLT":return a(e.lhs,t)<a(e.rhs,t)?1n:0n;case"relationalLEq":return a(e.lhs,t)<=a(e.rhs,t)?1n:0n;case"relationalGT":return a(e.lhs,t)>a(e.rhs,t)?1n:0n;case"relationalGEq":return a(e.lhs,t)>=a(e.rhs,t)?1n:0n;case"logicalAnd":return 0n!==a(e.lhs,t)&&0n!==a(e.rhs,t)?1n:0n;case"logicalOr":return 0n!==a(e.lhs,t)||0n!==a(e.rhs,t)?1n:0n}else if(e instanceof r.UnaryExpression)switch(e.type){case"unaryPlus":return a(e.body,t);case"unaryMinus":return-a(e.body,t);case"logicalNot":return 0n===a(e.body,t)?1n:0n}else if(e instanceof r.Identifier)return 0n;throw t.error("Invalid preprocessor expression")}t.ppEvaluate=function(e,t){const n=i.parse(`int x = ${e};`);if(1!==n.length||"declaration"!==n[0].type||1!==n[0].list.length||"initDeclarator"!==n[0].list[0].type||Array.isArray(n[0].list[0].initializer))throw t.error("Invalid #if conditional: `"+e+"`");return a(n[0].list[0].initializer,t)}},4221:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Definition=void 0;const i=n(5358);t.Definition=class Definition{constructor(e,t,n,i){this.preprocessor=e,this.identifier=t,this.replacement=n,this.parameters=i}expand(e){if(this.parameters.length>0)return this.expandWithParameters(e);return{output:this.replacement.map((e=>e.value)).join(""),line:e}}expandWithParameters(e){const t=e;if(0===(e=this.preprocessor.consume(e,i.PreProRegex.whitespace).remainingLine).length||"("!==e[0])return{output:this.identifier,line:t};e=this.preprocessor.mustConsume(e,"(").remainingLine;const n=[];for(let t=0;t<this.parameters.length;t++){const i=this.consumeArgument(e);n.push(i.value.trim()),e=t!==this.parameters.length-1?this.preprocessor.mustConsume(i.remainingLine,",").remainingLine:this.preprocessor.mustConsume(i.remainingLine,")").remainingLine}let r="";for(const e of this.replacement){if("identifier"===e.type){const t=this.parameters.indexOf(e.value);if(t>=0){r+=this.preprocessor.expandDefinitions(n[t]);continue}}r+=e.value}return{output:r,line:e}}consumeArgument(e){const t={value:"",remainingLine:e};let n=!1,i=0;for(;t.remainingLine.length>0&&(n||0!==i||","!==t.remainingLine[0]&&")"!==t.remainingLine[0]);){const e=t.remainingLine[0];let r=1;n&&"\\"===e&&'"'===t.remainingLine[0]?r=2:'"'===e?n=!n:"("!==e||n?")"!==e||n||i--:i++,t.value+=t.remainingLine.substring(0,r),t.remainingLine=t.remainingLine.substring(r)}return t}equals(e){return e.identifier===this.identifier&&e.replacement.length===this.replacement.length&&e.replacement.every(((e,t)=>e.value===this.replacement[t].value))&&e.parameters.length===this.parameters.length&&e.parameters.every(((e,t)=>e===this.parameters[t]))}}},5358:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.PreprocessorBase=t.PreProRegex=void 0,t.PreProRegex={identifier:/^[a-zA-Z_][a-zA-Z0-9_]*/,token:/^(?:"(?:\\"|[^\n"])*"|[^ \t\v\f\na-zA-Z_]+)/,whitespace:/^[ \t\v\f]+/,comments:/(?:\/\*[^]*?\*\/)|(?:\/\/.*?$)/gm,condition:/defined(?:[ \t]*\([ \t]*([a-zA-Z_][a-zA-Z0-9_]*)[ \t]*\)|[ \t]+([a-zA-Z_][a-zA-Z0-9_]*))|(d?[^d]*)/gm};t.PreprocessorBase=class PreprocessorBase{consumeAny(e){let n;if((n=this.consume(e,t.PreProRegex.identifier)).success)return n.type="identifier",n;if((n=this.consume(e,t.PreProRegex.token)).success)return n;if((n=this.consume(e,t.PreProRegex.whitespace)).success)return n;throw this.error("Malformed input? Line does not match defined regular expressions.\n`"+e+"`")}mustConsume(e,t,n=t.toString()){const i=this.consume(e,t);if(i.success)return i;throw this.error(`Expected to find ${n} but found \`${e}\` instead`)}consume(e,t){if("string"==typeof t)return e.startsWith(t)?{success:!0,value:t,remainingLine:e.substring(t.length)}:{success:!1,remainingLine:e};const n=e.match(t);return null===n?{success:!1,remainingLine:e}:{success:!0,value:n[0],remainingLine:e.substring(n[0].length)}}}},4551:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Definition=t.Preprocessor=void 0;var i=n(7527);Object.defineProperty(t,"Preprocessor",{enumerable:!0,get:function(){return i.Preprocessor}});var r=n(4221);Object.defineProperty(t,"Definition",{enumerable:!0,get:function(){return r.Definition}})},7527:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Preprocessor=void 0;const i=n(7601),r=n(4168),s=n(4221),a=n(5358);class Preprocessor extends a.PreprocessorBase{constructor(e,t=!0){super(),this.filename=e,this.definitions=new Map,this.userFiles=new Map,this.libraryFiles=t?new Map(i.LIBRARY_HEADERS):new Map,this.definitions.set("__FILE__",new s.Definition(this,"__FILE__",[{value:`"${e}"`}],[]))}process(e,t=this.filename){const n=(e=(e=e.replace(/\r\n/g,"\n")).replace(a.PreProRegex.comments," ")).replace(/\\\n/g,"").split("\n");let i="";for(;n.length>0;){const e=n.shift();if(e.startsWith("#")){let r;if((r=this.consume(e,"#define")).success)this._define(r.remainingLine);else if((r=this.consume(e,"#undef")).success)this._undef(r.remainingLine);else if((r=this.consume(e,"#include")).success)i+=this._include(r.remainingLine)+"\n";else if((r=this.consume(e,"#ifdef")).success)this._ifdef(r.remainingLine,!0,n);else if((r=this.consume(e,"#ifndef")).success)this._ifdef(r.remainingLine,!1,n);else if((r=this.consume(e,"#if")).success)i+=this._if(r.remainingLine,n);else if((r=this.consume(e,"#pragma")).success){if("once"===this.mustConsume(r.remainingLine,a.PreProRegex.whitespace,"whitespace").remainingLine.trim()){const e=`__pragma_once_${t}__`;if(this.definitions.has(e))return i;this.definitions.set(e,new s.Definition(this,e,[],[]))}}else if(e.trim().length>1)throw this.error("Unknown preprocessor directive")}else i+=this.expandDefinitions(e)+"\n"}return i}expandDefinitions(e){let t="";for(;e.length>0;){const n=this.consumeAny(e);if("identifier"===n?.type){const i=this.definitions.get(n.value);if(void 0!==i){const r=i.expand(n.remainingLine);t+=r.output,e=r.line;continue}}t+=n?.value,e=n.remainingLine}return t}error(e){return new class extends Error{constructor(){super(...arguments),this.name="PreprocessorError"}}(`In file '${this.filename}': ${e}`)}_include(e){if((e=this.mustConsume(e,a.PreProRegex.whitespace,"whitespace").remainingLine.trim()).startsWith('"')&&e.endsWith('"'))return this._includeUser(e.substring(1,e.length-1));if(e.startsWith("<")&&e.endsWith(">"))return this._includeLib(e.substring(1,e.length-1));if((e=this.expandDefinitions(e)).startsWith('"')&&e.endsWith('"'))return this._includeUser(e.substring(1,e.length-1));if(e.startsWith("<")&&e.endsWith(">"))return this._includeLib(e.substring(1,e.length-1));throw this.error("Invalid #include")}_includeLib(e){const t=this.libraryFiles.get(e);if(void 0===t)throw this.error("Unknown path `"+e+"`");return this.process(t,`<${e}>`)}_includeUser(e){const t=this.filename.replace(/[^/\\]*$/,e);let n=this.userFiles.get(t);return void 0===n&&(n=this.userFiles.get(e),void 0===n)?this._includeLib(e):this.process(n,e)}_define(e){e=this.mustConsume(e,a.PreProRegex.whitespace,"whitespace").remainingLine;const t=this.mustConsume(e,a.PreProRegex.identifier,"identifier"),n=[],i=[];if(t.remainingLine.trim().length>0){if("("===t.remainingLine[0]){for(e=this.mustConsume(t.remainingLine,"(").remainingLine;e.length>0;){e=this.consume(e,a.PreProRegex.whitespace).remainingLine;const t=this.mustConsume(e,a.PreProRegex.identifier,"identifier");if(i.push(t.value),0===(e=this.consume(t.remainingLine,a.PreProRegex.whitespace).remainingLine).length)throw this.error("Unexpected end of line");if(","!==e[0]){if(")"===e[0])break;throw this.error("Unexpected")}e=this.mustConsume(e,",").remainingLine}(e=this.mustConsume(e,")").remainingLine).length>0&&(e=this.mustConsume(e,a.PreProRegex.whitespace,"whitespace").remainingLine)}else e=this.mustConsume(t.remainingLine,a.PreProRegex.whitespace,"whitespace").remainingLine;for(;e.length>0;){const t=this.consumeAny(e);"identifier"===t.type&&i.includes(t.value)||(t.value=this.expandDefinitions(t.value)),n.push(t),e=t.remainingLine}}const r=new s.Definition(this,t.value,n,i),o=this.definitions.get(t.value);if(void 0!==o&&!r.equals(o))throw this.error("Duplicate defines must be the same");this.definitions.set(t.value,r)}_undef(e){e=this.mustConsume(e,a.PreProRegex.whitespace,"whitespace").remainingLine;const t=this.mustConsume(e,a.PreProRegex.identifier,"identifier");if(0!==t.remainingLine.trim().length)throw this.error("Unexpected extra characters in undef");this.definitions.delete(t.value)}_ifdef(e,t,n){e=this.mustConsume(e,a.PreProRegex.whitespace,"whitespace").remainingLine;const i=this.mustConsume(e,a.PreProRegex.identifier,"identifier");n.unshift(`#if ${t?"":"!"} defined ${i.value}`)}_if(e,t){const n=this.mustConsume(e,a.PreProRegex.whitespace,"whitespace").remainingLine;let i=this._condition(n),r=i,s=1,o=!1;const c=[];for(let e=0;e<t.length;e++){const n=t[e].trimEnd();if(n.startsWith("#if"))s++;else if("#endif"===n){if(s--,0===s)return t.splice(0,e+1),this.process(c.join("\n"))}else{if("#else"===n&&1===s){if(o)throw this.error("more than one #else statement");o=!0,i=!r,r=!0;continue}if(n.startsWith("#elif")&&1===s){if(r)i=!1;else{const n=this.mustConsume(t[e].substring(5),a.PreProRegex.whitespace,"whitespace").remainingLine;i=this._condition(n),r||(r=i)}continue}}i&&c.push(t[e])}throw this.error("no matching #endif found")}_condition(e){let t="";for(const n of e.matchAll(a.PreProRegex.condition)){if(4!==n.length)throw this.error("invalid regex result when processing #if condition");const e=n[1]??n[2];t+=e?this.definitions.has(e)?" 1L ":" 0L ":n[3]}t=this.expandDefinitions(t);try{return 0n!==r.ppEvaluate(t,this)}catch(t){throw console.debug(t),this.error("Invalid condition `"+e+"`")}}}t.Preprocessor=Preprocessor},2771:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CFuncDefinition=t.CFuncImport=t.CFuncDeclaration=t.CArgument=t.CVarDefinition=t.CVarDeclaration=void 0;const i=n(7894);t.CVarDeclaration=class CVarDeclaration{constructor(e,t,n,i,r){this.node=e,this.name=t,this.type=n,this.storage=i,this.linkage=r,this.declType="variable",this._addressUsed=!1}set addressUsed(e){var t;this._definition?(t=this._definition).addressUsed||(t.addressUsed=e):this._addressUsed||(this._addressUsed=e)}get addressUsed(){return this._definition?this._definition.addressUsed:this._addressUsed}set definition(e){if(void 0===e)throw new Error("Cannot set definition to undefined");e.addressUsed||(e.addressUsed=this._addressUsed),this._definition=e}get definition(){return this._definition}};t.CVarDefinition=class CVarDefinition{constructor(e,t,n,i,r){this.node=e,this.name=t,this.type=n,this.storage=i,this.linkage=r,this.declType="variable",this.addressUsed=!1,this.dependencies=new Map}};t.CArgument=class CArgument{constructor(e,t,n,i){this.node=e,this.name=t,this.type=n,this.index=i,this.declType="variable",this.storage="argument",this.linkage="none",this.addressUsed=!1}};t.CFuncDeclaration=class CFuncDeclaration{constructor(e,t,n,i,r=!1){this.node=e,this.name=t,this.type=n,this.linkage=i,this.fnImport=r,this.declType="function"}};t.CFuncImport=class CFuncImport{constructor(e){this.declaration=e,this.declType="import",this.node=e.node}getFunction(){return this.declaration}};t.CFuncDefinition=class CFuncDefinition{constructor(e,t,n,r,s){this.node=e,this.name=t,this.type=n,this.linkage=r,this.translationUnit=s,this.declType="function",this.dependencies=new Map,this.body=new i.CCompoundStatement(e.body,this)}get scope(){return this.translationUnit}equals(e){return e===this}getFunction(){return this}}},5923:function(e,t,n){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,t,n,i){void 0===i&&(i=n),Object.defineProperty(e,i,{enumerable:!0,get:function(){return t[n]}})}:function(e,t,n,i){void 0===i&&(i=n),e[i]=t[n]}),r=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),s=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&i(t,e,n);return r(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.CInitializer=t.CComma=t.CAssignment=t.CConditional=t.CLogicalAndOr=t.CBitwiseAndOr=t.CEquality=t.CRelational=t.CShift=t.CAddSub=t.CMod=t.CMulDiv=t.CCast=t.CLogicalNot=t.CBitwiseNot=t.CUnaryPlusMinus=t.CDereference=t.CAddressOf=t.CSizeof=t.CIncrDecr=t.CMemberAccess=t.CFunctionCall=t.CStringLiteral=t.CArrayPointer=t.CIdentifier=t.CConstant=void 0;const a=s(n(6718)),o=n(4902);class CConstant{constructor(e,t,n){this.node=e,this.type=t,this.value=n,this.lvalue=!1}changeType(e){if(this.type.equals(e))return this;let t;if(e.equals(o.CArithmetic.BOOL))t=0==this.value?0:1;else if("float"===e.type)t=Number(this.value);else{if(this.value>e.maxValue||this.value<e.minValue)throw new a.ExpressionTypeError(this.node,"value which fits in "+e.name,this.value.toString());t=BigInt(this.value)}return new CConstant(this.node,e,t)}*identifiers(){}}t.CConstant=CConstant;class CIdentifier{constructor(e,t){this.node=e,this.value=t,this.lvalue=!(t.type instanceof o.CFuncType)}get type(){return this.value.type}*identifiers(){yield this}}t.CIdentifier=CIdentifier;class CArrayPointer{constructor(e,t){if(this.node=e,this.arrayIdentifier=t,this.lvalue=!1,!(t.type instanceof o.CArray))throw new a.ExpressionTypeError(this.node,"array");this.type=new o.CPointer(this.node,t.type.type)}*identifiers(){this.arrayIdentifier instanceof CIdentifier&&(yield this.arrayIdentifier)}}t.CArrayPointer=CArrayPointer;t.CStringLiteral=class CStringLiteral{constructor(e,t){if(this.node=e,this.value=t,this.lvalue=!1,0===t.length||0n!==t[t.length-1])throw new a.ExpressionTypeError(e,"null terminated char[]","char[]");this.type=new o.CArray(e,o.CArithmetic.U8,t.length)}*identifiers(){}};t.CFunctionCall=class CFunctionCall{constructor(e,t,n){if(this.node=e,this.body=t,this.args=n,this.lvalue=!1,this.fnType=a.asFunction(t.node,t.type),this.type=this.fnType.returnType,this.fnType.variadic&&this.fnType.parameterTypes.length>n.length)throw new a.ExpressionTypeError(e,`at least ${this.fnType.parameterTypes.length} argument(s) to variadic function`);if(!this.fnType.variadic&&this.fnType.parameterTypes.length!==n.length)throw new a.ExpressionTypeError(e,this.fnType.parameterTypes.length+" argument(s)",""+n.length);for(let e=0;e<this.fnType.parameterTypes.length;e++)CAssignment.checkAssignmentValid(n[e].node,this.fnType.parameterTypes[e],n[e])}*identifiers(){yield*this.body.identifiers();for(const e of this.args)yield*e.identifiers()}};t.CMemberAccess=class CMemberAccess{constructor(e,t,n){this.node=e,this.body=t,this.member=n;const i=a.asPointer(t.node,t.type);this.structUnion=a.asStructOrUnion(t.node,i.type);const r=this.structUnion.memberType(n);this.type=r instanceof o.CArray?new o.CPointer(r.node,r.type):r,this.lvalue=!(this.type instanceof o.CArray)}*identifiers(){yield*this.body.identifiers()}};t.CIncrDecr=class CIncrDecr{constructor(e,t,n,i){this.node=e,this.body=t,this.op=n,this.pos=i,this.lvalue=!1,a.checkLvalue(t,!0),this.type=a.asNonFunctionPointer(t.node,a.asArithmeticOrPointer(t.node,t.type)),this.type instanceof o.CPointer&&o.checkTypeComplete(this.type.type)}*identifiers(){yield*this.body.identifiers()}};t.CSizeof=class CSizeof{constructor(e,t){if(this.node=e,this.body=t,this.lvalue=!1,this.type=o.CSizeT,t.incomplete||0===t.bytes||t instanceof o.CFuncType)throw new a.ExpressionTypeError(e,"Complete non-function type",t.typeName)}*identifiers(){}};t.CAddressOf=class CAddressOf{constructor(e,t){this.node=e,this.lvalue=!1,t instanceof CArrayPointer&&(t=t.arrayIdentifier),t instanceof CIdentifier&&t.type instanceof o.CFuncType||a.checkLvalue(t,!0),this.type=new o.CPointer(e,t.type),t instanceof CIdentifier&&(t.value.addressUsed=!0),this.body=t}*identifiers(){yield*this.body.identifiers()}};t.CDereference=class CDereference{constructor(e,t){this.node=e,this.body=t,this.lvalue=!0,this.type=a.asPointer(e,t.type).type}*identifiers(){yield*this.body.identifiers()}};t.CUnaryPlusMinus=class CUnaryPlusMinus{constructor(e,t,n){this.node=e,this.body=t,this.op=n,this.lvalue=!1,this.bodyType=a.asArithmetic(t.node,t.type),this.type=o.integerPromotion(this.bodyType)}*identifiers(){yield*this.body.identifiers()}};t.CBitwiseNot=class CBitwiseNot{constructor(e,t){this.node=e,this.body=t,this.lvalue=!1,this.bodyType=a.asInteger(t.node,t.type),this.type=this.bodyType.bytes<o.CArithmetic.S32.bytes?o.CArithmetic.S32:this.bodyType}*identifiers(){yield*this.body.identifiers()}};t.CLogicalNot=class CLogicalNot{constructor(e,t){this.node=e,this.body=t,this.lvalue=!1,this.type=o.CArithmetic.S32,a.asArithmeticOrPointer(t.node,t.type)}*identifiers(){yield*this.body.identifiers()}};t.CCast=class CCast{constructor(e,t,n){this.node=e,this.type=t,this.body=n,this.lvalue=!1}*identifiers(){yield*this.body.identifiers()}};class CMulDiv{constructor(e,t,n,i){this.node=e,this.lhs=t,this.rhs=n,this.op=i,this.lvalue=!1,this.type=o.usualArithmeticConversion(a.asArithmetic(t.node,t.type),a.asArithmetic(n.node,n.type))}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}t.CMulDiv=CMulDiv;class CMod{constructor(e,t,n){this.node=e,this.lhs=t,this.rhs=n,this.lvalue=!1,this.type=o.usualArithmeticConversion(a.asInteger(t.node,t.type),a.asInteger(n.node,n.type))}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}t.CMod=CMod;class CAddSub{constructor(e,t,n,i){if(this.node=e,this.lhs=t,this.rhs=n,this.op=i,this.lvalue=!1,t.type instanceof o.CPointer&&n.type instanceof o.CPointer){if(!t.type.equals(n.type))throw new a.ExpressionTypeError(e,"both pointers to have the same type");o.checkTypeComplete(t.type.type),this.type=a.asNonFunctionPointer(t.node,t.type),a.asNonFunctionPointer(n.node,n.type)}else t.type instanceof o.CPointer?(a.asInteger(n.node,n.type),o.checkTypeComplete(t.type.type),this.type=a.asNonFunctionPointer(t.node,t.type)):n.type instanceof o.CPointer?(a.asInteger(t.node,t.type),o.checkTypeComplete(n.type.type),this.type=a.asNonFunctionPointer(n.node,n.type)):this.type=o.usualArithmeticConversion(a.asArithmetic(t.node,t.type),a.asArithmetic(n.node,n.type))}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}t.CAddSub=CAddSub;class CShift{constructor(e,t,n,i){this.node=e,this.lhs=t,this.rhs=n,this.dir=i,this.lvalue=!1,this.type=o.integerPromotion(a.asInteger(t.node,t.type)),a.asInteger(n.node,n.type)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}t.CShift=CShift;t.CRelational=class CRelational{constructor(e,t,n,i){this.node=e,this.lhs=t,this.rhs=n,this.op=i,this.lvalue=!1,this.type=o.CArithmetic.BOOL,a.asArithmeticOrPointer(t.node,t.type),a.asArithmeticOrPointer(n.node,n.type),this.commonType=o.usualArithmeticConversion(t.type instanceof o.CArithmetic?t.type:o.CSizeT,n.type instanceof o.CArithmetic?n.type:o.CSizeT)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}};t.CEquality=class CEquality{constructor(e,t,n,i){this.node=e,this.lhs=t,this.rhs=n,this.op=i,this.lvalue=!1,this.type=o.CArithmetic.BOOL,a.asArithmeticOrPointer(t.node,t.type),a.asArithmeticOrPointer(n.node,n.type),this.commonType=o.usualArithmeticConversion(t.type instanceof o.CArithmetic?t.type:o.CSizeT,n.type instanceof o.CArithmetic?n.type:o.CSizeT)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}};class CBitwiseAndOr{constructor(e,t,n,i){this.node=e,this.lhs=t,this.rhs=n,this.op=i,this.lvalue=!1,this.type=o.usualArithmeticConversion(a.asInteger(t.node,t.type),a.asInteger(n.node,n.type))}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}}t.CBitwiseAndOr=CBitwiseAndOr;t.CLogicalAndOr=class CLogicalAndOr{constructor(e,t,n,i){this.node=e,this.lhs=t,this.rhs=n,this.op=i,this.lvalue=!1,this.type=o.CArithmetic.BOOL,a.asArithmeticOrPointer(t.node,t.type),a.asArithmeticOrPointer(n.node,n.type)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}};t.CConditional=class CConditional{constructor(e,t,n,i){if(this.node=e,this.test=t,this.trueValue=n,this.falseValue=i,this.lvalue=!1,a.asArithmeticOrPointer(t.node,t.type),n.type instanceof o.CArithmetic&&i.type instanceof o.CArithmetic)this.type=o.usualArithmeticConversion(n.type,i.type);else{if(!n.type.equals(i.type)){if(n.type instanceof o.CPointer&&i.type instanceof o.CPointer){if(n.type.type instanceof o.CVoid)return void(this.type=i.type);if(i.type.type instanceof o.CVoid)return void(this.type=n.type)}else if(n.type instanceof o.CPointer||i.type instanceof o.CPointer){const e=n.type instanceof o.CPointer?i:n;if(e instanceof CConstant&&0==e.value)return void(this.type=n.type instanceof o.CPointer?n.type:i.type)}throw new a.ExpressionTypeError(e,"both conditional branches to have the same type","different types")}this.type=n.type}}*identifiers(){yield*this.test.identifiers(),yield*this.trueValue.identifiers(),yield*this.falseValue.identifiers()}};class CAssignment{constructor(e,t,n,i,r=!1){if(this.node=e,this.lhs=t,this.rhs=n,this.assignmentType=i,this.initialAssignment=r,this.lvalue=!1,a.checkLvalue(t,!0),t.type instanceof o.CArray&&!r||t.type instanceof o.CFuncType||t.type.incomplete)throw new a.ExpressionTypeError(t.node,"assignable type");if("const"===o.getQualifier(t.type)&&!r)throw new a.ExpressionTypeError(t.node,"non-const location");if((t.type instanceof o.CStruct||t.type instanceof o.CUnion)&&t.type.hasConstMember()&&!r)throw new a.ExpressionTypeError(t.node,"structure without a const member");if(this.type=t.type,t.type instanceof o.CArray&&n instanceof CArrayPointer&&(this.rhs=n=n.arrayIdentifier),i){if(n instanceof CInitializer)throw new a.ExpressionTypeError(e,"simple assignments with structure initializers");let r=n.type;switch(i){case"mul":r=new CMulDiv(e,t,n,"*").type;break;case"div":r=new CMulDiv(e,t,n,"/").type;break;case"mod":r=new CMod(e,t,n).type;break;case"add":r=new CAddSub(e,t,n,"+").type;break;case"sub":r=new CAddSub(e,t,n,"-").type;break;case"leftShift":r=new CShift(e,t,n,"left").type;break;case"rightShift":r=new CShift(e,t,n,"right").type;break;case"bitwiseAnd":r=new CBitwiseAndOr(e,t,n,"and").type;break;case"bitwiseOr":r=new CBitwiseAndOr(e,t,n,"or").type;break;case"bitwiseXor":r=new CBitwiseAndOr(e,t,n,"xor").type;break;default:throw new a.ExpressionTypeError(e,"valid assignment type")}CAssignment._checkAssignmentTypeValid(e,t.type,r)}else CAssignment.checkAssignmentValid(e,t.type,n)}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}static checkAssignmentValid(e,t,n){t instanceof o.CPointer&&n instanceof CConstant&&0n===n.value||this._checkAssignmentTypeValid(e,t,n.type)}static _checkAssignmentTypeValid(e,t,n){if(!(t.equals(n)||t instanceof o.CArithmetic&&n instanceof o.CArithmetic)){if(t instanceof o.CPointer&&n instanceof o.CPointer){if(t.type instanceof o.CVoid||n.type instanceof o.CVoid)return;if(t.type.equals(n.type)&&"const"!==n.qualifier)return}if(!(t instanceof o.CPointer&&n instanceof o.CFuncType&&t.type.equals(n)))throw new a.ExpressionTypeError(e,t.typeName,n.typeName)}}}t.CAssignment=CAssignment;t.CComma=class CComma{constructor(e,t,n){this.node=e,this.lhs=t,this.rhs=n,this.lvalue=!1,this.type=n.type}*identifiers(){yield*this.lhs.identifiers(),yield*this.rhs.identifiers()}};class CInitializer{constructor(e,t,n){this.node=e,this.body=t,this._memberTypes=[],this._type=n??new o.CArray(void 0,new o.CPointer(void 0,new o.CVoid),t.length)}get memberTypes(){return this._memberTypes}get type(){return this._type}set type(e){const t=()=>{throw new a.ExpressionTypeError(this.node,"initializer to match type")};if(this._memberTypes=[],e instanceof o.CArray){this.body.length>(e.length??1/0)&&t();for(let t=0;t<this.body.length;t++)this.body[t]=CInitializer.typeCheck(e.type,this.body[t]),this._memberTypes.push(e.type)}else if(e instanceof o.CStruct){this.body.length>e.members.length&&t();for(let t=0;t<this.body.length;t++)this.body[t]=CInitializer.typeCheck(e.members[t].type,this.body[t]),this._memberTypes.push(e.members[t].type)}else e instanceof o.CUnion?(this.body.length>1&&t(),1===this.body.length&&(this.body[0]=CInitializer.typeCheck(e.members[0].type,this.body[0]),this._memberTypes.push(e.members[0].type))):t();this._type=e}*identifiers(){for(const e of this.body)yield*e.identifiers()}static typeCheck(e,t){return t instanceof CInitializer?t.type=e:(CAssignment.checkAssignmentValid(t.node,e,t),t instanceof CConstant&&e instanceof o.CArithmetic&&t.type!==e&&(t=t.changeType(e))),t}}t.CInitializer=CInitializer},7133:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Scope=void 0;const i=n(7745),r=n(2771);t.Scope=class Scope{constructor(e,t,n=t?.func){this.node=e,this.parent=t,this.func=n,this.tags=new Map,this.identifiers=new Map,this.typedefs=new Map}_getTag(e){return this.tags.get(e)??this.parent?._getTag(e)}lookupTag(e,t,n){const i=this._getTag(e);if(t&&i&&t.prototype!==Object.getPrototypeOf(i))throw new ScopeError("`"+e+"` was already declared as a "+i.typeName,i.node,n);return i}addTag(e){if(!e.name)throw new Error("Cannot add nameless compound type to scope");if(this._getTag(e.name))throw new ScopeError("Compound type `"+e.name+"` is already defined!",e.node);this.tags.set(e.name,e)}_getId(e){return this.identifiers.get(e)??this.parent?._getId(e)}lookupIdentifier(e,t){const n=this._getId(e);if(!n)throw new ScopeError("Failed to find `"+e+"`",t);return n}addIdentifier(e){const t=this.identifiers.get(e.name);if(t)if(t.type.equals(e.type)&&t instanceof r.CFuncDeclaration&&e instanceof r.CFuncDefinition)"external"!==t.linkage&&"external"===e.linkage&&(e.linkage=t.linkage),t.definition=e;else{if(t.type.equals(e.type)&&e instanceof r.CFuncDeclaration)return void(t instanceof r.CFuncDeclaration&&(t.fnImport||(t.fnImport=e.fnImport)));if(!(t.type.equals(e.type)&&t instanceof r.CVarDeclaration&&e instanceof r.CVarDefinition)){if(t.type.equals(e.type)&&e instanceof r.CVarDeclaration){if("external"!==t.linkage&&t.linkage!==e.linkage)throw new ScopeError("Variable `"+e.name+"` is already defined with "+t.linkage+" linkage",t.node,e.node);return}throw new ScopeError("Identifier `"+e.name+"` is already defined in this scope!",t.node,e.node)}if("external"!==t.linkage&&t.linkage!==e.linkage)throw new ScopeError("Variable `"+e.name+"` is already defined with "+t.linkage+" linkage",t.node,e.node);t.definition=e}this.identifiers.set(e.name,e)}get declarations(){return[...this.identifiers.values()]}_getTypedef(e){return this.typedefs.get(e)??this.parent?._getTypedef(e)}lookupTypedef(e,t){const n=this._getTypedef(e);if(void 0===n)throw new ScopeError("typedef `"+e+"` not found in scope",t);return n}addTypedef(e,t,n){const i=this._getTypedef(e);if(i){if(i.equals(t))return;throw new ScopeError("typedef already defined with a different type",n)}this.typedefs.set(e,t)}};class ScopeError extends i.CError{constructor(){super(...arguments),this.name="ScopeError"}}},7894:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CLabelledStatement=t.CReturn=t.CBreak=t.CContinue=t.CSwitch=t.CGoto=t.CDoLoop=t.CWhileLoop=t.CForLoop=t.CIf=t.CNop=t.CExpressionStatement=t.CCompoundStatement=void 0;const i=n(2771),r=n(5923),s=n(7133),a=n(6718);t.CCompoundStatement=class CCompoundStatement{constructor(e,t){this.node=e,this.parent=t,this.statements=[],this.scope=new s.Scope(e,t.scope,t instanceof i.CFuncDefinition?t:void 0)}};t.CExpressionStatement=class CExpressionStatement{constructor(e,t,n){this.node=e,this.expression=t,this.parent=n}get scope(){return this.parent.scope}};t.CNop=class CNop{constructor(e,t){this.node=e,this.parent=t}get scope(){return this.parent.scope}};t.CIf=class CIf{constructor(e,t,n){this.node=e,this.test=t,this.parent=n,a.asArithmeticOrPointer(t.node,t.type)}get scope(){return this.parent.scope}};t.CForLoop=class CForLoop{constructor(e,t){this.node=e,this.parent=t,this.scope=new s.Scope(e,t.scope)}};t.CWhileLoop=class CWhileLoop{constructor(e,t,n){this.node=e,this.test=t,this.parent=n,a.asArithmeticOrPointer(t.node,t.type)}get scope(){return this.parent.scope}};t.CDoLoop=class CDoLoop{constructor(e,t,n){this.node=e,this.test=t,this.parent=n,a.asArithmeticOrPointer(t.node,t.type)}get scope(){return this.parent.scope}};t.CGoto=class CGoto{constructor(e,t,n){this.node=e,this.target=t,this.parent=n}get scope(){return this.parent.scope}};t.CSwitch=class CSwitch{constructor(e,t,n){this.node=e,this.expression=t,this.parent=n,this.children=[]}get scope(){return this.parent.scope}};t.CContinue=class CContinue{constructor(e,t,n){this.node=e,this.loop=t,this.parent=n}get scope(){return this.parent.scope}};t.CBreak=class CBreak{constructor(e,t,n){this.node=e,this.target=t,this.parent=n}get scope(){return this.parent.scope}};t.CReturn=class CReturn{constructor(e,t,n,i){if(this.node=e,this.func=t,this.value=n,this.parent=i,void 0===n){if(t.type.returnType.bytes>0)throw new a.ExpressionTypeError(e,"`return [expression]`","`return;`")}else t.type.returnType.equals(n.type)||r.CAssignment.checkAssignmentValid(e,t.type.returnType,n)}get scope(){return this.parent.scope}};t.CLabelledStatement=class CLabelledStatement{constructor(e,t){this.node=e,this.label=t}}},366:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.normalizeValueType=t.constInteger=t.constExpression=void 0;const i=n(2771),r=n(5923),s=n(6718),a=n(4902);function o(e,t){if(e instanceof r.CConstant)return{value:e.value,type:e.type};if(e instanceof r.CIdentifier&&e.value instanceof i.CVarDefinition&&"const"===e.value.type.qualifier&&e.value.staticValue instanceof r.CConstant)return o(e.value.staticValue,t);if(e instanceof r.CSizeof)return l({value:e.body.bytes,type:a.CSizeT});if(e instanceof r.CUnaryPlusMinus){const n=o(e.body,t);return"+"===e.op?n:{value:-n.value,type:e.type}}if(e instanceof r.CBitwiseNot){const n=c(e.body,t);return l({value:~n.value,type:n.type})}if(e instanceof r.CLogicalNot){return{value:0==o(e.body,t).value?1n:0n,type:a.CArithmetic.S32}}if(e instanceof r.CCast&&(e.type instanceof a.CArithmetic||e.type instanceof a.CPointer)){return l({value:o(e.body,t).value,type:e.type})}if(e instanceof r.CMulDiv){const n=o(e.lhs,t),i=o(e.rhs,t);return"*"===e.op?"float"===e.type.type?{value:Number(n.value)*Number(i.value),type:e.type}:l({value:BigInt(n.value)*BigInt(i.value),type:e.type}):"float"===e.type.type?{value:Number(n.value)/Number(i.value),type:e.type}:l({value:BigInt(n.value)/BigInt(i.value),type:e.type})}if(e instanceof r.CMod){const n=c(e.lhs,t),i=c(e.rhs,t);return l({value:n.value%i.value,type:e.type})}if(e instanceof r.CAddSub&&e.type instanceof a.CArithmetic){const n=o(e.lhs,t),i=o(e.rhs,t);return"+"===e.op?"float"===e.type.type?{value:Number(n.value)+Number(i.value),type:e.type}:l({value:BigInt(n.value)+BigInt(i.value),type:e.type}):"float"===e.type.type?{value:Number(n.value)-Number(i.value),type:e.type}:l({value:BigInt(n.value)-BigInt(i.value),type:e.type})}if(e instanceof r.CShift){const n=c(e.lhs,t),i=c(e.rhs,t);return"left"===e.dir?l({value:n.value<<i.value,type:e.type}):l({value:n.value>>i.value,type:e.type})}if(e instanceof r.CRelational){const n=o(e.lhs,t),i=o(e.rhs,t);return"LT"===e.op?{value:n.value<i.value?1n:0n,type:a.CArithmetic.S32}:"GT"===e.op?{value:n.value>i.value?1n:0n,type:a.CArithmetic.S32}:"LEq"===e.op?{value:n.value<=i.value?1n:0n,type:a.CArithmetic.S32}:{value:n.value>=i.value?1n:0n,type:a.CArithmetic.S32}}if(e instanceof r.CEquality){const n=o(e.lhs,t),i=o(e.rhs,t);return"=="===e.op?{value:n.value==i.value?1n:0n,type:a.CArithmetic.S32}:{value:n.value!=i.value?1n:0n,type:a.CArithmetic.S32}}if(e instanceof r.CBitwiseAndOr){const n=c(e.lhs,t),i=c(e.rhs,t);return"and"===e.op?l({value:n.value&i.value,type:e.type}):"or"===e.op?l({value:n.value|i.value,type:e.type}):l({value:n.value^i.value,type:e.type})}if(e instanceof r.CLogicalAndOr){const n=o(e.lhs,t);return"and"===e.op?0!=n.value&&0!=o(e.rhs,t).value?{value:1n,type:a.CArithmetic.S32}:{value:0n,type:a.CArithmetic.S32}:0!=n.value||0!=o(e.rhs,t).value?{value:1n,type:a.CArithmetic.S32}:{value:0n,type:a.CArithmetic.S32}}if(e instanceof r.CConditional&&(e.type instanceof a.CArithmetic||e.type instanceof a.CPointer)){let n;return n=0!=o(e.test,t).value?o(e.trueValue,t):o(e.falseValue,t),l({value:n.value,type:e.type})}if(void 0!==t)return t(e);throw new s.ExpressionTypeError(e.node,"constant expression")}function c(e,t){const n=o(e,t);if(n.type instanceof a.CArithmetic&&"float"!==n.type.type)return{value:BigInt(n.value),type:n.type};throw new s.ExpressionTypeError(e.node,"expected constant integer expression")}function l(e){if(e.type instanceof a.CArithmetic){if(a.CArithmetic.BOOL.equals(e.type))return{value:0==e.value?0n:1n,type:a.CArithmetic.BOOL};if("float"===e.type.type)return{value:"number"==typeof e.value?e.value:Number(e.value),type:e.type};{let t;t="number"==typeof e.value?isNaN(e.value)?0n:e.value>e.type.maxValue?BigInt(e.type.maxValue):e.value<e.type.minValue?BigInt(e.type.minValue):BigInt(e.value):e.value;const n=2n**BigInt(8*e.type.bytes)-1n;if("unsigned"===e.type.type)t&=n;else{const i=BigInt(e.type.minValue);t=(t-i&n)+i}return{value:t,type:e.type}}}return{value:l({value:e.value,type:a.CArithmetic.U32}).value,type:e.type}}t.constExpression=o,t.constInteger=c,t.normalizeValueType=l},5963:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ptConstant=t.evalIntegerConstant=t.ptExpression=void 0;const i=n(1225),r=n(5923),s=n(4902),a=n(366),o=n(615);function c(e,t){if(e instanceof i.pt.ConstantExpression)return c(e.expr,t);if(e instanceof i.pt.Constant)return l(e);if(e instanceof i.pt.Identifier){const n=new r.CIdentifier(e,t.lookupIdentifier(e.name,e));return t.func&&t.func.dependencies.set(n.value,!0),n.type instanceof s.CArray?new r.CArrayPointer(e,n):n}if(e instanceof i.pt.StringLiteral){const t=[],n=/[^\\\n"]|\\(?:[^x0-7\n]|x[0-9a-fA-F]{1,2}|[0-7]{1,3})/y;for(;n.lastIndex<e.value.length;){const r=n.exec(e.value);if(!r||0===n.lastIndex)throw new i.ParseTreeValidationError(e,"Invalid string literal");t.push(BigInt(h(r[0],e).codePointAt(0)??0))}return t.push(0n),new r.CArrayPointer(e,new r.CStringLiteral(e,t))}if(e instanceof i.pt.UnaryExpression)return function(e,t){const n=c(e.body,t);if("prefixIncrement"===e.type)return new r.CIncrDecr(e,n,"++","pre");if("prefixDecrement"===e.type)return new r.CIncrDecr(e,n,"--","pre");if("postfixIncrement"===e.type)return new r.CIncrDecr(e,n,"++","post");if("postfixDecrement"===e.type)return new r.CIncrDecr(e,n,"--","post");if("addressOf"===e.type)return new r.CAddressOf(e,n);if("dereference"===e.type)return new r.CDereference(e,n);if("unaryPlus"===e.type)return new r.CUnaryPlusMinus(e,n,"+");if("unaryMinus"===e.type)return new r.CUnaryPlusMinus(e,n,"-");if("bitwiseNot"===e.type)return new r.CBitwiseNot(e,n);if("logicalNot"===e.type)return new r.CLogicalNot(e,n);throw new i.ParseTreeValidationError(e,"Invalid unary expression")}(e,t);if(e instanceof i.pt.BinaryExpression)return function(e,t){const n=c(e.lhs,t),s=c(e.rhs,t);if("mul"===e.type)return new r.CMulDiv(e,n,s,"*");if("div"===e.type)return new r.CMulDiv(e,n,s,"/");if("mod"===e.type)return new r.CMod(e,n,s);if("add"===e.type)return new r.CAddSub(e,n,s,"+");if("sub"===e.type)return new r.CAddSub(e,n,s,"-");if("bitwiseShiftLeft"===e.type)return new r.CShift(e,n,s,"left");if("bitwiseShiftRight"===e.type)return new r.CShift(e,n,s,"right");if("relationalLT"===e.type)return new r.CRelational(e,n,s,"LT");if("relationalGT"===e.type)return new r.CRelational(e,n,s,"GT");if("relationalLEq"===e.type)return new r.CRelational(e,n,s,"LEq");if("relationalGEq"===e.type)return new r.CRelational(e,n,s,"GEq");if("relationalEq"===e.type)return new r.CEquality(e,n,s,"==");if("relationalNEq"===e.type)return new r.CEquality(e,n,s,"!=");if("bitwiseAnd"===e.type)return new r.CBitwiseAndOr(e,n,s,"and");if("bitwiseXor"===e.type)return new r.CBitwiseAndOr(e,n,s,"xor");if("bitwiseOr"===e.type)return new r.CBitwiseAndOr(e,n,s,"or");if("logicalAnd"===e.type)return new r.CLogicalAndOr(e,n,s,"and");if("logicalOr"===e.type)return new r.CLogicalAndOr(e,n,s,"or");if("comma"===e.type)return new r.CComma(e,n,s);if("arraySubscript"===e.type)return new r.CDereference(e,new r.CAddSub(e,c(e.lhs,t),c(e.rhs,t),"+"));throw new i.ParseTreeValidationError(e,"Invalid binary expression")}(e,t);if(e instanceof i.pt.SizeofExpression){if(e.body instanceof i.pt.Expression){let n=c(e.body,t);return n instanceof r.CArrayPointer&&(n=n.arrayIdentifier),new r.CSizeof(e,n.type)}return new r.CSizeof(e,o.getType(e.body,t))}if(e instanceof i.pt.CastExpression)return new r.CCast(e,o.getType(e.targetType,t),c(e.body,t));if(e instanceof i.pt.FunctionCallExpression)return new r.CFunctionCall(e,c(e.fn,t),(e.args??[]).map((e=>c(e,t))));if(e instanceof i.pt.MemberAccessExpression){let n=c(e.lhs,t);return e.pointer||(n=new r.CAddressOf(e,n)),new r.CMemberAccess(e,n,e.rhs)}if(e instanceof i.pt.ConditionalExpression)return new r.CConditional(e,c(e.condition,t),c(e.trueValue,t),c(e.falseValue,t));if(e instanceof i.pt.AssignmentExpression)return new r.CAssignment(e,c(e.lhs,t),c(e.rhs,t),e.assignType);throw new i.ParseTreeValidationError(e,"Invalid expression")}function l(e){let t,n=e.value;if("int"===e.valueType||"oct"===e.valueType||"hex"===e.valueType){let t,a,o=!1,c=!1;if(n=n.toLowerCase(),n.endsWith("u")&&(n=n.slice(0,-1),o=!0),n.endsWith("l")&&(n=n.slice(0,-1),c=!0,n.endsWith("l")&&(n=n.slice(0,-1))),!o&&n.endsWith("u")&&(n=n.slice(0,-1),o=!0),"oct"!==e.valueType)t=BigInt(n);else{t=0n;for(let e=0;e<n.length-1;e++)t+=BigInt(n[n.length-1-e])*8n**BigInt(e)}a="int"!==e.valueType||o||c?"int"===e.valueType||o||c?o&&c?[s.CArithmetic.U64]:c?[s.CArithmetic.S64,s.CArithmetic.U64]:[s.CArithmetic.U32,s.CArithmetic.U64]:[s.CArithmetic.S32,s.CArithmetic.U32,s.CArithmetic.S64,s.CArithmetic.U64]:[s.CArithmetic.S32,s.CArithmetic.S64,s.CArithmetic.U64];for(const n of a)if(t>=n.minValue&&t<=n.maxValue)return new r.CConstant(e,n,t);throw new i.ParseTreeValidationError(e,"Integer constant too large for its type")}if("float"===e.valueType)return n.endsWith("f")?(n=n.slice(0,-1),t=s.CArithmetic.Fp32):t=s.CArithmetic.Fp64,new r.CConstant(e,t,parseFloat(n));if("char"===e.valueType)return n=h(n,e),new r.CConstant(e,s.CArithmetic.U8,BigInt(n.codePointAt(0)));throw new i.ParseTreeValidationError(e,"Invalid constant type?")}function h(e,t){if(e.startsWith("\\")){if("\\n"===e)return"\n";if("\\t"===e)return"\t";if("\\v"===e)return"\v";if("\\b"===e)return"\b";if("\\r"===e)return"\r";if("\\f"===e)return"\f";if("\\a"===e)return"";if("\\\\"===e)return"\\";if("\\?"===e)return"?";if("\\'"===e)return"'";if('\\"'===e)return'"';let n;if(n=e.startsWith("\\x")?parseInt(e.slice(2),16):parseInt(e.slice(1),8),!isNaN(n)&&n>=0&&n<=255)return String.fromCharCode(n);throw new i.ParseTreeValidationError(t,"Invalid character escape")}const n=e.codePointAt(0);if(1!==e.length||void 0===n||n>255)throw new i.ParseTreeValidationError(t,"Invalid character");return e}t.ptExpression=c,t.evalIntegerConstant=function(e,t){const n=c(e.expr,t);return a.constInteger(n)},t.ptConstant=l},615:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getDeclaratorName=t.getDeclaratorType=t.getType=void 0;const i=n(2771),r=n(5923),s=n(4902),a=n(1225),o=n(5963);function c(e,t){let n=function(e,t){const n=e.specifierList,f=1===n.length?n[0]:void 0;if(f instanceof a.pt.StructUnionSpecifier){const e="struct"===f.structure?s.CStruct:s.CUnion;let n=new e(f,f.id);if(f.id){const i=t.lookupTag(f.id,e,f);i?n=i:t.addTag(n)}if(!f.declarations)return n;const i=[];for(const e of f.declarations){const n=c(e,t);for(const r of e.list){const o=l(n,r,t),c=h(r);if(o.incomplete||0===o.bytes||o instanceof s.CFuncType)throw new a.ParseTreeValidationError(r,"Type must be complete");i.push(new s.CCompoundMember(e,c,o))}}return n.members=i,n.node=f,n}if(f instanceof a.pt.EnumSpecifier){let e=new s.CEnum(f,f.id);if(f.id){const n=t.lookupTag(f.id,s.CEnum,f);n?e=n:t.addTag(e)}if(!f.body)return s.CArithmetic.S32;let n=0n;const a=[];for(const e of f.body){e.value&&(n=o.evalIntegerConstant(e.value,t).value);const c=new i.CVarDefinition(e,e.id,s.addQualifier(s.CArithmetic.S32,"const"),"static","internal");c.staticValue=new r.CConstant(e,s.CArithmetic.S32,n),t.addIdentifier(c),a.push({name:e.id,value:n++})}return e.values=a,e.node=f,s.CArithmetic.S32}if(n.every((e=>"string"==typeof e))){const e=s.getArithmeticType(n);if(e)return e}else if(1===n.length&&n[0]instanceof a.pt.CustomTypeSpecifier)return t.lookupTypedef(n[0].name);throw new a.ParseTreeValidationError(e,"Invalid specifier")}(e.typeInfo,t);return e.typeInfo.qualifierList.length&&(n=s.addQualifier(n,e.typeInfo.qualifierList[0])),e.declarator&&(n=l(n,e.declarator,t)),n}function l(e,t,n){let i=t;for(;i&&!(i instanceof a.pt.IdentifierDeclarator);)if(i instanceof a.pt.PointerDeclarator||i instanceof a.pt.AbstractPointerDeclarator){let t=i.pointer;for(;t;)e=new s.CPointer(t,e,t.qualifierList?.includes("const")),t=t.body;i=i.body}else if(i instanceof a.pt.ArrayDeclarator||i instanceof a.pt.AbstractArrayDeclarator){if(e=new s.CArray(i,e),i.length&&(e.length=Number(o.evalIntegerConstant(i.length,n).value),e.length<=0))throw new a.ParseTreeValidationError(i.length,"Invalid array length");i=i.body}else{const t=[];let r=void 0;for(const e of i.args??[]){const i=c(e,n);if(i instanceof s.CFuncType)throw new a.ParseTreeValidationError(e,"Functions cannot be parameters");if(t.push(i),e.declarator&&!e.declarator.abstractDeclarator&&(r??(r=[]),r.push(h(e.declarator))),r&&r.length!==t.length)throw new a.ParseTreeValidationError(e,"Unexpected mix of abstract & non-abstract declarators")}1===t.length&&t[0]instanceof s.CVoid&&t.shift(),0===t.length&&(r=[]),e=new s.CFuncType(i,e,t,r,i.variadic),i=i.body}return e}function h(e){for(;!(e instanceof a.pt.IdentifierDeclarator);)e=e.body;return e.id}t.getType=c,t.getDeclaratorType=l,t.getDeclaratorName=h},6718:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.checkLvalue=t.asStructOrUnion=t.asFunction=t.asNonFunctionPointer=t.asArithmeticOrPointer=t.asPointer=t.asInteger=t.asArithmetic=t.ExpressionTypeError=void 0;const i=n(7745),r=n(4902);class ExpressionTypeError extends i.CError{constructor(e,t,n){super(n?`Expected ${t} but got ${n} instead!`:"Expected "+t,e),this.wantedType=t,this.actualType=n,this.name="ExpressionTypeError"}}function s(e,t){if(t instanceof r.CArithmetic)return t;throw new ExpressionTypeError(e,"arithmetic",t.typeName)}t.ExpressionTypeError=ExpressionTypeError,t.asArithmetic=s,t.asInteger=function(e,t){const n=s(e,t);switch(n.type){case"signed":case"unsigned":return n;default:throw new ExpressionTypeError(e,"integer",t.typeName)}},t.asPointer=function(e,t){if(t instanceof r.CPointer)return t;throw new ExpressionTypeError(e,"pointer",t.typeName)},t.asArithmeticOrPointer=function(e,t){if(t instanceof r.CArithmetic)return t;if(t instanceof r.CPointer)return t;throw new ExpressionTypeError(e,"arithmetic or pointer",t.typeName)},t.asNonFunctionPointer=function(e,t){if(t instanceof r.CPointer&&t.type instanceof r.CFuncType)throw new ExpressionTypeError(e,"non-function pointer","function pointer");return t},t.asFunction=function(e,t){if(t instanceof r.CFuncType)return t;if(t instanceof r.CPointer&&t.type instanceof r.CFuncType)return t.type;throw new ExpressionTypeError(e,"function",t.typeName)},t.asStructOrUnion=function(e,t){if(r.checkTypeComplete(t),t instanceof r.CStruct)return t;if(t instanceof r.CUnion)return t;throw new ExpressionTypeError(e,"struct or union",t.typeName)},t.checkLvalue=function(e,t){if(e.lvalue===t)return e;throw new ExpressionTypeError(e.node,"lvalue="+t,"lvalue="+e.lvalue)}},4902:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.checkTypeComplete=t.getArithmeticType=t.usualArithmeticConversion=t.integerPromotion=t.getQualifier=t.addQualifier=t.CSizeT=t.CArithmetic=t.CVoid=t.CEnum=t.CUnion=t.CStruct=t.CCompoundMember=t.CArray=t.CPointer=t.CFuncType=void 0;const i=n(7745);class CFuncType{constructor(e,t,n,i,r=!1){this.node=e,this.returnType=t,this.parameterTypes=n,this.parameterNames=i,this.variadic=r,this.typeName="function",this.bytes=0,this.alignment=1,this.incomplete=!1,t instanceof CVoid||o(t),n.forEach((e=>o(e)))}equals(e){return e instanceof CFuncType&&e.returnType.equals(this.returnType)&&e.parameterTypes.length===this.parameterTypes.length&&e.parameterTypes.every(((e,t)=>this.parameterTypes[t].equals(e)))&&e.variadic===this.variadic}}t.CFuncType=CFuncType;class CPointer{constructor(e,t,n=!1){this.node=e,this.type=t,this.typeName="pointer",this.bytes=4,this.alignment=4,this.incomplete=!1,n&&(this.qualifier="const")}equals(e){return e instanceof CPointer&&e.qualifier===this.qualifier&&this.type.equals(e.type)}}t.CPointer=CPointer;class CArray{constructor(e,t,n){this.node=e,this.type=t,this.length=n,this.typeName="array",o(t),this.alignment=t.alignment}get bytes(){if(void 0===this.length)throw new Error("Tried to get size of incomplete type");return this.type.bytes*this.length}get incomplete(){return void 0===this.length}equals(e){return e instanceof CArray&&e.length===this.length&&this.type.equals(e.type)}}t.CArray=CArray;t.CCompoundMember=class CCompoundMember{constructor(e,t,n){this.node=e,this.name=t,this.type=n}};class CStruct{constructor(e,t){this.node=e,this.name=t,this.typeName="struct"}get members(){if(void 0===this._members)throw new Error("Can't get members of an incomplete struct");return this._members}set members(e){if(void 0!==this._members)throw new Error("Can't redefine a struct's members");if(0===e.length)throw new Error("Struct must have one or more member");this._members=e}get bytes(){if(this.incomplete)throw new Error("Tried to get size of incomplete type");return this.members.reduce(((e,t)=>(e=Math.ceil(e/t.type.alignment)*t.type.alignment)+t.type.bytes),0)}get alignment(){return Math.max(...this.members.map((e=>e.type.alignment)))}get incomplete(){return void 0===this._members}equals(e){return void 0===this.name?this===e:e instanceof CStruct&&e.name===this.name}memberType(e){const t=this.members.find((t=>t.name===e));if(t)return t.type;throw new Error(`Struct does not contain member "${e}"`)}hasConstMember(){return void 0!==this.members.find((e=>s(e.type)||(e.type instanceof CUnion||e.type instanceof CStruct)&&e.type.hasConstMember()))}}t.CStruct=CStruct;class CUnion{constructor(e,t){this.node=e,this.name=t,this.typeName="union"}get members(){if(void 0===this._members)throw new Error("Can't get members of an incomplete union");return this._members}set members(e){if(void 0!==this._members)throw new Error("Can't redefine a union's members");if(0===e.length)throw new Error("Struct must have one or more member");this._members=e}get bytes(){if(this.incomplete)throw new Error("Tried to get size of incomplete type");return this.members.reduce(((e,t)=>Math.max(e,t.type.bytes)),0)}get alignment(){return Math.max(...this.members.map((e=>e.type.alignment)))}get incomplete(){return void 0===this._members}equals(e){return void 0===this.name?this===e:e instanceof CUnion&&e.name===this.name}memberType(e){const t=this.members.find((t=>t.name===e));if(t)return t.type;throw new Error(`Union does not contain member "${e}"`)}hasConstMember(){return void 0!==this.members.find((e=>s(e.type)||(e.type instanceof CUnion||e.type instanceof CStruct)&&e.type.hasConstMember()))}}t.CUnion=CUnion;class CEnum{constructor(e,t){this.node=e,this.name=t,this.typeName="enum"}get values(){if(void 0===this._values)throw new Error("Can't get values of an incomplete enum");return this._values}set values(e){if(void 0!==this._values)throw new Error("Can't redefine an enum's values");if(0===e.length)throw new Error("Enum must have one or more value");this._values=e}get incomplete(){return void 0===this._values}equals(e){return void 0===this.name?this===e:e instanceof CEnum&&e.name===this.name}}t.CEnum=CEnum;class CVoid{constructor(){this.typeName="void",this.bytes=0,this.alignment=1,this.incomplete=!0,this.node=void 0}equals(e){return e instanceof CVoid}}t.CVoid=CVoid;class CArithmetic{constructor(e,t,n){this.name=e,this.bytes=t,this.type=n,this.typeName="arithmetic",this.incomplete=!1,this.node=void 0,this.alignment=t}equals(e){return e instanceof CArithmetic&&e.name===this.name&&e.type===this.type&&e.bytes===this.bytes}get minValue(){if(CArithmetic.BOOL.equals(this))return 0;switch(this.type){case"float":return-1/0;case"unsigned":return 0;case"signed":return-(2n**(BigInt(8*this.bytes)-1n))}}get maxValue(){if(CArithmetic.BOOL.equals(this))return 1;switch(this.type){case"float":return 1/0;case"unsigned":return 2n**BigInt(8*this.bytes)-1n;case"signed":return 2n**(BigInt(8*this.bytes)-1n)-1n}}}t.CArithmetic=CArithmetic,CArithmetic.Fp32=new CArithmetic("float",4,"float"),CArithmetic.Fp64=new CArithmetic("double",8,"float"),CArithmetic.U8=new CArithmetic("char",1,"unsigned"),CArithmetic.S8=new CArithmetic("signed char",1,"signed"),CArithmetic.U16=new CArithmetic("unsigned short",2,"unsigned"),CArithmetic.S16=new CArithmetic("short",2,"signed"),CArithmetic.U32=new CArithmetic("unsigned int",4,"unsigned"),CArithmetic.S32=new CArithmetic("int",4,"signed"),CArithmetic.U64=new CArithmetic("unsigned long",8,"unsigned"),CArithmetic.S64=new CArithmetic("long",8,"signed"),CArithmetic.BOOL=new CArithmetic("bool",4,"signed"),t.CSizeT=CArithmetic.U32;const r=Symbol("const");function s(e){return e?.qualifier}function a(e){return"float"===e.type?e:e.bytes<CArithmetic.S32.bytes||e===CArithmetic.BOOL?CArithmetic.S32:e}function o(e,t=e.node){if(e.incomplete)throw new class extends i.CError{constructor(){super(...arguments),this.name="IncompleteTypeError"}}("Invalid use of an incomplete type",t);return e}t.addQualifier=function(e,t){if(void 0===t)return e;if(Object.prototype.hasOwnProperty.call(e,"qualifier"))throw new Error("Type already has a qualifier");const n=e;if(n[r])return n[r];const i=Object.setPrototypeOf({qualifier:t,_base:e},e);return n[r]=i,i},t.getQualifier=s,t.integerPromotion=a,t.usualArithmeticConversion=function(e,t){return e===CArithmetic.Fp64||t===CArithmetic.Fp64?CArithmetic.Fp64:e===CArithmetic.Fp32||t===CArithmetic.Fp32?CArithmetic.Fp32:(e=a(e),t=a(t),e===CArithmetic.U64||t===CArithmetic.U64?CArithmetic.U64:e===CArithmetic.S64||t===CArithmetic.S64?CArithmetic.S64:e===CArithmetic.U32||t===CArithmetic.U32?CArithmetic.U32:CArithmetic.S32)},t.getArithmeticType=function(e){const t=e.slice();function n(e){const n=t.indexOf(e);return n>-1&&(t.splice(n,1),!0)}function i(e){if(!(t.length>0))return e}return n("void")?i(new CVoid):n("double")?(n("long"),i(CArithmetic.Fp64)):n("float")?i(CArithmetic.Fp32):n("char")?n("signed")?i(CArithmetic.S8):(n("unsigned"),i(CArithmetic.U8)):n("short")?(n("int"),n("unsigned")?i(CArithmetic.U16):(n("signed"),i(CArithmetic.S16))):n("long")?(n("long"),n("int"),n("unsigned")?i(CArithmetic.U64):(n("signed"),i(CArithmetic.S64))):n("int")?n("unsigned")?i(CArithmetic.U32):(n("signed"),i(CArithmetic.S32)):n("unsigned")?i(CArithmetic.U32):n("signed")?i(CArithmetic.S32):n("bool")?i(CArithmetic.BOOL):void 0},t.checkTypeComplete=o},4118:e=>{"use strict";e.exports=JSON.parse("{\"ctype.h\":\"#pragma once\\nint isalnum(int chr);\\nint isalpha(int chr);\\nint iscntrl(int chr);\\nint isdigit(int chr);\\nint islower(int chr);\\nint isupper(int chr);\\nint isgraph(int chr);\\nint isprint(int chr);\\nint ispunct(int chr);\\nint isspace(int chr);\\nint isxdigit(int chr);\\nint tolower(int chr);\\nint toupper(int chr);\\n\",\"custom/alloc.c\":\"#include <stdlib.h>\\n#define PAGE_SIZE 65536\\n#define ALLOC_OFFSET (sizeof(struct node))\\n#define BLOCK_START(b) ((char*) (b) + ALLOC_OFFSET)\\nstatic struct node {\\nstruct node *prev;\\nstruct node *next;\\nsize_t size;\\nint padding;  \\n} alloc_list;\\nstatic void merge_blocks(struct node* node) {\\nstruct node* last = NULL;\\nwhile(node && node->next) {\\nsize_t end = (size_t) node + ALLOC_OFFSET + node->size;\\nstruct node* next = node->next;\\nif (end == (size_t) next) {\\nnode->size += ALLOC_OFFSET + next->size;\\nnode->next = next->next;\\nif (node->next->prev) node->next->prev = node;\\nnext->prev = NULL;\\nnext->next = NULL;\\nnext->size = 0;\\n} else {\\nnode = next;\\n}\\n}\\n}\\nvoid* malloc(size_t size) {\\nif(size > 0) {\\nsize = (size + 31) & ~31;  \\nstruct node *block = &alloc_list, *last = block;\\nwhile (block) {\\nif (block->size >= size) {\\nif (block->size - size >= 48) {\\nstruct node *new_block = (struct node*) (BLOCK_START(block) + size);\\nnew_block->size = block->size - size - ALLOC_OFFSET;\\nnew_block->prev = block;\\nnew_block->next = block->next;\\nblock->size = size;\\nif (block->next) block->next->prev = new_block;\\nblock->next = new_block;\\n}\\nstruct node *prev = block->prev, *next = block->next;\\nif (prev) prev->next = next;\\nif (next) next->prev = prev;\\nblock->next = (struct node *) -1;\\nblock->prev = (struct node *) 7;\\nreturn BLOCK_START(block);\\n}\\nlast = block;\\nblock = block->next;\\n}\\nint pages = 1 + ((size + ALLOC_OFFSET) / PAGE_SIZE);\\nint result = __wasm_i32__(1, pages, 0x40, 0);  \\nif (result < 0) {\\nreturn NULL;\\n} else {\\nlast->next = (struct node*) (result * PAGE_SIZE);\\nlast->next->size = (pages * PAGE_SIZE) - ALLOC_OFFSET;\\nlast->next->prev = last;\\nmerge_blocks(last);\\nreturn malloc(size);\\n}\\n}\\nreturn NULL;\\n}\\nvoid free(void* ptr) {\\nif (ptr) {\\nstruct node* block = (struct node*) ((char*)ptr - ALLOC_OFFSET);\\nif ((int) block->next != -1 || (int) block->prev != 7) {\\nreturn;\\n}\\n__wasm__(3, ptr, 0, block->size, 0xFC, 0x0B, 0x00);  \\nstruct node* list = &alloc_list;\\nwhile (list->next && list->next < block) {\\nlist = list->next;\\n}\\nblock->prev = list;\\nblock->next = list->next;\\nif (list->next && list->next->prev) list->next->prev = block;\\nlist->next = block;\\nmerge_blocks(&alloc_list);\\n}\\n}\\nvoid* realloc(void* ptr, size_t size) {\\nif (ptr) {\\nstruct node* block = (struct node*) ((char*)ptr - ALLOC_OFFSET);\\nif ((int) block->next != -1 || (int) block->prev != 7) {\\nreturn NULL;\\n}\\nif (block->size > size) {\\nreturn ptr;\\n}\\nvoid* new_ptr = malloc(size);\\n__wasm__(3, new_ptr, ptr, block->size, 0xFC, 0x0A, 0x00, 0x00);  \\nfree(ptr);\\nreturn new_ptr;\\n}\\nreturn NULL;\\n}\\nvoid* calloc(size_t nobj, size_t size) {\\nif (nobj && size) {\\nsize *= nobj;\\nvoid* ptr = malloc(size);\\nif (ptr) {\\n__wasm__(3, ptr, 0, size, 0xFC, 0x0B, 0x00);  \\n}\\nreturn ptr;\\n}\\nreturn NULL;\\n}\\n\",\"custom/ctype.c\":\"#include <ctype.h>\\nint isalnum(int chr) {\\nreturn isalpha(chr) || isdigit(chr);\\n}\\nint isalpha(int chr) {\\nreturn islower(chr) || isupper(chr);\\n}\\nint iscntrl(int chr) {\\nreturn chr < 0x20 || chr == 0x7f;\\n}\\nint isdigit(int chr) {\\nreturn chr >= '0' && chr <= '9';\\n}\\nint islower(int chr) {\\nreturn chr >= 'a' && chr <= 'z';\\n}\\nint isupper(int chr) {\\nreturn chr >= 'A' && chr <= 'Z';\\n}\\nint isgraph(int chr) {\\nreturn chr >= ' ' && chr <= '~';\\n}\\nint isprint(int chr) {\\nreturn chr > ' ' && chr <= '~';\\n}\\nint ispunct(int chr) {\\nreturn chr >= 'a' && chr <= 'z';\\n}\\nint isspace(int chr) {\\nreturn chr == ' ' || (chr >= '\\\\t' && chr <= '\\\\r');\\n}\\nint isxdigit(int chr) {\\nreturn isdigit(chr) || (chr >= 'a' && chr <= 'f') || (chr >= 'A' && chr <= 'F');\\n}\\nint tolower(int chr) {\\nreturn isupper(chr) ? chr + 32 : chr;\\n}\\nint toupper(int chr) {\\nreturn islower(chr) ? chr - 32 : chr;\\n}\\n\",\"custom/math.c\":\"#include <math.h>\\n#include <wasm/f64.h>\\ndouble sqrt(double d) {\\nreturn f64_sqrt(d);\\n}\\ndouble ceil(double d) {\\nreturn f64_ceil(d);\\n}\\ndouble fabs(double d) {\\nreturn f64_abs(d);\\n}\\ndouble floor(double d) {\\nreturn f64_floor(d);\\n}\\ndouble fmax(double d1, double d2) {\\nreturn f64_max(d1, d2);\\n}\\ndouble fmin(double d1, double d2) {\\nreturn f64_min(d1, d2);\\n}\\ndouble trunc(double d) {\\nreturn f64_trunc(d);\\n}\\ndouble copysign(double d1, double d2) {\\nreturn f64_copysign(d1, d2);\\n}\\ndouble round(double d) {\\nreturn f64_nearest(d);\\n}\\n\",\"custom/stdio.c\":\"#include <stdio.h>\\nint putchar(int chr) {\\n__put_char(chr);\\nreturn chr;\\n}\\nint puts(const char *s) {\\nchar *x = s;\\nwhile (*x) {\\n__put_char(*x);\\nx++;\\n}\\n__put_char('\\\\n');\\nreturn 0;\\n}\\n\",\"custom/string.c\":\"#include <string.h>\\nchar* strcpy(char* destination, const char* source) {\\nmemcpy(destination, source, strlen(source) + 1);  \\nreturn destination;\\n}\\nchar* strncpy(char* destination, const char* source, size_t n) {\\nconst size_t len = strnlen(source, n);\\nif (len < n) {\\nmemcpy(destination, source, len);\\nmemset(destination + len, 0, n - len);\\n} else {\\nmemcpy(destination, source, n);\\n}\\nreturn destination;\\n}\\nvoid* memcpy(void* destination, const void* source, size_t n) {\\n__wasm__(3, destination, source, n, 0xFC, 0x0A, 0, 0);  \\nreturn destination;\\n}\\nvoid* memset(void* destination, int c, size_t n) {\\n__wasm__(3, destination, c, n, 0xFC, 0x0B, 0);  \\nreturn destination;\\n}\\n\",\"float.h\":\"#pragma once\\n#define FLT_RADIX 2\\n#define FLT_ROUNDS 1\\n#define FLT_DIG 6\\n#define FLT_EPSILON 1.192092896e-07F\\n#define FLT_MANT_DIG 24\\n#define FLT_MAX 3.402823466e+38F\\n#define FLT_MAX_EXP 128\\n#define FLT_MIN 1.175494351e-38F\\n#define FLT_MIN_EXP (-125)\\n#define DBL_DIG 15\\n#define DBL_EPSILON 2.2204460492503131e-016\\n#define DBL_MANT_DIG 53\\n#define DBL_MAX 1.7976931348623158e+308\\n#define DBL_MAX_EXP 1024\\n#define DBL_MIN 2.2250738585072014e-308\\n#define DBL_MIN_EXP (-1021)\\n#define LDBL_DIG 15\\n#define LDBL_EPSILON 2.2204460492503131e-016\\n#define LDBL_MANT_DIG 53\\n#define LDBL_MAX 1.7976931348623158e+308\\n#define LDBL_MAX_EXP 1024\\n#define LDBL_MIN 2.2250738585072014e-308\\n#define LDBL_MIN_EXP (-1021)\\n\",\"libraries/musl/src/string/memchr.c\":\"#include <string.h>\\n#include <stdint.h>\\n#include <limits.h>\\n#define SS (sizeof(size_t))\\n#define ALIGN (sizeof(size_t)-1)\\n#define ONES ((size_t)-1/UCHAR_MAX)\\n#define HIGHS (ONES * (UCHAR_MAX/2+1))\\n#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)\\nvoid *memchr(const void *src, int c, size_t n)\\n{\\nconst unsigned char *s = src;\\nc = (unsigned char)c;\\nfor (; n && *s != c; s++, n--);\\nreturn n ? (void *)s : (void *)0;\\n}\\n\",\"libraries/musl/src/string/memcmp.c\":\"#include <string.h>\\nint memcmp(const void *vl, const void *vr, size_t n)\\n{\\nconst unsigned char *l=vl, *r=vr;\\nfor (; n && *l == *r; n--, l++, r++);\\nreturn n ? *l-*r : 0;\\n}\\n\",\"libraries/musl/src/string/memmove.c\":\"#include <string.h>\\n#include <stdint.h>\\nvoid *memmove(void *dest, const void *src, size_t n)\\n{\\nchar *d = dest;\\nconst char *s = src;\\nif (d==s) return d;\\nif ((uintptr_t)s-(uintptr_t)d-n <= -2*n) return memcpy(d, s, n);\\nif (d<s) {\\nfor (; n; n--) *d++ = *s++;\\n} else {\\nwhile (n) n--, d[n] = s[n];\\n}\\nreturn dest;\\n}\\n\",\"libraries/musl/src/string/strcat.c\":\"#include <string.h>\\nchar *strcat(char *dest, const char *src)\\n{\\nstrcpy(dest + strlen(dest), src);\\nreturn dest;\\n}\\n\",\"libraries/musl/src/string/strchr.c\":\"#include <string.h>\\nchar *__strchrnul(const char *s, int c);\\nchar *strchr(const char *s, int c)\\n{\\nchar *r = __strchrnul(s, c);\\nreturn *(unsigned char *)r == (unsigned char)c ? r : (char *)0;\\n}\\n\",\"libraries/musl/src/string/strchrnul.c\":\"#include <string.h>\\n#include <stdint.h>\\n#include <limits.h>\\n#define ALIGN (sizeof(size_t))\\n#define ONES ((size_t)-1/UCHAR_MAX)\\n#define HIGHS (ONES * (UCHAR_MAX/2+1))\\n#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)\\nchar *__strchrnul(const char *s, int c)\\n{\\nc = (unsigned char)c;\\nif (!c) return (char *)s + strlen(s);\\nfor (; *s && *(unsigned char *)s != c; s++);\\nreturn (char *)s;\\n}\\n\",\"libraries/musl/src/string/strcmp.c\":\"#include <string.h>\\nint strcmp(const char *l, const char *r)\\n{\\nfor (; *l==*r && *l; l++, r++);\\nreturn *(unsigned char *)l - *(unsigned char *)r;\\n}\\n\",\"libraries/musl/src/string/strcspn.c\":\"#include <string.h>\\n#define BITOP(a,b,op) \\\\\\n((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))\\nchar *__strchrnul(const char *s, int c);\\nsize_t strcspn(const char *s, const char *c)\\n{\\nconst char *a = s;\\nsize_t byteset[8];  \\nif (!c[0] || !c[1]) return (size_t) (__strchrnul(s, *c)-a);\\nmemset(byteset, 0, sizeof byteset);\\nfor (; *c && BITOP(byteset, *(unsigned char *)c, |=); c++);\\nfor (; *s && !BITOP(byteset, *(unsigned char *)s, &); s++);\\nreturn (size_t) (s-a);\\n}\\n\",\"libraries/musl/src/string/strlen.c\":\"#include <string.h>\\n#include <stdint.h>\\n#include <limits.h>\\n#define ALIGN (sizeof(size_t))\\n#define ONES ((size_t)-1/UCHAR_MAX)\\n#define HIGHS (ONES * (UCHAR_MAX/2+1))\\n#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)\\nsize_t strlen(const char *s)\\n{\\nconst char *a = s;\\nfor (; *s; s++);\\nreturn (size_t) (s-a);\\n}\\n\",\"libraries/musl/src/string/strncat.c\":\"#include <string.h>\\nchar *strncat(char *d, const char *s, size_t n)\\n{\\nchar *a = d;\\nd += strlen(d);\\nwhile (n && *s) n--, *d++ = *s++;\\n*d++ = 0;\\nreturn a;\\n}\\n\",\"libraries/musl/src/string/strncmp.c\":\"#include <string.h>\\nint strncmp(const char *_l, const char *_r, size_t n)\\n{\\nconst unsigned char *l=(void *)_l, *r=(void *)_r;\\nif (!n--) return 0;\\nfor (; *l && *r && n && *l == *r ; l++, r++, n--);\\nreturn *l - *r;\\n}\\n\",\"libraries/musl/src/string/strnlen.c\":\"#include <string.h>\\nsize_t strnlen(const char *s, size_t n)\\n{\\nconst char *p = memchr(s, 0, n);\\nreturn p ? (size_t) (p-s) : n;\\n}\\n\",\"libraries/musl/src/string/strpbrk.c\":\"#include <string.h>\\nchar *strpbrk(const char *s, const char *b)\\n{\\ns += strcspn(s, b);\\nreturn *s ? (char *)s : (char *) 0;\\n}\\n\",\"libraries/musl/src/string/strrchr.c\":\"#include <string.h>\\nvoid *__memrchr(const void *m, int c, size_t n)\\n{\\nconst unsigned char *s = m;\\nc = (unsigned char)c;\\nwhile (n--) if (s[n]==c) return (void *)(s+n);\\nreturn 0;\\n}\\nchar *strrchr(const char *s, int c)\\n{\\nreturn __memrchr(s, c, strlen(s) + 1);\\n}\\n\",\"libraries/musl/src/string/strspn.c\":\"#include <string.h>\\n#define BITOP(a,b,op) \\\\\\n((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))\\nsize_t strspn(const char *s, const char *c)\\n{\\nconst char *a = s;\\nsize_t byteset[8] = { 0 };\\nif (!c[0]) return 0;\\nif (!c[1]) {\\nfor (; *s == *c; s++);\\nreturn (size_t) (s-a);\\n}\\nfor (; *c && BITOP(byteset, *(unsigned char *)c, |=); c++);\\nfor (; *s && BITOP(byteset, *(unsigned char *)s, &); s++);\\nreturn (size_t) (s-a);\\n}\\n\",\"libraries/musl/src/string/strstr.c\":\"#include <string.h>\\n#include <stdint.h>\\nstatic char *twobyte_strstr(const unsigned char *h, const unsigned char *n)\\n{\\nuint16_t nw = n[0]<<8 | n[1], hw = h[0]<<8 | h[1];\\nfor (h++; *h && hw != nw; hw = hw<<8 | *++h);\\nreturn *h ? (char *)h-1 : (char *) 0;\\n}\\nstatic char *threebyte_strstr(const unsigned char *h, const unsigned char *n)\\n{\\nuint32_t nw = (uint32_t)n[0]<<24 | n[1]<<16 | n[2]<<8;\\nuint32_t hw = (uint32_t)h[0]<<24 | h[1]<<16 | h[2]<<8;\\nfor (h+=2; *h && hw != nw; hw = (hw|*++h)<<8);\\nreturn *h ? (char *)h-2 : (char *) 0;\\n}\\nstatic char *fourbyte_strstr(const unsigned char *h, const unsigned char *n)\\n{\\nuint32_t nw = (uint32_t)n[0]<<24 | n[1]<<16 | n[2]<<8 | n[3];\\nuint32_t hw = (uint32_t)h[0]<<24 | h[1]<<16 | h[2]<<8 | h[3];\\nfor (h+=3; *h && hw != nw; hw = hw<<8 | *++h);\\nreturn *h ? (char *)h-3 : (char *) 0;\\n}\\n#define MAX(a,b) ((a)>(b)?(a):(b))\\n#define MIN(a,b) ((a)<(b)?(a):(b))\\n#define BITOP(a,b,op) \\\\\\n((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))\\nstatic char *twoway_strstr(const unsigned char *h, const unsigned char *n)\\n{\\nconst unsigned char *z;\\nsize_t l, ip, jp, k, p, ms, p0, mem, mem0;\\nsize_t byteset[8] = { 0 };\\nsize_t shift[256];\\nfor (l=0; n[l] && h[l]; l++)\\nBITOP(byteset, n[l], |=), shift[n[l]] = l+1;\\nif (n[l]) return 0;  \\nip = -1; jp = 0; k = p = 1;\\nwhile (jp+k<l) {\\nif (n[ip+k] == n[jp+k]) {\\nif (k == p) {\\njp += p;\\nk = 1;\\n} else k++;\\n} else if (n[ip+k] > n[jp+k]) {\\njp += k;\\nk = 1;\\np = jp - ip;\\n} else {\\nip = jp++;\\nk = p = 1;\\n}\\n}\\nms = ip;\\np0 = p;\\nip = -1; jp = 0; k = p = 1;\\nwhile (jp+k<l) {\\nif (n[ip+k] == n[jp+k]) {\\nif (k == p) {\\njp += p;\\nk = 1;\\n} else k++;\\n} else if (n[ip+k] < n[jp+k]) {\\njp += k;\\nk = 1;\\np = jp - ip;\\n} else {\\nip = jp++;\\nk = p = 1;\\n}\\n}\\nif (ip+1 > ms+1) ms = ip;\\nelse p = p0;\\nif (memcmp(n, n+p, ms+1)) {\\nmem0 = 0;\\np = MAX(ms, l-ms-1) + 1;\\n} else mem0 = l-p;\\nmem = 0;\\nz = h;\\nfor (;;) {\\nif (z-h < l) {\\nsize_t grow = l | 63;\\nconst unsigned char *z2 = memchr(z, 0, grow);\\nif (z2) {\\nz = z2;\\nif (z-h < l) return 0;\\n} else z += grow;\\n}\\nif (BITOP(byteset, h[l-1], &)) {\\nk = l-shift[h[l-1]];\\nif (k) {\\nif (k < mem) k = mem;\\nh += k;\\nmem = 0;\\ncontinue;\\n}\\n} else {\\nh += l;\\nmem = 0;\\ncontinue;\\n}\\nfor (k=MAX(ms+1,mem); n[k] && n[k] == h[k]; k++);\\nif (n[k]) {\\nh += k-ms;\\nmem = 0;\\ncontinue;\\n}\\nfor (k=ms+1; k>mem && n[k-1] == h[k-1]; k--);\\nif (k <= mem) return (char *)h;\\nh += p;\\nmem = mem0;\\n}\\nreturn 0;\\n}\\nchar *strstr(const char *h, const char *n)\\n{\\nif (!n[0]) return (char *)h;\\nh = strchr(h, *n);\\nif (!h || !n[1]) return (char *)h;\\nif (!h[1]) return 0;\\nif (!n[2]) return twobyte_strstr((void *)h, (void *)n);\\nif (!h[2]) return 0;\\nif (!n[3]) return threebyte_strstr((void *)h, (void *)n);\\nif (!h[3]) return 0;\\nif (!n[4]) return fourbyte_strstr((void *)h, (void *)n);\\nreturn twoway_strstr((void *)h, (void *)n);\\n}\\n\",\"libraries/musl/src/string/strtok.c\":\"#include <string.h>\\nchar *strtok(char *s, const char *sep)\\n{\\nstatic char *p;\\nif (!s && !(s = p)) return NULL;\\ns += strspn(s, sep);\\nif (!*s) return p = 0;\\np = s + strcspn(s, sep);\\nif (*p) *p++ = 0;\\nelse p = 0;\\nreturn s;\\n}\\n\",\"libraries/printf/printf.c\":\"#include <stdbool.h>\\n#include <stdint.h>\\n#include \\\"printf.h\\\"\\n#ifdef PRINTF_INCLUDE_CONFIG_H\\n#include \\\"printf_config.h\\\"\\n#endif\\n#ifndef PRINTF_NTOA_BUFFER_SIZE\\n#define PRINTF_NTOA_BUFFER_SIZE    32U\\n#endif\\n#ifndef PRINTF_FTOA_BUFFER_SIZE\\n#define PRINTF_FTOA_BUFFER_SIZE    32U\\n#endif\\n#ifndef PRINTF_DISABLE_SUPPORT_FLOAT\\n#define PRINTF_SUPPORT_FLOAT\\n#endif\\n#ifndef PRINTF_DISABLE_SUPPORT_EXPONENTIAL\\n#define PRINTF_SUPPORT_EXPONENTIAL\\n#endif\\n#ifndef PRINTF_DEFAULT_FLOAT_PRECISION\\n#define PRINTF_DEFAULT_FLOAT_PRECISION  6U\\n#endif\\n#ifndef PRINTF_MAX_FLOAT\\n#define PRINTF_MAX_FLOAT  1e9\\n#endif\\n#ifndef PRINTF_DISABLE_SUPPORT_LONG_LONG\\n#define PRINTF_SUPPORT_LONG_LONG\\n#endif\\n#ifndef PRINTF_DISABLE_SUPPORT_PTRDIFF_T\\n#define PRINTF_SUPPORT_PTRDIFF_T\\n#endif\\n#define FLAGS_ZEROPAD   (1U <<  0U)\\n#define FLAGS_LEFT      (1U <<  1U)\\n#define FLAGS_PLUS      (1U <<  2U)\\n#define FLAGS_SPACE     (1U <<  3U)\\n#define FLAGS_HASH      (1U <<  4U)\\n#define FLAGS_UPPERCASE (1U <<  5U)\\n#define FLAGS_CHAR      (1U <<  6U)\\n#define FLAGS_SHORT     (1U <<  7U)\\n#define FLAGS_LONG      (1U <<  8U)\\n#define FLAGS_LONG_LONG (1U <<  9U)\\n#define FLAGS_PRECISION (1U << 10U)\\n#define FLAGS_ADAPT_EXP (1U << 11U)\\n#if defined(PRINTF_SUPPORT_FLOAT)\\n#include <float.h>\\n#endif\\ntypedef void (*out_fct_type)(char character, void* buffer, size_t idx, size_t maxlen);\\ntypedef struct {\\nvoid  (*fct)(char character, void* arg);\\nvoid* arg;\\n} out_fct_wrap_type;\\nstatic inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)\\n{\\nif (idx < maxlen) {\\n((char*)buffer)[idx] = character;\\n}\\n}\\nstatic inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)\\n{\\n(void)character; (void)buffer; (void)idx; (void)maxlen;\\n}\\nstatic inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)\\n{\\n(void)buffer; (void)idx; (void)maxlen;\\nif (character) {\\n_putchar(character);\\n}\\n}\\nstatic inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen)\\n{\\n(void)idx; (void)maxlen;\\nif (character) {\\n((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);\\n}\\n}\\nstatic inline unsigned int _strnlen_s(const char* str, size_t maxsize)\\n{\\nconst char* s;\\nfor (s = str; *s && maxsize--; ++s);\\nreturn (unsigned int)(s - str);\\n}\\nstatic inline bool _is_digit(char ch)\\n{\\nreturn (ch >= '0') && (ch <= '9');\\n}\\nstatic unsigned int _atoi(const char** str)\\n{\\nunsigned int i = 0U;\\nwhile (_is_digit(**str)) {\\ni = i * 10U + (unsigned int)(*((*str)++) - '0');\\n}\\nreturn i;\\n}\\nstatic size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)\\n{\\nconst size_t start_idx = idx;\\nif (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {\\nfor (size_t i = len; i < width; i++) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nwhile (len) {\\nout(buf[--len], buffer, idx++, maxlen);\\n}\\nif (flags & FLAGS_LEFT) {\\nwhile (idx - start_idx < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nreturn idx;\\n}\\nstatic size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nif (!(flags & FLAGS_LEFT)) {\\nif (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {\\nwidth--;\\n}\\nwhile ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = '0';\\n}\\nwhile ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = '0';\\n}\\n}\\nif (flags & FLAGS_HASH) {\\nif (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {\\nlen--;\\nif (len && (base == 16U)) {\\nlen--;\\n}\\n}\\nif ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = 'x';\\n}\\nelse if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = 'X';\\n}\\nelse if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\\nbuf[len++] = 'b';\\n}\\nif (len < PRINTF_NTOA_BUFFER_SIZE) {\\nbuf[len++] = '0';\\n}\\n}\\nif (len < PRINTF_NTOA_BUFFER_SIZE) {\\nif (negative) {\\nbuf[len++] = '-';\\n}\\nelse if (flags & FLAGS_PLUS) {\\nbuf[len++] = '+';   \\n}\\nelse if (flags & FLAGS_SPACE) {\\nbuf[len++] = ' ';\\n}\\n}\\nreturn _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);\\n}\\nstatic size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nchar buf[PRINTF_NTOA_BUFFER_SIZE];\\nsize_t len = 0U;\\nif (!value) {\\nflags &= ~FLAGS_HASH;\\n}\\nif (!(flags & FLAGS_PRECISION) || value) {\\ndo {\\nconst char digit = (char)(value % base);\\nbuf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;\\nvalue /= base;\\n} while (value && (len < PRINTF_NTOA_BUFFER_SIZE));\\n}\\nreturn _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);\\n}\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\nstatic size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nchar buf[PRINTF_NTOA_BUFFER_SIZE];\\nsize_t len = 0U;\\nif (!value) {\\nflags &= ~FLAGS_HASH;\\n}\\nif (!(flags & FLAGS_PRECISION) || value) {\\ndo {\\nconst char digit = (char)(value % base);\\nbuf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;\\nvalue /= base;\\n} while (value && (len < PRINTF_NTOA_BUFFER_SIZE));\\n}\\nreturn _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);\\n}\\n#endif   \\n#if defined(PRINTF_SUPPORT_FLOAT)\\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\\nstatic size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags);\\n#endif\\nstatic size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nchar buf[PRINTF_FTOA_BUFFER_SIZE];\\nsize_t len  = 0U;\\ndouble diff = 0.0;\\nstatic const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };\\nif (value != value)\\nreturn _out_rev(out, buffer, idx, maxlen, \\\"nan\\\", 3, width, flags);\\nif (value < -DBL_MAX)\\nreturn _out_rev(out, buffer, idx, maxlen, \\\"fni-\\\", 4, width, flags);\\nif (value > DBL_MAX)\\nreturn _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? \\\"fni+\\\" : \\\"fni\\\", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);\\nif ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {\\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\\nreturn _etoa(out, buffer, idx, maxlen, value, prec, width, flags);\\n#else\\nreturn 0U;\\n#endif\\n}\\nbool negative = false;\\nif (value < 0) {\\nnegative = true;\\nvalue = 0 - value;\\n}\\nif (!(flags & FLAGS_PRECISION)) {\\nprec = PRINTF_DEFAULT_FLOAT_PRECISION;\\n}\\nwhile ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {\\nbuf[len++] = '0';\\nprec--;\\n}\\nint whole = (int)value;\\ndouble tmp = (value - whole) * pow10[prec];\\nunsigned long frac = (unsigned long)tmp;\\ndiff = tmp - frac;\\nif (diff > 0.5) {\\n++frac;\\nif (frac >= pow10[prec]) {\\nfrac = 0;\\n++whole;\\n}\\n}\\nelse if (diff < 0.5) {\\n}\\nelse if ((frac == 0U) || (frac & 1U)) {\\n++frac;\\n}\\nif (prec == 0U) {\\ndiff = value - (double)whole;\\nif ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {\\n++whole;\\n}\\n}\\nelse {\\nunsigned int count = prec;\\nwhile (len < PRINTF_FTOA_BUFFER_SIZE) {\\n--count;\\nbuf[len++] = (char)(48U + (frac % 10U));\\nif (!(frac /= 10U)) {\\nbreak;\\n}\\n}\\nwhile ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {\\nbuf[len++] = '0';\\n}\\nif (len < PRINTF_FTOA_BUFFER_SIZE) {\\nbuf[len++] = '.';\\n}\\n}\\nwhile (len < PRINTF_FTOA_BUFFER_SIZE) {\\nbuf[len++] = (char)(48 + (whole % 10));\\nif (!(whole /= 10)) {\\nbreak;\\n}\\n}\\nif (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {\\nif (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {\\nwidth--;\\n}\\nwhile ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {\\nbuf[len++] = '0';\\n}\\n}\\nif (len < PRINTF_FTOA_BUFFER_SIZE) {\\nif (negative) {\\nbuf[len++] = '-';\\n}\\nelse if (flags & FLAGS_PLUS) {\\nbuf[len++] = '+';   \\n}\\nelse if (flags & FLAGS_SPACE) {\\nbuf[len++] = ' ';\\n}\\n}\\nreturn _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);\\n}\\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\\nstatic size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)\\n{\\nif ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {\\nreturn _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);\\n}\\nconst bool negative = value < 0;\\nif (negative) {\\nvalue = -value;\\n}\\nif (!(flags & FLAGS_PRECISION)) {\\nprec = PRINTF_DEFAULT_FLOAT_PRECISION;\\n}\\nunion {\\nuint64_t U;\\ndouble   F;\\n} conv;\\nconv.F = value;\\nint exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;            \\nconv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);   \\nint expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);\\nexp2 = (int)(expval * 3.321928094887362 + 0.5);\\nconst double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;\\nconst double z2 = z * z;\\nconv.U = (uint64_t)(exp2 + 1023) << 52U;\\nconv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));\\nif (value < conv.F) {\\nexpval--;\\nconv.F /= 10;\\n}\\nunsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;\\nif (flags & FLAGS_ADAPT_EXP) {\\nif ((value >= 1e-4) && (value < 1e6)) {\\nif ((int)prec > expval) {\\nprec = (unsigned)((int)prec - expval - 1);\\n}\\nelse {\\nprec = 0;\\n}\\nflags |= FLAGS_PRECISION;    \\nminwidth = 0U;\\nexpval   = 0;\\n}\\nelse {\\nif ((prec > 0) && (flags & FLAGS_PRECISION)) {\\n--prec;\\n}\\n}\\n}\\nunsigned int fwidth = width;\\nif (width > minwidth) {\\nfwidth -= minwidth;\\n} else {\\nfwidth = 0U;\\n}\\nif ((flags & FLAGS_LEFT) && minwidth) {\\nfwidth = 0U;\\n}\\nif (expval) {\\nvalue /= conv.F;\\n}\\nconst size_t start_idx = idx;\\nidx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);\\nif (minwidth) {\\nout((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);\\nidx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);\\nif (flags & FLAGS_LEFT) {\\nwhile (idx - start_idx < width) out(' ', buffer, idx++, maxlen);\\n}\\n}\\nreturn idx;\\n}\\n#endif   \\n#endif   \\nstatic int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)\\n{\\nunsigned int flags, width, precision, n;\\nsize_t idx = 0U;\\nif (!buffer) {\\nout = _out_null;\\n}\\nwhile (*format)\\n{\\nif (*format != '%') {\\nout(*format, buffer, idx++, maxlen);\\nformat++;\\ncontinue;\\n}\\nelse {\\nformat++;\\n}\\nflags = 0U;\\ndo {\\nswitch (*format) {\\ncase '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;\\ncase '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;\\ncase '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;\\ncase ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;\\ncase '#': flags |= FLAGS_HASH;    format++; n = 1U; break;\\ndefault :                                   n = 0U; break;\\n}\\n} while (n);\\nwidth = 0U;\\nif (_is_digit(*format)) {\\nwidth = _atoi(&format);\\n}\\nelse if (*format == '*') {\\nconst int w = va_arg(va, int);\\nif (w < 0) {\\nflags |= FLAGS_LEFT;     \\nwidth = (unsigned int)-w;\\n}\\nelse {\\nwidth = (unsigned int)w;\\n}\\nformat++;\\n}\\nprecision = 0U;\\nif (*format == '.') {\\nflags |= FLAGS_PRECISION;\\nformat++;\\nif (_is_digit(*format)) {\\nprecision = _atoi(&format);\\n}\\nelse if (*format == '*') {\\nconst int prec = (int)va_arg(va, int);\\nprecision = prec > 0 ? (unsigned int)prec : 0U;\\nformat++;\\n}\\n}\\nswitch (*format) {\\ncase 'l' :\\nflags |= FLAGS_LONG;\\nformat++;\\nif (*format == 'l') {\\nflags |= FLAGS_LONG_LONG;\\nformat++;\\n}\\nbreak;\\ncase 'h' :\\nflags |= FLAGS_SHORT;\\nformat++;\\nif (*format == 'h') {\\nflags |= FLAGS_CHAR;\\nformat++;\\n}\\nbreak;\\n#if defined(PRINTF_SUPPORT_PTRDIFF_T)\\ncase 't' :\\nflags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\\nformat++;\\nbreak;\\n#endif\\ncase 'j' :\\nflags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\\nformat++;\\nbreak;\\ncase 'z' :\\nflags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\\nformat++;\\nbreak;\\ndefault :\\nbreak;\\n}\\nswitch (*format) {\\ncase 'd' :\\ncase 'i' :\\ncase 'u' :\\ncase 'x' :\\ncase 'X' :\\ncase 'o' :\\ncase 'b' : {\\nunsigned int base;\\nif (*format == 'x' || *format == 'X') {\\nbase = 16U;\\n}\\nelse if (*format == 'o') {\\nbase =  8U;\\n}\\nelse if (*format == 'b') {\\nbase =  2U;\\n}\\nelse {\\nbase = 10U;\\nflags &= ~FLAGS_HASH;    \\n}\\nif (*format == 'X') {\\nflags |= FLAGS_UPPERCASE;\\n}\\nif ((*format != 'i') && (*format != 'd')) {\\nflags &= ~(FLAGS_PLUS | FLAGS_SPACE);\\n}\\nif (flags & FLAGS_PRECISION) {\\nflags &= ~FLAGS_ZEROPAD;\\n}\\nif ((*format == 'i') || (*format == 'd')) {\\nif (flags & FLAGS_LONG_LONG) {\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\nconst long long value = va_arg(va, long long);\\nidx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\\n#endif\\n}\\nelse if (flags & FLAGS_LONG) {\\nconst long value = va_arg(va, long);\\nidx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\\n}\\nelse {\\nconst int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);\\nidx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\\n}\\n}\\nelse {\\nif (flags & FLAGS_LONG_LONG) {\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\nidx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);\\n#endif\\n}\\nelse if (flags & FLAGS_LONG) {\\nidx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);\\n}\\nelse {\\nconst unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);\\nidx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);\\n}\\n}\\nformat++;\\nbreak;\\n}\\n#if defined(PRINTF_SUPPORT_FLOAT)\\ncase 'f' :\\ncase 'F' :\\nif (*format == 'F') flags |= FLAGS_UPPERCASE;\\nidx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);\\nformat++;\\nbreak;\\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\\ncase 'e':\\ncase 'E':\\ncase 'g':\\ncase 'G':\\nif ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;\\nif ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;\\nidx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);\\nformat++;\\nbreak;\\n#endif   \\n#endif   \\ncase 'c' : {\\nunsigned int l = 1U;\\nif (!(flags & FLAGS_LEFT)) {\\nwhile (l++ < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nout((char)va_arg(va, int), buffer, idx++, maxlen);\\nif (flags & FLAGS_LEFT) {\\nwhile (l++ < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nformat++;\\nbreak;\\n}\\ncase 's' : {\\nconst char* p = va_arg(va, char*);\\nunsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);\\nif (flags & FLAGS_PRECISION) {\\nl = (l < precision ? l : precision);\\n}\\nif (!(flags & FLAGS_LEFT)) {\\nwhile (l++ < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nwhile ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {\\nout(*(p++), buffer, idx++, maxlen);\\n}\\nif (flags & FLAGS_LEFT) {\\nwhile (l++ < width) {\\nout(' ', buffer, idx++, maxlen);\\n}\\n}\\nformat++;\\nbreak;\\n}\\ncase 'p' : {\\nwidth = sizeof(void*) * 2U;\\nflags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\nconst bool is_ll = sizeof(uintptr_t) == sizeof(long long);\\nif (is_ll) {\\nidx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);\\n}\\nelse {\\n#endif\\nidx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);\\n#if defined(PRINTF_SUPPORT_LONG_LONG)\\n}\\n#endif\\nformat++;\\nbreak;\\n}\\ncase '%' :\\nout('%', buffer, idx++, maxlen);\\nformat++;\\nbreak;\\ndefault :\\nout(*format, buffer, idx++, maxlen);\\nformat++;\\nbreak;\\n}\\n}\\nout((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);\\nreturn (int)idx;\\n}\\nint printf_(const char* format, ...)\\n{\\nva_list va;\\nva_start(va, format);\\nchar buffer[1];\\nconst int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);\\nva_end(va);\\nreturn ret;\\n}\\nint sprintf_(char* buffer, const char* format, ...)\\n{\\nva_list va;\\nva_start(va, format);\\nconst int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);\\nva_end(va);\\nreturn ret;\\n}\\nint snprintf_(char* buffer, size_t count, const char* format, ...)\\n{\\nva_list va;\\nva_start(va, format);\\nconst int ret = _vsnprintf(_out_buffer, buffer, count, format, va);\\nva_end(va);\\nreturn ret;\\n}\\nint vprintf_(const char* format, va_list va)\\n{\\nchar buffer[1];\\nreturn _vsnprintf(_out_char, buffer, (size_t)-1, format, va);\\n}\\nint vsnprintf_(char* buffer, size_t count, const char* format, va_list va)\\n{\\nreturn _vsnprintf(_out_buffer, buffer, count, format, va);\\n}\\nint fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)\\n{\\nva_list va;\\nva_start(va, format);\\nconst out_fct_wrap_type out_fct_wrap = { out, arg };\\nconst int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);\\nva_end(va);\\nreturn ret;\\n}\\n\",\"libraries/printf/printf.h\":\"#include <stdio.h>\\n#define _putchar __put_char\\n#define printf_ printf\\n#define sprintf_ sprintf\\n#define snprintf_ snprintf\\n#define vprintf_ vprintf\\n#define vsnprintf_ vsnprintf\\n\",\"limits.h\":\"#pragma once\\n#define CHAR_BIT 8\\n#define CHAR_MAX 255\\n#define CHAR_MIN 0\\n#define INT_MAX 2147483647\\n#define INT_MIN -2147483648\\n#define LONG_MAX 9223372036854775807\\n#define LONG_MIN -9223372036854775808\\n#define LLONG_MAX 9223372036854775807\\n#define LLONG_MIN -9223372036854775808\\n#define SCHAR_MAX 127\\n#define SCHAR_MIN -128\\n#define SHRT_MAX 32767\\n#define SHRT_MIN -32768\\n#define UCHAR_MAX 255\\n#define USHRT_MAX 65535\\n#define UINT_MAX 4294967295\\n#define ULONG_MAX 18446744073709551615\\n#define ULLONG_MAX 18446744073709551615\\n\",\"math.h\":\"#pragma once\\ndouble sqrt(double);\\ndouble ceil(double);\\ndouble fabs(double);\\ndouble floor(double);\\ndouble fmax(double, double);\\ndouble fmin(double, double);\\ndouble trunc(double);\\ndouble copysign(double, double);\\ndouble round(double);  \\n\",\"stdarg.h\":\"#pragma once\\ntypedef char *va_list;\\n#define va_start(ap, parmN) ( ap = ((char*) __wasm_ssp__()) - 8 )\\n#define va_arg(ap, T) ( ap -= 8, *((T*) __wasm_rload__((T *) (ap + 8))) )\\n#define va_copy(dst, src) ( dst = src )\\n#define va_end(ap) \\\"va_end\\\"\\n\",\"stdbool.h\":\"#pragma once\\n#define __bool_true_false_are_defined 1\\n#define bool _Bool\\n#define false 0\\n#define true 1\\n\",\"stddef.h\":\"#pragma once\\n#define NULL ((void *) 0)\\n#define offsetof(st, m) ((size_t)&(((st *)0)->m))\\n#ifndef __type_size\\n#define __type_size\\ntypedef unsigned int size_t;\\n#endif\\n#ifndef __type_ptrdiff\\n#define __type_ptrdiff\\ntypedef signed long ptrdiff_t;\\n#endif\\n\",\"stdint.h\":\"#pragma once\\n#ifndef __type_int8\\n#define __type_int8\\ntypedef signed char int8_t;\\n#define INT8_MAX 127\\n#define INT8_MIN -128\\n#endif\\n#ifndef __type_uint8\\n#define __type_uint8\\ntypedef unsigned char uint8_t;\\n#define UINT8_MAX 255\\n#endif\\n#ifndef __type_int16\\n#define __type_int16\\ntypedef signed short int16_t;\\n#define INT16_MAX 32767\\n#define INT16_MIN -32768\\n#endif\\n#ifndef __type_uint16\\n#define __type_uint16\\ntypedef unsigned short uint16_t;\\n#define UINT16_MAX 65535\\n#endif\\n#ifndef __type_int32\\n#define __type_int32\\ntypedef signed int int32_t;\\n#define INT32_MAX 2147483647\\n#define INT32_MIN -2147483648\\n#endif\\n#ifndef __type_uint32\\n#define __type_uint32\\ntypedef unsigned int uint32_t;\\n#define UINT32_MAX 4294967295\\n#endif\\n#ifndef __type_int64\\n#define __type_int64\\ntypedef signed long int64_t;\\n#define INT64_MAX 9223372036854775807\\n#define INT64_MIN -9223372036854775808\\n#endif\\n#ifndef __type_uint64\\n#define __type_uint64\\ntypedef unsigned long uint64_t;\\n#define UINT64_MAX 18446744073709551615\\n#endif\\n#ifndef __type_int_least8\\n#define __type_int_least8\\ntypedef signed char int_least8_t;\\n#define INT_LEAST8_MAX 127\\n#define INT_LEAST8_MIN -128\\n#endif\\n#ifndef __type_uint_least8\\n#define __type_uint_least8\\ntypedef unsigned char uint_least8_t;\\n#define UINT_LEAST8_MAX 255\\n#endif\\n#ifndef __type_int_least16\\n#define __type_int_least16\\ntypedef signed short int_least16_t;\\n#define INT_LEAST16_MAX 32767\\n#define INT_LEAST16_MIN -32768\\n#endif\\n#ifndef __type_uint_least16\\n#define __type_uint_least16\\ntypedef unsigned short uint_least16_t;\\n#define UINT_LEAST16_MAX 65535\\n#endif\\n#ifndef __type_int_least32\\n#define __type_int_least32\\ntypedef signed int int_least32_t;\\n#define INT_LEAST32_MAX 2147483647\\n#define INT_LEAST32_MIN -2147483648\\n#endif\\n#ifndef __type_uint_least32\\n#define __type_uint_least32\\ntypedef unsigned int uint_least32_t;\\n#define UINT_LEAST32_MAX 4294967295\\n#endif\\n#ifndef __type_int_least64\\n#define __type_int_least64\\ntypedef signed long int_least64_t;\\n#define INT_LEAST64_MAX 9223372036854775807\\n#define INT_LEAST64_MIN -9223372036854775808\\n#endif\\n#ifndef __type_uint_least64\\n#define __type_uint_least64\\ntypedef unsigned long uint_least64_t;\\n#define UINT_LEAST64_MAX 18446744073709551615\\n#endif\\n#ifndef __type_int_fast8\\n#define __type_int_fast8\\ntypedef signed int int_fast8_t;\\n#define INT_FAST8_MAX 2147483647\\n#define INT_FAST8_MIN -2147483648\\n#endif\\n#ifndef __type_uint_fast8\\n#define __type_uint_fast8\\ntypedef unsigned int uint_fast8_t;\\n#define UINT_FAST8_MAX 4294967295\\n#endif\\n#ifndef __type_int_fast16\\n#define __type_int_fast16\\ntypedef signed int int_fast16_t;\\n#define INT_FAST16_MAX 2147483647\\n#define INT_FAST16_MIN -2147483648\\n#endif\\n#ifndef __type_uint_fast16\\n#define __type_uint_fast16\\ntypedef unsigned int uint_fast16_t;\\n#define UINT_FAST16_MAX 4294967295\\n#endif\\n#ifndef __type_int_fast32\\n#define __type_int_fast32\\ntypedef signed int int_fast32_t;\\n#define INT_FAST32_MAX 2147483647\\n#define INT_FAST32_MIN -2147483648\\n#endif\\n#ifndef __type_uint_fast32\\n#define __type_uint_fast32\\ntypedef unsigned int uint_fast32_t;\\n#define UINT_FAST32_MAX 4294967295\\n#endif\\n#ifndef __type_int_fast64\\n#define __type_int_fast64\\ntypedef signed long int_fast64_t;\\n#define INT_FAST64_MAX 9223372036854775807\\n#define INT_FAST64_MIN -9223372036854775808\\n#endif\\n#ifndef __type_uint_fast64\\n#define __type_uint_fast64\\ntypedef unsigned long uint_fast64_t;\\n#define UINT_FAST64_MAX 18446744073709551615\\n#endif\\n#ifndef __type_intptr\\n#define __type_intptr\\ntypedef signed int intptr_t;\\n#define INTPTR_MAX 2147483647\\n#define INTPTR_MIN -2147483648\\n#endif\\n#ifndef __type_uintptr\\n#define __type_uintptr\\ntypedef unsigned int uintptr_t;\\n#define UINTPTR_MAX 4294967295\\n#endif\\n#ifndef __type_intmax\\n#define __type_intmax\\ntypedef signed int intmax_t;\\n#define INTMAX_MAX 9223372036854775807\\n#define INTMAX_MIN -9223372036854775808\\n#endif\\n#ifndef __type_uintmax\\n#define __type_uintmax\\ntypedef unsigned int uintmax_t;\\n#define UINTMAX_MAX 18446744073709551615\\n#endif\\n\",\"stdio.h\":\"#pragma once\\n#include <stddef.h>\\n#include <stdarg.h>\\nimport void __put_char(char);\\nint printf(const char* format, ...);\\nint sprintf(char* buffer, const char* format, ...);\\nint snprintf(char* buffer, size_t count, const char* format, ...);\\nint vsnprintf(char* buffer, size_t count, const char* format, va_list va);\\nint vprintf(const char* format, va_list va);\\nint fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...);\\nint putchar(int chr);\\nint puts(const char *s);\\n\",\"stdlib.h\":\"#pragma once\\n#include <stddef.h>\\n#include <stdarg.h>\\nvoid* malloc(size_t size);\\nvoid free(void* ptr);\\nvoid* realloc(void* ptr, size_t size);\\nvoid* calloc(size_t nobj, size_t size);\\n\",\"string.h\":\"#pragma once\\n#include <stddef.h>\\nchar* strcpy(char* s1, const char* s2);\\nchar* strncpy(char* s1, const char* s2, size_t n);\\nchar* strcat(char* s1, const char* s2);\\nchar* strncat(char* s1, const char* s2, size_t n);\\nint strcmp(const char* s1, const char* s2);\\nint strncmp(const char* s1, const char* s2, size_t n);\\nchar* strchr(const char* s, int c);\\nchar* strrchr(const char* s, int c);\\nsize_t strspn(const char* s1, const char* s2);\\nsize_t strcspn(const char* s1, const char* s2);\\nchar* strpbrk(const char* s1, const char* s2);\\nchar* strstr(const char* s1, const char* s2);\\nsize_t strlen(const char* s);\\nsize_t strnlen(const char* s, size_t n);\\nchar* strtok(char* s1, const char* s2);\\nvoid* memcpy(void* s1, const void* s2, size_t n);\\nvoid* memmove(void* s1, const void* s2, size_t n);\\nint memcmp(const void* s1, const void* s2, size_t n);\\nvoid* memchr(const void* s, int c, size_t n);\\nvoid* memset(void* s, int c, size_t n);\\n\",\"wasm/f32.h\":\"#pragma once\\n#define f32_abs(x)          (__wasm_f32__(1, (float) x, 0x8B))\\n#define f32_neg(x)          (__wasm_f32__(1, (float) x, 0x8C))\\n#define f32_ceil(x)         (__wasm_f32__(1, (float) x, 0x8D))\\n#define f32_floor(x)        (__wasm_f32__(1, (float) x, 0x8E))\\n#define f32_trunc(x)        (__wasm_f32__(1, (float) x, 0x8F))\\n#define f32_nearest(x)      (__wasm_f32__(1, (float) x, 0x90))\\n#define f32_sqrt(x)         (__wasm_f32__(1, (float) x, 0x91))\\n#define f32_min(x,y)        (__wasm_f32__(2, (float) x, (float) y, 0x96))\\n#define f32_max(x,y)        (__wasm_f32__(2, (float) x, (float) y, 0x97))\\n#define f32_copysign(x,y)   (__wasm_f32__(2, (float) x, (float) y, 0x98))\\n\",\"wasm/f64.h\":\"#pragma once\\n#define f64_abs(x)          (__wasm_f64__(1, (double) x, 0x99))\\n#define f64_neg(x)          (__wasm_f64__(1, (double) x, 0x9A))\\n#define f64_ceil(x)         (__wasm_f64__(1, (double) x, 0x9B))\\n#define f64_floor(x)        (__wasm_f64__(1, (double) x, 0x9C))\\n#define f64_trunc(x)        (__wasm_f64__(1, (double) x, 0x9D))\\n#define f64_nearest(x)      (__wasm_f64__(1, (double) x, 0x9E))\\n#define f64_sqrt(x)         (__wasm_f64__(1, (double) x, 0x9F))\\n#define f64_min(x,y)        (__wasm_f64__(2, (double) x, (double) y, 0xA4))\\n#define f64_max(x,y)        (__wasm_f64__(2, (double) x, (double) y, 0xA5))\\n#define f64_copysign(x,y)   (__wasm_f64__(2, (double) x, (double) y, 0xA6))\\n\"}")},6347:(e,t,n)=>{var i=function(){function e(e,t){var n;if(Object.defineProperty(this,"name",{enumerable:!1,writable:!1,value:"JisonParserError"}),null==e&&(e="???"),Object.defineProperty(this,"message",{enumerable:!1,writable:!0,value:e}),this.hash=t,t&&t.exception instanceof Error){var i=t.exception;this.message=i.message||e,n=i.stack}n||(Error.hasOwnProperty("captureStackTrace")?Error.captureStackTrace(this,this.constructor):n=new Error(e).stack),n&&Object.defineProperty(this,"stack",{enumerable:!1,writable:!1,value:n})}function t(e,t,n){n=n||0;for(var i=0;i<t;i++)this.push(e),e+=n}function i(e,t){for(t+=e=this.length-e;e<t;e++)this.push(this[e])}function r(e){for(var t=[],n=0,i=e.length;n<i;n++){var r=e[n];"function"==typeof r?(n++,r.apply(t,e[n])):t.push(r)}return t}"function"==typeof Object.setPrototypeOf?Object.setPrototypeOf(e.prototype,Error.prototype):e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e.prototype.name="JisonParserError";var s={trace:function(){},JisonParserError:e,yy:{},options:{type:"lalr",hasPartialLrUpgradeOnConflict:!0,errorRecoveryTokenDiscardCount:3},symbols_:{"!":14,$accept:0,$end:1,"%":16,"&":9,"(":3,")":4,"*":10,"+":11,",":8,"-":12,".":7,"/":15,":":22,";":24,"<":17,"=":23,">":18,"?":21,ADD_ASSIGN:49,AND_ASSIGN:53,AND_OP:44,BREAK:87,CASE:77,CHAR:60,CONST:73,CONSTANT_CHAR:32,CONSTANT_FLOAT:28,CONSTANT_HEX:29,CONSTANT_INT:31,CONSTANT_OCTAL:30,CONTINUE:86,DEC_OP:36,DEFAULT:78,DIV_ASSIGN:47,DO:83,DOUBLE:65,ELLIPSIS:76,ELSE:80,ENUM:72,EOF:1,EQ_OP:42,EXTERN:57,FLOAT:64,FOR:84,GE_OP:41,GOTO:85,IDENTIFIER:27,IF:79,IMPORT:75,INC_OP:35,INLINE:74,INT:62,LEFT_ASSIGN:51,LEFT_OP:38,LE_OP:40,LONG:63,MOD_ASSIGN:48,MUL_ASSIGN:46,NE_OP:43,OR_ASSIGN:55,OR_OP:45,PTR_OP:34,RETURN:88,RIGHT_ASSIGN:52,RIGHT_OP:39,SHORT:61,SIGNED:66,SIZEOF:37,STATIC:58,STRING_LITERAL:33,STRUCT:70,SUB_ASSIGN:50,SWITCH:81,TYPEDEF:56,TYPE_NAME:69,UNION:71,UNSIGNED:67,VOID:59,WHILE:82,XOR_ASSIGN:54,"[":5,"]":6,"^":19,_BOOL:68,abstract_declarator:141,additive_expression:101,and_expression:105,argument_expression_list:96,assignment_expression:111,assignment_operator:112,ast_tree:89,block_item:149,block_item_list:148,cast_expression:99,compound_statement:147,concat_string_literals:93,conditional_expression:110,constant:91,constant_expression:114,declaration:115,declaration_specifiers:116,declarator:133,direct_abstract_declarator:142,direct_declarator:134,enum_specifier:128,enumerator:130,enumerator_list:129,equality_expression:104,error:2,exclusive_or_expression:106,expression:113,expression_statement:150,external_declaration:155,function_definition:156,function_specifier:132,identifier:90,inclusive_or_expression:107,init_declarator:118,init_declarator_list:117,initializer:143,initializer_list:144,iteration_statement:152,jump_statement:153,labeled_statement:146,logical_and_expression:108,logical_or_expression:109,multiplicative_expression:100,parameter_declaration:139,parameter_list:138,parameter_type_list:137,pointer:135,postfix_expression:95,primary_expression:94,relational_expression:103,selection_statement:151,shift_expression:102,specifier_qualifier_list:125,statement:145,storage_class_specifier:119,string_literal:92,struct_declaration:124,struct_declaration_list:123,struct_declarator:127,struct_declarator_list:126,struct_or_union:122,struct_or_union_specifier:121,translation_unit:154,type_name:140,type_qualifier:131,type_qualifier_list:136,type_specifier:120,unary_expression:97,unary_operator:98,"{":25,"|":20,"}":26,"~":13},terminals_:{1:"EOF",2:"error",3:"(",4:")",5:"[",6:"]",7:".",8:",",9:"&",10:"*",11:"+",12:"-",13:"~",14:"!",15:"/",16:"%",17:"<",18:">",19:"^",20:"|",21:"?",22:":",23:"=",24:";",25:"{",26:"}",27:"IDENTIFIER",28:"CONSTANT_FLOAT",29:"CONSTANT_HEX",30:"CONSTANT_OCTAL",31:"CONSTANT_INT",32:"CONSTANT_CHAR",33:"STRING_LITERAL",34:"PTR_OP",35:"INC_OP",36:"DEC_OP",37:"SIZEOF",38:"LEFT_OP",39:"RIGHT_OP",40:"LE_OP",41:"GE_OP",42:"EQ_OP",43:"NE_OP",44:"AND_OP",45:"OR_OP",46:"MUL_ASSIGN",47:"DIV_ASSIGN",48:"MOD_ASSIGN",49:"ADD_ASSIGN",50:"SUB_ASSIGN",51:"LEFT_ASSIGN",52:"RIGHT_ASSIGN",53:"AND_ASSIGN",54:"XOR_ASSIGN",55:"OR_ASSIGN",56:"TYPEDEF",57:"EXTERN",58:"STATIC",59:"VOID",60:"CHAR",61:"SHORT",62:"INT",63:"LONG",64:"FLOAT",65:"DOUBLE",66:"SIGNED",67:"UNSIGNED",68:"_BOOL",69:"TYPE_NAME",70:"STRUCT",71:"UNION",72:"ENUM",73:"CONST",74:"INLINE",75:"IMPORT",76:"ELLIPSIS",77:"CASE",78:"DEFAULT",79:"IF",80:"ELSE",81:"SWITCH",82:"WHILE",83:"DO",84:"FOR",85:"GOTO",86:"CONTINUE",87:"BREAK",88:"RETURN"},TERROR:2,EOF:1,originalQuoteName:null,originalParseError:null,cleanupAfterParse:null,constructParseErrorInfo:null,yyMergeLocationInfo:null,__reentrant_call_depth:0,__error_infos:[],__error_recovery_infos:[],quoteName:function(e){return'"'+e+'"'},getSymbolName:function(e){if(this.terminals_[e])return this.terminals_[e];var t=this.symbols_;for(var n in t)if(t[n]===e)return n;return null},describeSymbol:function(e){if(e!==this.EOF&&this.terminal_descriptions_&&this.terminal_descriptions_[e])return this.terminal_descriptions_[e];if(e===this.EOF)return"end of input";var t=this.getSymbolName(e);return t?this.quoteName(t):null},collect_expected_token_set:function(e,t){var n=this.TERROR,i=[],r={};if(!t&&this.state_descriptions_&&this.state_descriptions_[e])return[this.state_descriptions_[e]];for(var s in this.table[e])if((s=+s)!==n){var a=t?s:this.describeSymbol(s);a&&!r[a]&&(i.push(a),r[a]=!0)}return i},productions_:function(e){for(var t=[],n=e.pop,i=e.rule,r=0,s=n.length;r<s;r++)t.push([n[r],i[r]]);return t}({pop:r([89,89,90,t,[91,5],92,93,93,t,[94,4],t,[95,8],96,96,t,[97,6],t,[98,6],99,99,t,[100,4],t,[101,3],t,[102,3],t,[103,5],t,[104,3],105,105,106,106,107,107,108,108,109,109,110,110,111,111,t,[112,11],113,113,114,115,115,t,[116,8],117,117,118,118,t,[119,3],t,[120,13],t,[121,3],122,122,123,123,124,t,[125,4],126,126,127,t,[128,5],129,129,130,130,131,132,132,133,133,t,[134,6],t,[135,4],136,136,137,137,138,138,t,[139,3],140,140,t,[141,3],t,[142,9],t,[143,3],144,144,t,[145,6],t,[146,3],147,147,148,148,149,149,150,150,t,[151,3],t,[152,6],t,[153,5],154,154,155,155,156]),rule:r([2,t,[1,9],i,[10,4],3,1,4,3,4,3,3,2,2,i,[10,3],t,[2,4],4,t,[1,7],4,1,t,[3,3],i,[4,3],i,[3,6],i,[8,7],i,[36,3],i,[4,6],5,i,[4,3],t,[1,11],i,[59,3],i,[3,3],i,[80,3],i,[4,4],i,[32,4],t,[1,15],5,4,i,[107,4],2,3,i,[31,4],i,[114,4],5,5,6,i,[40,8],i,[17,4],i,[130,4],i,[125,3],i,[67,4],i,[21,3],i,[139,3],i,[22,4],i,[46,3],3,3,4,i,[4,4],i,[33,3],i,[83,8],i,[41,3],i,[39,5],i,[31,3],5,7,5,5,7,6,7,6,7,i,[49,3],i,[20,6],3])}),performAction:function(e,t,n,i,r,s){var o=this.yy,c=o.parser,l=o.lexer;switch(n){case 0:this.$=void 0,this._$=s[i-1];break;case 1:return this.$=void 0,this._$=c.yyMergeLocationInfo(i-1,i),r[i-1];case 2:return this.$=void 0,this._$=s[i],[];case 3:case 9:case 100:case 101:case 102:case 103:case 104:case 105:case 106:case 107:case 108:case 109:case 110:case 111:case 142:this._$=s[i],this.$=e;break;case 4:this._$=s[i],this.$=new a.Constant(this._$,e,"float");break;case 5:this._$=s[i],this.$=new a.Constant(this._$,e,"hex");break;case 6:this._$=s[i],this.$=new a.Constant(this._$,e,"oct");break;case 7:this._$=s[i],this.$=new a.Constant(this._$,e,"int");break;case 8:this._$=s[i],this.$=new a.Constant(this._$,e,"char");break;case 10:case 13:case 16:case 26:case 38:case 40:case 44:case 47:case 50:case 55:case 58:case 60:case 62:case 64:case 66:case 68:case 70:case 83:case 98:case 113:case 114:case 130:case 144:case 167:case 178:case 183:case 184:case 185:case 186:case 187:case 188:case 196:case 197:case 216:this._$=s[i],this.$=r[i];break;case 11:this._$=c.yyMergeLocationInfo(i-1,i),this.$=r[i-1]+r[i];break;case 12:this._$=s[i],this.$=new a.Identifier(this._$,e);break;case 14:this._$=s[i],this.$=new a.StringLiteral(this._$,r[i]);break;case 15:case 146:case 169:case 179:this._$=c.yyMergeLocationInfo(i-2,i),this.$=r[i-1];break;case 17:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.BinaryExpression(this._$,"arraySubscript",r[i-3],r[i-1]);break;case 18:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.FunctionCallExpression(this._$,r[i-2]);break;case 19:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.FunctionCallExpression(this._$,r[i-3],r[i-1]);break;case 20:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.MemberAccessExpression(this._$,!1,r[i-2],r[i]);break;case 21:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.MemberAccessExpression(this._$,!0,r[i-2],r[i]);break;case 22:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.UnaryExpression(this._$,"postfixIncrement",r[i-1]);break;case 23:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.UnaryExpression(this._$,"postfixDecrement",r[i-1]);break;case 24:case 96:case 121:case 128:case 136:case 155:case 159:case 181:case 194:case 214:this._$=s[i],this.$=[r[i]];break;case 25:case 97:case 129:case 137:case 160:case 182:this._$=c.yyMergeLocationInfo(i-2,i),this.$=(r[i-2].push(r[i]),r[i-2]);break;case 27:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.UnaryExpression(this._$,"prefixIncrement",r[i]);break;case 28:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.UnaryExpression(this._$,"prefixDecrement",r[i]);break;case 29:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.UnaryExpression(this._$,r[i-1],r[i]);break;case 30:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.SizeofExpression(this._$,r[i]);break;case 31:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.SizeofExpression(this._$,r[i-1]);break;case 32:this._$=s[i],this.$="addressOf";break;case 33:this._$=s[i],this.$="dereference";break;case 34:this._$=s[i],this.$="unaryPlus";break;case 35:this._$=s[i],this.$="unaryMinus";break;case 36:this._$=s[i],this.$="bitwiseNot";break;case 37:this._$=s[i],this.$="logicalNot";break;case 39:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.CastExpression(this._$,r[i-2],r[i]);break;case 41:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"mul",r[i-2],r[i]);break;case 42:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"div",r[i-2],r[i]);break;case 43:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"mod",r[i-2],r[i]);break;case 45:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"add",r[i-2],r[i]);break;case 46:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"sub",r[i-2],r[i]);break;case 48:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"bitwiseShiftLeft",r[i-2],r[i]);break;case 49:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"bitwiseShiftRight",r[i-2],r[i]);break;case 51:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"relationalLT",r[i-2],r[i]);break;case 52:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"relationalGT",r[i-2],r[i]);break;case 53:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"relationalLEq",r[i-2],r[i]);break;case 54:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"relationalGEq",r[i-2],r[i]);break;case 56:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"relationalEq",r[i-2],r[i]);break;case 57:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"relationalNEq",r[i-2],r[i]);break;case 59:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"bitwiseAnd",r[i-2],r[i]);break;case 61:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"bitwiseXor",r[i-2],r[i]);break;case 63:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"bitwiseOr",r[i-2],r[i]);break;case 65:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"logicalAnd",r[i-2],r[i]);break;case 67:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"logicalOr",r[i-2],r[i]);break;case 69:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new a.ConditionalExpression(this._$,r[i-4],r[i-2],r[i]);break;case 71:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.AssignmentExpression(this._$,r[i-1],r[i-2],r[i]);break;case 72:this._$=s[i],this.$=void 0;break;case 73:this._$=s[i],this.$="mul";break;case 74:this._$=s[i],this.$="div";break;case 75:this._$=s[i],this.$="mod";break;case 76:this._$=s[i],this.$="add";break;case 77:this._$=s[i],this.$="sub";break;case 78:this._$=s[i],this.$="leftShift";break;case 79:this._$=s[i],this.$="rightShift";break;case 80:this._$=s[i],this.$="bitwiseAnd";break;case 81:this._$=s[i],this.$="bitwiseXor";break;case 82:this._$=s[i],this.$="bitwiseOr";break;case 84:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.BinaryExpression(this._$,"comma",r[i-2],r[i]);break;case 85:this._$=s[i],this.$=new a.ConstantExpression(this._$,r[i]);break;case 86:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.Declaration(this._$,r[i-1]);break;case 87:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.Declaration(this._$,r[i-2],r[i-1]);break;case 88:this._$=s[i],this.$=new a.DeclarationSpecifiers(this._$,[],[],[r[i]],[]);break;case 89:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.DeclarationSpecifiers(this._$,r[i].specifierList,r[i].qualifierList,[r[i-1],...r[i].storageList],r[i].fnSpecifierList);break;case 90:this._$=s[i],this.$=new a.DeclarationSpecifiers(this._$,[r[i]],[],[],[]);break;case 91:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.DeclarationSpecifiers(this._$,[r[i-1],...r[i].specifierList],r[i].qualifierList,r[i].storageList,r[i].fnSpecifierList);break;case 92:this._$=s[i],this.$=new a.DeclarationSpecifiers(this._$,[],[r[i]],[],[]);break;case 93:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.DeclarationSpecifiers(this._$,r[i].specifierList,[r[i-1],...r[i].qualifierList],r[i].storageList,r[i].fnSpecifierList);break;case 94:this._$=s[i],this.$=new a.DeclarationSpecifiers(this._$,[],[],[],[r[i]]);break;case 95:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.DeclarationSpecifiers(this._$,r[i].specifierList,r[i].qualifierList,r[i].storageList,[r[i-1],...r[i].fnSpecifierList]);break;case 99:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.InitDeclarator(this._$,r[i-2],r[i]);break;case 112:this._$=s[i],this.$="bool";break;case 115:this._$=s[i],this.$=new a.CustomTypeSpecifier(this._$,r[i]);break;case 116:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new a.StructUnionSpecifier(this._$,r[i-4],r[i-3],r[i-1]);break;case 117:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.StructUnionSpecifier(this._$,r[i-3],void 0,r[i-1]);break;case 118:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.StructUnionSpecifier(this._$,r[i-1],r[i]);break;case 119:this._$=s[i],this.$="struct";break;case 120:this._$=s[i],this.$="union";break;case 122:case 156:case 195:case 215:this._$=c.yyMergeLocationInfo(i-1,i),this.$=(r[i-1].push(r[i]),r[i-1]);break;case 123:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.StructDeclaration(this._$,r[i-2],r[i-1]);break;case 124:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.SpecifierQualifiers(this._$,[r[i-1],...r[i].specifierList],r[i].qualifierList);break;case 125:this._$=s[i],this.$=new a.SpecifierQualifiers(this._$,[r[i]],[]);break;case 126:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.SpecifierQualifiers(this._$,r[i].specifierList,[r[i-1],...r[i].qualifierList]);break;case 127:this._$=s[i],this.$=new a.SpecifierQualifiers(this._$,[],[r[i]]);break;case 131:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.EnumSpecifier(this._$,void 0,r[i-1]);break;case 132:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new a.EnumSpecifier(this._$,r[i-3],r[i-1]);break;case 133:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new a.EnumSpecifier(this._$,void 0,r[i-2]);break;case 134:this._$=c.yyMergeLocationInfo(i-5,i),this.$=new a.EnumSpecifier(this._$,r[i-4],r[i-2]);break;case 135:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.EnumSpecifier(this._$,r[i]);break;case 138:this._$=s[i],this.$=new a.Enumerator(this._$,r[i]);break;case 139:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.Enumerator(this._$,r[i-2],r[i]);break;case 140:this._$=s[i],this.$="const";break;case 141:this._$=s[i],this.$="inline";break;case 143:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.PointerDeclarator(this._$,r[i-1],r[i]);break;case 145:this._$=s[i],this.$=new a.IdentifierDeclarator(this._$,r[i]);break;case 147:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.ArrayDeclarator(this._$,r[i-3],r[i-1]);break;case 148:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.ArrayDeclarator(this._$,r[i-2]);break;case 149:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.FunctionDeclarator(this._$,r[i-3],r[i-1],r[i-1].variadic);break;case 150:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.FunctionDeclarator(this._$,r[i-2]);break;case 151:this._$=s[i],this.$=new a.Pointer(this._$);break;case 152:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.Pointer(this._$,r[i]);break;case 153:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.Pointer(this._$,void 0,r[i]);break;case 154:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.Pointer(this._$,r[i-1],r[i]);break;case 157:this._$=s[i],this.$=(r[i].variadic=!1,r[i]);break;case 158:this._$=c.yyMergeLocationInfo(i-2,i),this.$=(r[i-2].variadic=!0,r[i-2]);break;case 161:case 162:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.ParameterDeclaration(this._$,r[i-1],r[i]);break;case 163:this._$=s[i],this.$=new a.ParameterDeclaration(this._$,r[i]);break;case 164:this._$=s[i],this.$=new a.TypeName(this._$,r[i]);break;case 165:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.TypeName(this._$,r[i-1],r[i]);break;case 166:this._$=s[i],this.$=new a.AbstractPointerDeclarator(this._$,r[i]);break;case 168:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.AbstractPointerDeclarator(this._$,r[i-1],r[i]);break;case 170:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.AbstractArrayDeclarator(this._$);break;case 171:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.AbstractArrayDeclarator(this._$,void 0,r[i-1]);break;case 172:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.AbstractArrayDeclarator(this._$,r[i-2]);break;case 173:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.AbstractArrayDeclarator(this._$,r[i-3],r[i-1]);break;case 174:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.AbstractFunctionDeclarator(this._$);break;case 175:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.AbstractFunctionDeclarator(this._$,void 0,r[i-1],r[i-1].variadic);break;case 176:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.AbstractFunctionDeclarator(this._$,r[i-2]);break;case 177:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.AbstractFunctionDeclarator(this._$,r[i-3],r[i-1],r[i-1].variadic);break;case 180:this._$=c.yyMergeLocationInfo(i-3,i),this.$=r[i-2];break;case 189:this._$=c.yyMergeLocationInfo(i-2,i),this.$=r[i].setLabel(r[i-2]);break;case 190:this._$=c.yyMergeLocationInfo(i-3,i),this.$=new a.CaseStatement(this._$,r[i-2],r[i]);break;case 191:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.DefaultStatement(this._$,r[i]);break;case 192:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.CompoundStatement(this._$,[]);break;case 193:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.CompoundStatement(this._$,r[i-1]);break;case 198:this._$=s[i],this.$=new a.NoOp(this._$);break;case 199:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.ExpressionStatement(this._$,r[i-1]);break;case 200:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new a.IfStatement(this._$,r[i-2],r[i]);break;case 201:this._$=c.yyMergeLocationInfo(i-6,i),this.$=new a.IfStatement(this._$,r[i-4],r[i-2],r[i]);break;case 202:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new a.SwitchStatement(this._$,r[i-2],r[i]);break;case 203:this._$=c.yyMergeLocationInfo(i-4,i),this.$=new a.WhileLoop(this._$,r[i-2],r[i]);break;case 204:this._$=c.yyMergeLocationInfo(i-6,i),this.$=new a.DoWhileLoop(this._$,r[i-5],r[i-2]);break;case 205:case 207:this._$=c.yyMergeLocationInfo(i-5,i),this.$=new a.ForLoop(this._$,r[i-3],r[i-2],void 0,r[i]);break;case 206:case 208:this._$=c.yyMergeLocationInfo(i-6,i),this.$=new a.ForLoop(this._$,r[i-4],r[i-3],r[i-2],r[i]);break;case 209:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.GotoStatement(this._$,r[i-1]);break;case 210:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.ContinueStatement(this._$);break;case 211:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.BreakStatement(this._$);break;case 212:this._$=c.yyMergeLocationInfo(i-1,i),this.$=new a.ReturnStatement(this._$);break;case 213:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.ReturnStatement(this._$,r[i-1]);break;case 217:this._$=s[i],this.$=(l.externalDeclaration(r[i]),r[i]);break;case 218:this._$=c.yyMergeLocationInfo(i-2,i),this.$=new a.FunctionDefinition(this._$,r[i-2],r[i-1],r[i])}},table:function(e){for(var t=[],n=e.len,i=e.symbol,r=e.type,s=e.state,a=e.mode,o=e.goto,c=0,l=n.length;c<l;c++){for(var h=n[c],f={},u=0;u<h;u++){var d=i.shift();switch(r.shift()){case 2:f[d]=[a.shift(),o.shift()];break;case 0:f[d]=s.shift();break;default:f[d]=[3]}}t.push(f)}return t}({len:r([34,1,32,t,[0,4],10,t,[35,4],t,[0,19],3,3,t,[0,4],5,0,2,4,7,0,10,0,7,t,[0,5],28,23,4,28,0,40,91,0,8,7,39,32,9,0,0,1,23,23,0,9,26,26,2,0,3,4,0,0,41,0,37,8,42,25,25,26,25,i,[25,3],t,[0,5],10,0,0,44,61,11,t,[0,6],12,0,14,18,20,22,25,0,0,90,i,[25,6],t,[0,4],39,38,1,0,2,t,[1,3],59,1,i,[6,3],40,i,[113,3],1,t,[0,3],i,[19,3],i,[45,3],0,0,23,0,i,[9,3],t,[0,4],4,38,2,2,0,38,t,[0,11],39,35,39,40,i,[19,3],i,[9,3],t,[0,3],61,34,33,i,[68,3],7,32,31,30,30,t,[29,4],28,28,27,27,t,[26,3],0,0,59,1,59,0,38,t,[39,3],1,70,i,[85,4],i,[46,3],30,0,0,8,4,42,i,[51,3],8,i,[85,5],i,[174,3],2,9,2,i,[99,5],1,10,11,0,26,i,[103,3],12,14,18,18,t,[20,4],22,22,25,i,[168,3],i,[67,3],i,[56,3],2,2,1,41,41,i,[49,5],39,32,1,i,[156,3],i,[77,4],0,37,0,i,[144,5],t,[59,3],39,40,40,i,[21,8],0,52,i,[47,3],59,2,59,i,[82,3],59,1,i,[60,3],i,[62,3],0,0]),symbol:r([1,t,[56,20,1],89,115,116,t,[119,4,1],128,131,132,154,155,156,1,i,[35,21],i,[34,9],155,156,3,10,24,27,90,117,118,133,134,135,3,4,5,8,i,[13,3],i,[48,20],i,[47,8],i,[35,105],25,27,90,i,[3,3],8,23,24,25,147,8,24,3,27,90,134,i,[52,4],i,[14,3],i,[59,5],27,73,131,135,136,3,10,27,90,i,[181,9],25,i,[77,21],i,[17,15],t,[120,6,1],128,131,27,90,129,130,i,[55,28],3,t,[9,6,1],25,t,[27,7,1],35,36,37,t,[90,6,1],t,[97,15,1],143,i,[40,7],t,[24,10,1],i,[42,3],i,[80,20],77,78,79,t,[81,8,1],i,[73,21],113,i,[398,9],t,[145,9,1],i,[221,4],i,[403,8],i,[246,4],6,i,[107,6],i,[146,30],114,4,i,[338,28],137,138,139,i,[317,9],4,i,[282,23],26,i,[24,18],i,[23,4],i,[142,4],126,127,i,[143,6],10,27,i,[36,18],i,[35,4],i,[26,25],8,26,8,23,26,i,[371,5],i,[343,39],144,4,6,t,[8,5,1],t,[15,10,1],26,t,[38,18,1],112,i,[37,3],21,22,24,26,45,t,[3,10,1],i,[48,11],34,35,36,i,[51,18],i,[128,7],i,[127,18],i,[25,50],99,i,[26,25],i,[151,7],44,45,i,[9,3],i,[140,3],i,[10,4],i,[162,21],t,[33,4,1],i,[163,18],92,i,[88,17],i,[339,15],i,[576,22],i,[361,6],140,i,[115,3],i,[94,4],i,[126,7],9,i,[12,18],i,[109,4],i,[14,4],i,[134,6],24,26,i,[127,6],i,[18,12],i,[147,8],i,[20,4],11,12,i,[22,20],i,[199,11],i,[25,10],i,[778,85],i,[777,7],i,[1182,9],5,i,[325,16],i,[486,46],i,[810,13],22,i,[1109,3],t,[3,3],i,[183,8],i,[46,10],i,[162,33],i,[153,3],i,[152,5],27,90,24,24,i,[64,8],i,[722,31],113,i,[963,3],6,4,4,8,i,[895,6],i,[1205,4],141,142,i,[874,23],8,24,i,[811,3],i,[810,8],i,[196,31],i,[857,3],26,i,[42,37],111,i,[38,38],113,i,[39,35],i,[74,40],4,i,[40,22],t,[96,16,1],27,90,27,90,i,[157,56],i,[794,44],i,[100,34],i,[34,33],4,8,4,i,[1252,4],i,[443,3],i,[43,32],i,[32,31],i,[31,30],i,[30,59],i,[29,115],i,[28,55],i,[27,53],i,[26,59],i,[993,52],22,i,[1053,60],i,[918,111],i,[39,43],82,i,[1204,18],i,[1449,20],i,[1438,31],150,24,8,24,t,[56,21,1],i,[33,8],i,[2155,5],i,[2486,3],142,i,[8,4],i,[2076,5],i,[102,21],i,[47,8],i,[1299,3],i,[2207,3],i,[859,3],i,[2280,38],i,[2192,4],i,[2191,4],i,[1324,11],i,[1658,12],i,[2135,22],8,22,i,[1948,9],6,8,i,[974,3],i,[1953,10],i,[1848,11],i,[587,27],4,5,i,[205,4],10,i,[2403,28],i,[197,6],i,[1916,56],i,[1934,30],i,[20,60],i,[1994,22],i,[2016,43],i,[2041,34],i,[805,50],i,[387,3],i,[391,3],i,[1924,9],i,[697,32],150,i,[41,42],i,[627,4],i,[2865,70],i,[549,3],i,[856,37],i,[1009,45],i,[1106,59],i,[59,118],i,[2030,56],i,[40,56],6,4,i,[2640,43],t,[80,9,1],i,[588,3],i,[653,60],i,[61,120],i,[2629,9],i,[475,110]]),type:r([t,[2,21],t,[0,13],1,i,[35,32],i,[15,10],t,[2,27],i,[45,12],i,[35,103],i,[3,6],i,[5,8],i,[52,15],i,[69,6],i,[76,31],i,[92,25],i,[55,46],i,[338,16],i,[314,13],t,[2,47],t,[0,40],i,[43,8],i,[73,46],i,[491,36],i,[333,19],i,[409,26],i,[142,15],i,[97,21],i,[26,38],i,[35,21],i,[253,26],i,[329,34],t,[2,67],i,[112,25],i,[25,33],i,[51,43],i,[146,46],i,[576,61],t,[2,173],i,[777,42],i,[1182,34],i,[105,50],i,[162,65],i,[428,23],i,[409,35],i,[874,32],i,[927,19],i,[1006,54],i,[42,27],i,[576,39],i,[74,74],i,[40,24],i,[1420,3],i,[1389,71],i,[794,46],i,[34,50],i,[1657,13],i,[43,29],i,[32,31],i,[31,30],i,[30,59],i,[29,115],i,[28,55],i,[27,53],i,[26,69],i,[1357,73],i,[623,63],i,[918,78],i,[922,61],i,[1438,53],i,[56,33],i,[2037,26],i,[902,45],i,[314,25],i,[1413,8],i,[97,20],i,[1822,76],i,[116,13],i,[200,38],t,[2,266],i,[865,54],i,[48,41],i,[89,45],i,[2865,60],i,[73,33],i,[2165,68],i,[1166,59],i,[59,105],i,[2030,63],i,[938,93],i,[2875,93],i,[61,121],i,[475,88]]),state:r([1,t,[6,4,1],25,31,26,10,11,2,t,[4,6,1],i,[12,5],36,5,44,39,42,37,41,40,47,i,[16,7],48,i,[8,7],49,i,[8,7],50,i,[8,7],51,54,55,44,60,65,64,63,44,66,41,40,71,25,31,68,69,70,26,72,75,73,74,97,98,107,99,89,83,81,86,t,[115,6,-1],108,101,96,88,82,80,78,77,128,i,[22,19],142,132,119,121,i,[76,7],120,122,123,117,118,t,[124,4,1],44,143,144,41,40,i,[67,6],148,i,[45,12],147,145,153,i,[43,7],149,151,152,155,154,i,[112,3],157,i,[112,4],i,[8,3],159,i,[7,3],44,160,161,162,i,[133,5],163,i,[19,5],164,i,[137,3],168,i,[137,22],170,169,171,i,[24,6],191,86,i,[8,6],193,i,[8,7],148,86,194,i,[9,6],195,86,199,i,[58,20],142,200,i,[89,3],202,26,72,201,i,[202,34],219,i,[201,5],39,42,i,[202,23],221,i,[66,22],228,t,[122,6,1],230,i,[125,21],234,44,238,41,240,239,241,i,[239,7],75,248,i,[88,20],249,i,[58,20],254,i,[79,21],255,i,[64,17],256,i,[40,21],257,i,[22,6],259,i,[23,14],260,261,262,i,[290,22],i,[312,28],263,i,[115,16],264,i,[17,15],265,269,268,241,i,[19,14],271,i,[15,13],272,i,[14,12],273,i,[13,12],274,i,[13,11],275,i,[12,11],276,i,[12,11],277,i,[12,11],278,i,[12,10],279,i,[11,10],280,i,[11,9],281,i,[10,9],282,i,[10,8],283,i,[9,8],284,i,[9,8],285,i,[454,22],286,t,[122,7,1],i,[29,21],288,i,[29,6],i,[295,20],289,i,[316,21],290,i,[22,21],291,i,[22,21],292,i,[22,21],132,295,i,[665,8],294,i,[833,8],299,44,60,300,44,i,[13,8],66,41,240,305,151,152,303,i,[378,15],i,[593,6],307,44,308,i,[854,3],i,[621,8],i,[841,15],311,i,[50,8],317,300,i,[76,8],269,i,[74,5],i,[251,22],318,i,[251,26],142,132,323,i,[23,22],324,i,[149,20],326,i,[110,8],328,151,152,i,[32,19],332,i,[75,20],333,i,[148,22],334,i,[428,28],335,i,[29,28],336,i,[206,27],337,i,[22,21],339,i,[22,21],341,i,[95,22],346,i,[124,28],348,i,[29,28],350,i,[29,28],352,i,[29,28],353,i,[29,6]]),mode:r([t,[1,46],t,[2,7],i,[27,101],i,[31,5],1,i,[27,7],i,[9,3],i,[43,8],i,[18,5],i,[12,8],t,[2,20],i,[100,22],i,[44,38],t,[1,57],i,[96,6],i,[327,43],i,[218,8],i,[369,35],i,[20,35],i,[299,11],i,[352,20],i,[317,10],i,[250,19],i,[24,7],i,[67,6],i,[289,19],i,[310,86],i,[146,12],i,[412,22],i,[440,60],i,[236,15],i,[65,20],i,[8,22],i,[34,18],i,[30,22],i,[87,7],i,[55,20],i,[271,60],i,[246,30],i,[688,75],i,[561,7],i,[502,7],t,[1,217],i,[219,219],t,[1,232],i,[680,7],i,[458,70],i,[1605,13],i,[1062,14],i,[1676,26],i,[123,26],i,[1116,48],i,[1134,38],i,[20,60],i,[1194,23],i,[1216,42],i,[1241,80],i,[2006,28],i,[690,216],t,[2,42],i,[538,11],t,[1,155]]),goto:r([3,t,[12,13,1],27,33,34,32,28,29,30,35,i,[21,20],45,43,38,46,t,[88,7],i,[31,20],t,[90,7],i,[27,20],t,[92,7],i,[27,20],t,[94,7],i,[27,20],52,46,53,46,98,56,98,57,59,58,45,46,62,144,61,t,[144,4],t,[151,4],43,151,28,45,43,46,t,[118,6],67,t,[118,21],i,[74,15],46,t,[135,6],76,t,[135,21],100,t,[90,6,1],79,46,t,[102,5,1],109,84,85,87,i,[18,7],131,57,116,i,[20,10],i,[159,20],129,130,t,[133,9,1],i,[144,3],62,143,61,t,[143,4],100,146,i,[62,6],i,[59,10],150,i,[60,20],t,[152,4],43,152,28,156,i,[25,15],158,i,[16,15],i,[88,3],t,[125,5],i,[23,15],t,[127,5],i,[20,15],166,165,138,167,138,46,i,[206,18],t,[38,15],172,t,[38,10],t,[173,10,1],t,[68,3],183,t,[68,3],184,186,26,185,26,187,t,[26,16],188,189,190,t,[26,18],192,i,[230,16],i,[17,17],i,[138,7],i,[17,10],196,i,[17,16],t,[66,7],197,66,t,[64,3],198,t,[64,6],t,[14,21],109,t,[14,21],i,[96,17],i,[272,15],t,[62,3],203,t,[62,7],t,[60,3],204,t,[60,8],t,[58,10],205,206,58,58,t,[55,4],207,208,t,[55,6],209,210,t,[55,4],t,[50,12],211,212,t,[50,6],t,[47,4],213,214,t,[47,16],t,[44,4],215,44,44,216,217,t,[44,16],i,[576,9],218,i,[576,43],38,46,t,[12,15],220,t,[12,23],i,[248,17],222,224,223,225,226,227,i,[117,9],i,[25,10],i,[96,11],229,46,231,232,i,[34,7],233,i,[33,10],i,[860,3],235,236,157,237,242,163,243,163,43,46,244,i,[160,15],246,245,247,i,[590,8],i,[50,10],251,250,253,252,i,[21,17],i,[17,52],258,i,[18,16],46,i,[109,18],i,[482,32],i,[49,34],266,224,267,270,164,243,43,i,[178,69],i,[17,193],i,[539,23],287,i,[31,30],i,[129,68],293,i,[99,8],i,[784,30],296,224,297,i,[23,20],298,242,166,243,166,46,302,167,301,167,242,304,243,43,46,i,[35,20],100,306,i,[115,16],i,[1337,3],309,i,[1293,9],310,i,[24,10],224,312,t,[67,7],197,67,313,224,314,315,316,t,[65,3],198,t,[65,6],t,[63,3],203,t,[63,7],i,[193,17],270,166,243,270,i,[124,3],i,[123,20],t,[61,3],204,t,[61,8],t,[59,10],205,206,59,59,t,[56,4],207,208,t,[56,6],209,210,t,[56,4],t,[57,4],207,208,t,[57,6],209,210,t,[57,4],t,[51,12],211,212,t,[51,6],t,[52,12],211,212,t,[52,6],t,[53,12],211,212,t,[53,6],t,[54,12],211,212,t,[54,6],t,[48,4],213,214,t,[48,16],t,[49,4],213,214,t,[49,16],t,[45,4],215,45,45,216,217,t,[45,16],t,[46,4],215,46,46,216,217,t,[46,16],i,[554,30],319,224,320,224,321,224,322,i,[492,18],i,[18,18],302,168,301,168,100,325,i,[358,16],327,i,[352,20],329,330,331,i,[738,64],i,[30,67],i,[107,11],338,i,[18,17],340,i,[18,16],342,343,t,[200,43],344,t,[200,8],345,224,i,[139,30],347,i,[32,31],349,i,[32,31],351,i,[264,60]])}),defaultActions:function(e){for(var t={},n=e.idx,i=e.goto,r=0,s=n.length;r<s;r++){t[n[r]]=i[r]}return t}({idx:r([t,[3,4,1],t,[12,19,1],t,[33,4,1],38,42,44,t,[46,5,1],55,58,64,65,69,74,77,78,80,t,[89,7,1],97,98,t,[102,6,1],109,115,116,118,119,120,t,[122,6,1],131,142,143,146,147,t,[148,4,2],155,156,158,159,t,[161,5,1],170,t,[172,11,1],189,190,191,193,194,195,199,218,219,223,231,232,233,235,236,238,239,244,245,t,[247,4,1],252,254,258,260,261,262,266,268,t,[283,4,1],288,289,t,[296,4,1],304,306,t,[308,4,1],313,314,316,317,318,325,327,t,[329,5,1],335,336,342,343,346,348,t,[350,4,1]]),goto:r([2,214,216,217,t,[100,16,1],140,141,142,119,120,1,215,86,96,145,3,t,[89,4,2],218,87,153,155,121,136,99,178,70,16,t,[32,6,1],12,13,t,[4,5,1],10,9,40,192,194,196,197,t,[183,6,1],198,83,97,148,85,38,150,159,154,156,146,117,122,128,130,124,126,131,181,t,[72,11,1],22,23,t,[27,4,1],11,193,195,199,210,211,212,147,149,161,162,116,123,133,137,139,132,179,71,18,24,20,21,15,165,41,42,43,189,191,84,209,213,158,160,174,170,129,134,180,182,17,19,31,39,190,172,176,169,175,171,69,25,202,203,173,177,205,207,201,204,206,208])}),parseError:function(e,t,n){if(!t.recoverable)throw"function"==typeof this.trace&&this.trace(e),n||(n=this.JisonParserError),new n(e,t);"function"==typeof this.trace&&this.trace(e),t.destroy()},parse:function(e){var t,n,i,r=this,s=new Array(128),a=new Array(128),o=new Array(128),c=new Array(128),l=this.table,h=0,f=0,u=(this.TERROR,this.EOF),d=(this.options.errorRecoveryTokenDiscardCount,[0,354]);i=this.__lexer__?this.__lexer__:this.__lexer__=Object.create(this.lexer);var p={parseError:void 0,quoteName:void 0,lexer:void 0,parser:void 0,pre_parse:void 0,post_parse:void 0,pre_lex:void 0,post_lex:void 0};function _(e){if("object"==typeof e){var t={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t}return e}function y(e,t){for(var n in t)void 0===e[n]&&Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}function m(e){var t=_(e);return t&&t.range&&(t.range=t.range.slice(0)),t}function g(){var e=i.fastLex();return"number"!=typeof e&&(e=r.symbols_[e]||e),e||u}"function"!=typeof assert||assert,this.yyGetSharedState=function(){return p},y(p,this.yy),p.lexer=i,p.parser=this,"function"==typeof p.parseError?this.parseError=function(e,t,n){return n||(n=this.JisonParserError),p.parseError.call(this,e,t,n)}:this.parseError=this.originalParseError,"function"==typeof p.quoteName?this.quoteName=function(e){return p.quoteName.call(this,e)}:this.quoteName=this.originalQuoteName,this.cleanupAfterParse=function(e,t,n){var r,l;t&&((p.post_parse||this.post_parse)&&(l=this.constructParseErrorInfo(null,null,null,!1)),p.post_parse&&void 0!==(r=p.post_parse.call(this,p,e,l))&&(e=r),this.post_parse&&void 0!==(r=this.post_parse.call(this,p,e,l))&&(e=r),l&&l.destroy&&l.destroy());if(this.__reentrant_call_depth>1)return e;if(i.cleanupAfterLex&&i.cleanupAfterLex(n),p&&(p.lexer=void 0,p.parser=void 0,i.yy===p&&(i.yy=void 0)),p=void 0,this.parseError=this.originalParseError,this.quoteName=this.originalQuoteName,s.length=0,a.length=0,c.length=0,o.length=0,h=0,!n){for(var f=this.__error_infos.length-1;f>=0;f--){var u=this.__error_infos[f];u&&"function"==typeof u.destroy&&u.destroy()}this.__error_infos.length=0}return e},this.yyMergeLocationInfo=function(e,t,n,i,r){var s,a=0|e,o=0|t,l=n,f=i;if(!l&&null!=e)for(var u=a;u<=o&&!(l=c[u]);u++);if(!f&&null!=t)for(u=o;u>=a&&!(f=c[u]);u--);if(!l&&null==e){if(!r)for(u=(a||h)-1;u>=0&&!(l=c[u]);u--);return l?((s=_(l)).first_line=s.last_line,s.first_column=s.last_column,s.range&&(s.range=s.range.slice(0),s.range[0]=s.range[1]),f&&(y(s,f),s.last_line=f.last_line,s.last_column=f.last_column,s.range&&f.range&&(s.range[1]=f.range[1])),s):f?((s=_(f)).range&&(s.range=s.range.slice(0)),s):void 0}if(l||(l=f,f=null),l)return(s=_(l)).range&&(s.range=s.range.slice(0)),f&&(y(s,f),s.last_line=f.last_line,s.last_column=f.last_column,s.range&&f.range&&(s.range[1]=f.range[1])),s},this.constructParseErrorInfo=function(e,t,n,r){var l={errStr:e,exception:t,text:i.match,value:i.yytext,token:this.describeSymbol(f)||f,token_id:f,line:i.yylineno,loc:m(i.yylloc),expected:n,recoverable:r,state:b,action:v,new_state:E,symbol_stack:s,state_stack:a,value_stack:o,location_stack:c,stack_pointer:h,yy:p,lexer:i,parser:this,destroy:function(){var e=!!this.recoverable;for(var t in this)this.hasOwnProperty(t)&&"object"==typeof t&&(this[t]=void 0);this.recoverable=e}};return this.__error_infos.push(l),l};var b,v,w,C,A,x,S,E,L=function(){var e=i.lex();return"number"!=typeof e&&(e=r.symbols_[e]||e),e||u},I={$:!0,_$:void 0,yy:p},T=!1;try{if(this.__reentrant_call_depth++,i.setInput(e,p),"function"==typeof i.canIUse)i.canIUse().fastLex&&(L=g);for(t=i.yylloc,c[h]=t,o[h]=null,a[h]=0,s[h]=0,++h,n=i.yytext,this.pre_parse&&this.pre_parse.call(this,p),p.pre_parse&&p.pre_parse.call(this,p),E=a[h-1];;){if(b=E,this.defaultActions[b])v=2,E=this.defaultActions[b];else if(f||(f=L()),C=l[b]&&l[b][f]||d,E=C[1],!(v=C[0])){var P,N=this.describeSymbol(f)||f,O=this.collect_expected_token_set(b);P="number"==typeof i.yylineno?"Parse error on line "+(i.yylineno+1)+": ":"Parse error: ","function"==typeof i.showPosition&&(P+="\n"+i.showPosition(69,10)+"\n"),O.length?P+="Expecting "+O.join(", ")+", got unexpected "+N:P+="Unexpected "+N,A=this.constructParseErrorInfo(P,null,O,!1),void 0!==(w=this.parseError(A.errStr,A,this.JisonParserError))&&(T=w);break}switch(v){default:if(v instanceof Array){A=this.constructParseErrorInfo("Parse Error: multiple actions possible at state: "+b+", token: "+f,null,null,!1),void 0!==(w=this.parseError(A.errStr,A,this.JisonParserError))&&(T=w);break}A=this.constructParseErrorInfo("Parsing halted. No viable error recovery approach available due to internal system failure.",null,null,!1),void 0!==(w=this.parseError(A.errStr,A,this.JisonParserError))&&(T=w);break;case 1:s[h]=f,o[h]=i.yytext,c[h]=m(i.yylloc),a[h]=E,++h,f=0,n=i.yytext,t=i.yylloc;continue;case 2:if(x=(S=this.productions_[E-1])[1],void 0!==(w=this.performAction.call(I,n,t,E,h-1,o,c))){T=w;break}h-=x;var $=S[0];s[h]=$,o[h]=I.$,c[h]=I._$,E=l[a[h-1]][$],a[h]=E,++h;continue;case 3:-2!==h&&(T=!0,h--,void 0!==o[h]&&(T=o[h]))}break}}catch(e){if(e instanceof this.JisonParserError)throw e;if(i&&"function"==typeof i.JisonLexerError&&e instanceof i.JisonLexerError)throw e;A=this.constructParseErrorInfo("Parsing aborted due to exception.",e,null,!1),T=!1,void 0!==(w=this.parseError(A.errStr,A,this.JisonParserError))&&(T=w)}finally{T=this.cleanupAfterParse(T,!0,!0),this.__reentrant_call_depth--}return T}};s.originalParseError=s.parseError,s.originalQuoteName=s.quoteName;const a=n(3377);function o(){this.yy={}}return o.prototype=s,s.Parser=o,new o}();t.parser=i,t.Parser=i.Parser,t.parse=function(){return i.parse.apply(i,arguments)}},2993:()=>{}},t={};!function n(i){if(t[i])return t[i].exports;var r=t[i]={exports:{}};return e[i].call(r.exports,r,r.exports,n),r.exports}(4156)})();
//# sourceMappingURL=preprocessor.js.map